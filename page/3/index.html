<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/page/3/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 6.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-mysql" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/01/22/mysql/" class="article-date">
  <time class="dt-published" datetime="2023-01-22T03:54:01.952Z" itemprop="datePublished">2023-01-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="mysql"><a href="#mysql" class="headerlink" title="mysql"></a>mysql</h1><h2 id="mysql体系结构"><a href="#mysql体系结构" class="headerlink" title="mysql体系结构"></a>mysql体系结构</h2><p><strong>连接层</strong>：最上层是一些客户端和连接服务。<strong>主要完成一些类似于连接处理、授权认证、及相关的安全方案</strong>。在该层上引入了线程池的概念，为通过认证安全接入的客户端提供线程。同样在该层上可以实现基于SSL的安全链接。服务器也会为安全接入的每个客户端验证操作权限。</p>
<p><strong>服务层</strong>：第二层服务层，主要完成大部分的<strong>核心服务功能</strong>， 包括查询解析、分析、优化、缓存、以及所有的内置函数，所有跨存储引擎的功能也都在这一层实现，包括触发器、存储过程、视图等。</p>
<p><strong>引擎层</strong>：第三层存储引擎层，存储引擎就是存储数据、建立索引、更新&#x2F;查询数据等技术的实现方式。<strong>存储引擎真正的负责了MySQL中数据的存储和提取</strong>。存储引擎是基于表的，而不是基于库的，<strong>不同的表可以有不同的存储引擎</strong>。服务器通过API与存储引擎进行通信。不同的存储引擎具有的功能不同，这样我们可以根据自己的实际需要进行选取。</p>
<p><strong>存储层</strong>：第四层为数据存储层，主要是将<strong>数据存储在运行于该设备的文件系统</strong>之上，并完成与存储引擎的交互。</p>
<p><img src="C:\Users\hufei\AppData\Roaming\Typora\typora-user-images\mysqlarchitecture.png" alt="img"></p>
<h2 id="InnoDB存储结构"><a href="#InnoDB存储结构" class="headerlink" title="InnoDB存储结构"></a>InnoDB存储结构</h2><p>InnoDB 的数据是按「数据页」为单位来读写的，默认数据页大小为 16 KB。每个数据页之间通过双向链表的形式组织起来，物理上不连续，但是逻辑上连续。</p>
<p><img src="C:\Users\hufei\AppData\Roaming\Typora\typora-user-images\image-20220603121225077.png" alt="image-20220603121225077"></p>
<p>数据页内包含用户记录，每个记录之间用单向有序链表的方式组织起来，为了加快在数据页内高效查询记录，设计了一个页目录，页目录存储各个槽（分组），且主键值是有序的，于是可以通过二分查找法的方式进行检索从而提高效率。</p>
<p><img src="C:\Users\hufei\AppData\Roaming\Typora\typora-user-images\image-20220603121302165.png" alt="image-20220603121302165"></p>
<p>为了高效查询记录所在的数据页，InnoDB 采用 b+ 树作为索引，每个节点都是一个数据页。</p>
<p><img src="C:\Users\hufei\AppData\Roaming\Typora\typora-user-images\image-20220603121415375.png" alt="image-20220603121415375"></p>
<h2 id="DML-DDL-DCL"><a href="#DML-DDL-DCL" class="headerlink" title="DML,DDL,DCL"></a>DML,DDL,DCL</h2><p> DML（Data Manipulation Language，数据操作语言）：用于<strong>检索或者修改数据</strong>。<br> DML包括： </p>
<p>​	SELECT：用于检索数据；<br>​    INSERT：用于增加数据到数据库；<br>​    UPDATE：用于从数据库中修改现存的数据<br>​    DELETE：用于从数据库中删除数据。</p>
<p> DDL（Data Definition Language，数据定义语言）： 用于<strong>定义数据的结构</strong>，比如创建、修改或者删除数据库对象。<br> DDL包括：DDL语句可以用于创建用户和重建数据库对象。下面是DDL命令：<br>    CREATE TABLE：创建表<br>    ALTER TABLE<br>    DROP TABLE：删除表<br>    CREATE INDEX<br>    DROP INDEX</p>
<p> DCL（Data Control Language，数据控制语言）：用于<strong>定义数据库用户的权限</strong>。<br> DCL包括：<br>    ALTER PASSWORD<br>    GRANT<br>    REVOKE<br>    CREATE SYNONYM</p>
<h2 id="sql语句"><a href="#sql语句" class="headerlink" title="sql语句"></a>sql语句</h2><h3 id="sql语句执行过程"><a href="#sql语句执行过程" class="headerlink" title="sql语句执行过程"></a>sql语句执行过程</h3><h4 id="一条查询语句执行过程"><a href="#一条查询语句执行过程" class="headerlink" title="一条查询语句执行过程"></a>一条查询语句执行过程</h4><p>1.<strong>客户端发出请求</strong></p>
<p>2.<strong>mysql连接器连接客户端</strong>（验证用户身份，给予权限）。</p>
<p>​	连接有长连接和短连接。长连接是指连接成功后，如果客户端持续有请求，则一直使用同一个连接。短连接则是指每次执行完很少的几次查询就断开连接，下次查询再重新建立一个。<strong>尽量使用长连接</strong>。</p>
<p>3.<strong>查询缓存</strong>。</p>
<p>​	之前执行过的语句及其结果可能会以key-value对的形式，被直接缓存在内存中。key是查询的语句，value是查询的结果。<strong>MySQL 8.0版本之后已经没有此功能</strong>。</p>
<p>4.<strong>分析器（对SQL语句进行语法分析和词法分析操作）</strong></p>
<p>​	MySQL 需要知道你要做什么，因此需要对 SQL 语句做解析。<br>​	<strong>词法分析：</strong>你输入的是由多个字符串和空格组成的一条 SQL 语句，MySQL 需要识别出里面的字符串分别是什么，代表什么。检查查询的表或者列是否存在。</p>
<p>​	<strong>语法分析：</strong>语法分析器会根据语法规则，判断你输入的这个 SQL 语句是否满足 MySQL 语法。比如 select 少打了开头的字母“s”</p>
<p>5.<strong>优化器（主要对执行的SQL优化，执行最优的方案）</strong><br>     在开始执行之前，还要先经过优化器的处理。同一条sql语句可以有多个执行方案，但是执行的效率会有不同，而优化器的作用就是决定选择使用哪一个方案。优化器是在表里面有多个索引的时候，决定使用哪个索引；或者在一个语句有多表关联（join）的时候，决定各个表的连接顺序。</p>
<p>6.<strong>执行器（先检查用户是否有执行权限，有才会使用这个引擎提供的接口）</strong><br>    开始执行的时候，要先判断一下你对这个表 T 有没有执行查询的权限，如果没有，就会返回没有权限的错误，如果有权限，就打开表继续执行。打开表的时候，执行器就会根据表的引擎定义，去使用这个引擎提供的接口。</p>
<p>​	执行器循环调用引擎接口获取每行数据，这些接口都是引擎中已经定义好的。最后将所有满足条件的行组成的记录集作为结果集返回给客户端</p>
<p><strong>一条简单的查询语句</strong>。<code>select * from name = &quot;花一个无所&quot;</code></p>
<ol>
<li>判断 <code>buffer pool</code> 中是否存在这条数据</li>
<li>如果不存在则查磁盘。如果存在则读入<code>buffer pool</code> </li>
<li>判断 <code>change buffer</code> 中是否有这条数据。如果存在则 merge并写入<code>buffer pool</code> </li>
<li>返回 merge 之后的数据</li>
</ol>
<h4 id="更新语句执行过程"><a href="#更新语句执行过程" class="headerlink" title="更新语句执行过程"></a>更新语句执行过程</h4><p>前五个步骤与查询语句相同，关键在于执行器不同。InnoDB更新语句操作如下，以update T set c&#x3D;c+1 where ID&#x3D;2为例</p>
<ol>
<li>执行器先找引擎取ID&#x3D;2这一行。</li>
<li>执行器拿到引擎给的行数据，把这个值加上1，比如原来是N，现在就是N+1，得到新的一行数据，再调用引擎接口写入这行新数据。</li>
<li>引擎将这行新数据<strong>更新到内存中</strong>，同时将这个更新操作记录到redo log里面，此时redo log处于prepare状态。然后告知执行器执行完成了，随时可以提交事务。</li>
<li>执行器生成这个操作的binlog，并把binlog写入磁盘。</li>
<li>执行器调用引擎的提交事务接口，引擎把刚刚写入的redo log改成提交（commit）状态，更新完成。</li>
</ol>
<p><strong>一条根据普通索引简单的更新语句</strong>。<code>where name =  &quot;花一个无所&quot;</code></p>
<ol>
<li>判断 <code>buffer pool</code> 中是否存在这条数据</li>
<li>若存在则直接更新 <code>buffer pool</code></li>
<li>否则将改动写入 <code>change buffer</code></li>
<li>写 <code>redo log</code></li>
</ol>
<p><strong>一条根据唯一索引更新的语句</strong>。<code>where uniqId = 7</code></p>
<ol>
<li>判断 <code>buffer pool</code>  中是否存在这条数据</li>
<li>若存在则直接更新 <code>buffer pool</code></li>
<li>否则查磁盘，存在则读入 <code>buffer pool</code></li>
<li>更新 <code>buffer pool</code></li>
<li>写 <code>redo log</code></li>
</ol>
<h5 id="先更新内存数据，不直接更新磁盘数据的原因"><a href="#先更新内存数据，不直接更新磁盘数据的原因" class="headerlink" title="先更新内存数据，不直接更新磁盘数据的原因"></a>先更新内存数据，不直接更新磁盘数据的原因</h5><p>MySQL里如果在每次事务提交的时候，将该事务涉及修改的数据页全部刷新到磁盘中，这整个过程IO成本、查找成本都很高。</p>
<ol>
<li>Innodb 是以页为单位进行磁盘交互的，而一个事务很可能只修改一个数据页里面的几个字节，这个时候将完整的数据页刷到磁盘的话，太浪费资源了！</li>
<li>一个事务可能涉及修改多个数据页，并且这些数据页在物理上并不连续，使用随机IO写入性能太差</li>
<li>磁盘IO缓慢</li>
</ol>
<p>对于mysql来说，所有的变更都必须先更新缓冲池中的数据，然后缓冲池中的脏页会以一定的频率被刷入磁盘（<strong>checkPoint</strong>机制），通过缓冲池来优化CPU和磁盘之间的鸿沟，这样就可以保证整体的性能不会下降太快。</p>
<h5 id="redo-log"><a href="#redo-log" class="headerlink" title="redo log"></a>redo log</h5><p><strong>作用</strong>：保证事务的持久性</p>
<p>缓冲池可以帮助我们消除CPU和磁盘之间的鸿沟，checkpoint机制可以保证数据的最终落盘，然而由于checkpoint并不是每次变更的时候就触发的，而是master线程隔一段时间去处理的。所以最坏的情况就是刚写完缓冲池，数据库宕机了，那么这段数据就是丢失的，无法恢复。这样的话就不满足ACID中的D，为了解决这种情况下的持久化问题，InnoDB引擎的事务采用了WAL技术（Write-Ahead Logging），这种技术的思想就是先写日志，再写磁盘，只有日志写入成功，才算事务提交成功，这里的日志就是redo log。当发生宕机且数据未刷到磁盘的时候，可以通过redo log来恢复，保证ACID中的D，这就是redo log的作用。</p>
<p> 与从缓冲区写入磁盘相比，写redo log性能更高。redo log <strong>只记录事务对数据页做了哪些修改</strong>，这样就能完美地解决性能问题了(相对而言文件更小并且是顺序IO)。redo log是对页的物理修改，第x页的第x位置修改成xx，比如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">page(2,4),offset 64,value 2</span><br></pre></td></tr></table></figure>

<p><strong>redo log 包括两部分</strong>：一个是内存中的日志缓冲( redo log buffer )，另一个是磁盘上的日志文件( redo log file )。 mysql 每执行一条 DML 语句，先将记录写入 redo log buffer ，后续某个时间点再一次性将多个操作记录写到 redo log file 。</p>
<p>具体来说，当有一条记录需要更新的时候，InnoDB引擎就会先把记录写到redo log里面，并更新内存，这个时候更新就算完成了。同时，InnoDB引擎会在适当的时候，将这个操作记录更新到磁盘里面，如系统比较空闲或者redo log写满的时候。</p>
<p>redo log采用循环写，会发生覆盖。文件中有write pos和checkpoint。write pos是当前记录的位置，一边写一边后移，写到文件末尾后回到文件开头。checkpoint是当前要擦除的位置，也是往后推移并且循环的，擦除记录前要把记录更新到数据文件。</p>
<p>如果write pos追上checkpoint，表示log满了，这时候不能再执行新的更新，得停下来先擦掉一些记录，把checkpoint推进一下。</p>
<p>有了redo log，InnoDB就可以保证即使数据库发生异常重启，之前提交的记录都不会丢失，这个能力称为<strong>crash-safe</strong>。</p>
<h5 id="两阶段提交"><a href="#两阶段提交" class="headerlink" title="两阶段提交"></a><strong>两阶段提交</strong></h5><p>两阶段、三阶段都是为了解决分布式事务中的数据一致性问题</p>
<p>所谓两阶段提交，其实就是把 redo log 的写入拆分成了两个步骤：prepare 和 commit。这是为了解决bin log 与 redo log 的一致性问题，从而使从库用bin log同步时数据跟主库保持一致。</p>
<p>首先，存储引擎将执行更新好的新数据存到内存中，同时将这个更新操作记录到 redo log 里面，此时 redo log 处于 prepare 状态。然后告知执行器执行完成了，随时可以提交事务</p>
<p>然后执行器生成这个操作的 bin log，并把 bin log 写入磁盘</p>
<p>最后执行器调用存储引擎的提交事务接口，存储引擎把刚刚写入的 redo log 状态改成提交(commit)状态，更新完成</p>
<p>如果数据库在写入 redo log(prepare) 阶段之后、写入 binlog 之前，发生了崩溃：</p>
<p>此时 redo log 里面的事务处于 prepare 状态，binlog 还没写，之后从库进行同步的时候，无法执行这个操作，但是实际上主库已经完成了这个操作，所以为了主备一致，MySQL 崩溃时会在主库上回滚这个事务</p>
<p> 而如果数据库在写入 binlog 之后，redo log 状态修改为 commit 前发生崩溃，此时 redo log 里面的事务仍然是 prepare 状态，binlog 存在并完整，这样之后就会被从库同步过去，但是实际上主库并没有完成这个操作，所以为了主备一致，即使在这个时刻数据库崩溃了，恢复后仍会重新提交事务。</p>
<h5 id="bin-log"><a href="#bin-log" class="headerlink" title="bin log"></a>bin log</h5><p>binlog 用于记录数据库执行的写入性操作(不包括查询)信息，以二进制的形式保存在磁盘中。 binlog 是 mysql的逻辑日志，并且由 Server 层进行记录，使用任何存储引擎的 mysql 数据库都会记录 binlog 日志。</p>
<ul>
<li><strong>逻辑日志</strong>： 可以简单理解为记录的就是sql语句 。</li>
<li><strong>物理日志</strong>： mysql 数据最终是保存在数据页中的，物理日志记录的就是数据页变更 。</li>
</ul>
<p>binlog 是通过追加的方式进行写入的，可以通过 max_binlog_size 参数设置每个 binlog文件的大小，当文件大小达到给定值之后，会生成新的文件来保存日志。</p>
<p>在实际应用中， binlog 的主要使用场景有两个，分别是 <strong>主从复制</strong> 和 <strong>数据恢复</strong> 。</p>
<ol>
<li><strong>主从复制</strong> ：在 Master 端开启 binlog ，然后将 binlog 发送到各个 Slave 端， Slave 端重放 binlog 从而达到主从数据一致。</li>
<li><strong>数据恢复</strong> ：通过使用 mysqlbinlog 工具来恢复数据。</li>
</ol>
<p><strong>bin log和redo log不同之处</strong></p>
<p>bin log和redo log有以下不同。</p>
<ol>
<li>redo log是InnoDB引擎特有的；binlog是MySQL的Server层实现的，所有引擎都可以使用。</li>
<li>redo log是物理日志，记录的是“在某个数据页上做了什么修改”；binlog是逻辑日志，记录的是这个语句的原始逻辑。</li>
<li>redo log是循环写的，文件大小固定会用完；binlog是可以追加写入的，可以设置每个文件大小，binlog文件写到一定大小后会切换到下一个，并不会覆盖以前的日志。</li>
<li>redo log 适用于崩溃恢复(crash-safe)；binlog 适用于主从复制和数据从备份恢复</li>
</ol>
<h5 id="崩溃恢复"><a href="#崩溃恢复" class="headerlink" title="崩溃恢复"></a>崩溃恢复</h5><p><strong>redo log能用于崩溃恢复的原因</strong></p>
<p>redo log <strong>只会记录未刷入磁盘的日志</strong>，已经刷入磁盘的数据都会从 redo log 这个有限大小的日志文件里删除。</p>
<p>而 bin log 是追加日志，<strong>保存的是全量的日志</strong>。这就会导致一个问题，那就是没有标志能让 InnoDB 从 bin log 中判断哪些数据已经刷入磁盘了，哪些数据还没有。</p>
<p>因此数据库重启后，直接把 redo log 中的数据都恢复至内存就可以了。这就是为什么说 redo log 具有崩溃恢复的能力，而 bin log 不具备。</p>
<p>但是如果不小心整个数据库的数据被删除了，能使用redo log文件恢复数据吗？此时不可以使用redo log文件恢复，只能使用binlog文件从备份恢复。因为redo log文件不会存储历史所有的数据的变更，当内存数据刷新到磁盘中，redo log的数据就失效了，也就是redo log文件内容是会被覆盖的。</p>
<p><strong>恢复步骤</strong></p>
<p>根据两阶段提交，崩溃恢复时的判断规则是这样的：</p>
<p>如果 redo log 里面的事务是完整的，也就是已经有了 commit 标识，则直接提交</p>
<p>如果 redo log 里面的事务处于 prepare 状态，则判断对应的事务 binlog 是否存在并完整（一个事务的 binlog 有完整格式，mysql可以判断）</p>
<ul>
<li>a. 如果 binlog 存在并完整，则提交事务;</li>
<li>b. 否则，回滚事务。</li>
</ul>
<h5 id="change-buffer"><a href="#change-buffer" class="headerlink" title="change buffer"></a>change buffer</h5><p>change buffer是 <code>buffer pool</code>中的一块缓冲区，存储的是<strong>普通二级索引页</strong>的数据变更。它主要解决的是<strong>随机读磁盘IO</strong>消耗大的问题。</p>
<p>当有一条更新语句进来对某条数据进行修改时，需要找到这条数据，优先从 <code>buffer pool</code> 中找，不存在则从磁盘获取。将数据页从磁盘读入 <code>buffer pool</code> 涉及随机 IO 访问，这是数据库中成本最高的操作之一。所以有了这么一块缓冲区之后，针对某些写入或修改操作，直接把改动缓存在 <code>change buffer</code> 中，省去将数据从磁盘读入的过程。当下次查询的时候再从磁盘读出原始数据，将原始数据和 <code>change buffer</code> 中的改动做 merge 之后返回。</p>
<p><code>change buffer</code> 虽然是缓冲区。但其实它是可以持久化的，它持久化的地方默认是 <code>ibdata1</code>  共享空间表中(change buffer的写盘策略跟数据一样，内存放不下会触发落盘，还有checkpoint推进的时候也可能会触发)。因为为了保证数据的一致性。同时， <code>change buffer</code> 也是需要写 <code>redo log</code> 的。所以 <code>redo log</code> 里不仅有针对普通数据页的改动记录，也有 <code>change buffer</code> 的记录。</p>
<p>change buffer适合<strong>写多读少</strong>的业务场景，这种业务模型常见的就是账单类、日志类的系统。反过来，假设一个业务的更新模式是写入之后马上会做查询，那么即使满足了条件，将更新先记录在change buffer，但之后由于马上要访问这个数据页，会立即触发merge过程。这样随机访问IO的次数不会减少，反而增加了change buffer的维护代价。所以，对于这种业务模式来说，change buffer反而起到了副作用。</p>
<p><strong>唯一索引无法使用change buffer</strong>，因为唯一索引更新时需要进行唯一性检查，这必须要将数据从磁盘读入才能判断。</p>
<h3 id="buffer-pool"><a href="#buffer-pool" class="headerlink" title="buffer pool"></a>buffer pool</h3><p> MySQL 的数据是存储在磁盘里的，每次都从磁盘里面读取数据性能是极差的。</p>
<p>为此，Innodb 存储引擎设计了一个<strong>缓冲池(Buffer Pool）</strong>，来提高数据库的读写性能。</p>
<p>有了缓冲池后：</p>
<ul>
<li>当读取数据时，如果数据存在于 Buffer Pool 中，客户端就会直接读取 Buffer Pool 中的数据，否则再去磁盘中读取。</li>
<li>当修改数据时，首先是修改 Buffer Pool 中数据所在的页，然后将其页设置为脏页，最后由后台线程将脏页写入到磁盘。</li>
</ul>
<p><img src="C:\Users\hufei\AppData\Roaming\Typora\typora-user-images\image-20220603140803847.png" alt="image-20220603140803847"></p>
<p>为了更好的管理这些在 Buffer Pool 中的缓存页，InnoDB 为每一个缓存页都创建了一个<strong>控制块</strong>，控制块信息包括「缓存页的表空间、页号、缓存页地址、链表节点」等等。</p>
<p>当我们查询一条记录时，InnoDB 会把整个页的数据加载到 Buffer Pool 中，因为，通过索引只能定位到磁盘中的页，而不能定位到页中的一条记录。将页加载到 Buffer Pool 后，再通过页里的页目录去定位到某条具体的记录。</p>
<p><strong>如何管理空闲页</strong></p>
<p>为了能够快速找到空闲的缓存页，可以使用链表结构，将空闲缓存页的「控制块」作为链表的节点，这个链表称为 <strong>Free 链表</strong>（空闲链表）。</p>
<p>有了 Free 链表后，每当需要从磁盘中加载一个页到 Buffer Pool 中时，就从 Free链表中取一个空闲的缓存页，并且把该缓存页对应的控制块的信息填上，然后把该缓存页对应的控制块从 Free 链表中移除。</p>
<p><strong>如何管理脏页</strong></p>
<p>更新数据的时候，不需要每次都要写入磁盘，而是将 Buffer Pool 对应的缓存页标记为<strong>脏页</strong>，然后再由后台线程将脏页写入到磁盘。</p>
<p>那为了能快速知道哪些缓存页是脏的，于是就设计出 <strong>Flush 链表</strong>，它跟 Free 链表类似的，链表的节点也是控制块，区别在于 Flush 链表的元素都是脏页。</p>
<p><strong>如何管理脏页+干净页</strong></p>
<p>干净页，表示此页已被使用，但是页面未发生修改。使用<strong>LRU 链表（Least recently used）</strong>管理脏页+干净页，也就是说<strong>脏页同时存在于 LRU 链表和 Flush 链表</strong>。</p>
<p>简单的 LRU 算法并没有被 MySQL 使用，因为简单的 LRU 算法无法避免下面这两个问题：</p>
<ul>
<li>预读失效；</li>
<li>Buffer Pool 污染；</li>
</ul>
<p>程序有空间局部性的，靠近当前被访问数据的数据，在未来很大概率会被访问到。因此MySQL 在加载数据页时，会提前把它相邻的数据页一并加载进来，这就是预读。但是可能这些被提前加载进来的数据页，并没有被访问，相当于这个预读是白做了，这个就是<strong>预读失效</strong>。如果这些预读页如果一直不会被访问到，就会出现一个很奇怪的问题，<strong>不会被访问的预读页却占用了 LRU 链表前排的位置</strong>，而末尾淘汰的页，可能是频繁访问的页，这样就大大降低了缓存命中率。</p>
<p><strong>如何解决预读失效</strong></p>
<p>MySQL 是这样做的，它改进了 LRU 算法，将 LRU 划分了 2 个区域：<strong>old 区域 和 young 区域</strong>。young 区域在 LRU 链表的前半部分，old 区域则是在后半部分，如下图：</p>
<p><img src="C:\Users\hufei\AppData\Roaming\Typora\typora-user-images\image-20220605025934160.png" alt="image-20220605025934160"></p>
<p>old 区域占整个 LRU 链表长度的比例可以通过 <code>innodb_old_blocks_pc</code> 参数来设置，默认是 37，代表整个 LRU 链表中 young 区域与 old 区域比例是 63:37。</p>
<p><strong>划分这两个区域后，预读的页就只需要加入到 old 区域的头部，当页被真正访问的时候，才将页插入 young 区域的头部</strong>。如果预读的页一直没有被访问，就会从 old 区域移除，这样就不会影响 young 区域中的热点数据。</p>
<p><strong>如何解决Buffer Pool 污染</strong></p>
<p>当某一个 SQL 语句<strong>扫描了大量的数据</strong>时，在 Buffer Pool 空间比较有限的情况下，可能会将 <strong>Buffer Pool 里的所有页都替换出去，导致大量热数据被淘汰了</strong>，等这些热数据又被再次访问的时候，由于缓存未命中，就会产生大量的磁盘 IO，MySQL 性能就会急剧下降，这个过程被称为 <strong>Buffer Pool 污染</strong>。</p>
<p>像前面这种全表扫描的查询，很多缓冲页其实只会被访问一次，但是它却只因为被访问了一次而进入到 young 区域，从而导致热点数据被替换了。LRU 链表中 young 区域就是热点数据，只要我们<strong>提高进入到 young 区域的门槛</strong>，就能有效地保证 young 区域里的热点数据不会被替换掉。</p>
<p>MySQL 是这样做的，进入到 young 区域条件增加了一个<strong>停留在 old 区域的时间判断</strong>。</p>
<p>具体是这样做的，在对某个处在 old 区域的缓存页进行第一次访问时，就在它对应的控制块中记录下来这个访问时间：</p>
<ul>
<li>如果后续的访问时间与第一次访问的时间<strong>在某个时间间隔内</strong>，那么<strong>该缓存页就不会被从 old 区域移动到 young 区域的头部</strong>；</li>
<li>如果后续的访问时间与第一次访问的时间<strong>不在某个时间间隔内</strong>，那么<strong>该缓存页移动到 young 区域的头部</strong>；</li>
</ul>
<p>这个间隔时间是由 <code>innodb_old_blocks_time</code> 控制的，默认是 1000 ms。</p>
<p>也就说，<strong>只有同时满足「被访问」与「在 old 区域停留时间超过 1 秒」两个条件，才会被插入到 young 区域头部</strong>，这样就解决了 Buffer Pool 污染的问题 。</p>
<p>另外，MySQL 针对 young 区域其实做了一个优化，为了防止 young 区域节点频繁移动到头部。young 区域前面 1&#x2F;4 被访问不会移动到链表头部，只有后面的 3&#x2F;4被访问了才会。</p>
<p><strong>脏页什么时候会被刷入磁盘</strong></p>
<p>下面几种情况会触发脏页的刷新：</p>
<ul>
<li>当 redo log 日志满了的情况下，会主动触发脏页刷新到磁盘；</li>
<li>Buffer Pool 空间不足时，需要将一部分数据页淘汰掉，如果淘汰的是脏页，需要先将脏页同步到磁盘；</li>
<li>MySQL 认为空闲时，后台线程回定期将适量的脏页刷入到磁盘；</li>
<li>MySQL 正常关闭之前，会把所有的脏页刷入到磁盘；</li>
</ul>
<h3 id="sql流程控制函数"><a href="#sql流程控制函数" class="headerlink" title="sql流程控制函数"></a>sql流程控制函数</h3><table>
<thead>
<tr>
<th>函数</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>IF(expr1,expr2,expr3)</td>
<td>如果expr1是真, 返回expr2, 否则返回expr3</td>
</tr>
<tr>
<td>IFNULL(expr1,expr2)</td>
<td>如果expr1不是NULL,返回expr1,否则返回expr2</td>
</tr>
<tr>
<td>CASE WHEN [value1] THEN[result1]… ELSE[default] END</td>
<td>如果value是真, 返回result1,否则返回default</td>
</tr>
<tr>
<td>CASE [expr] WHEN [value1] THEN[result1]… ELSE[default] END</td>
<td>如果expr等于value1, 返回result1,否则返回default</td>
</tr>
</tbody></table>
<p><strong>case when 相当于if…else if…</strong></p>
<p>查询员工的信息，<br>如果薪资高于20000，显示该员工是“高富帅”，<br>如果薪资在15000-20000之间，显示“潜力股”<br>如果薪资在10000-15000之间，显示“有为青年”<br>如果薪资在10000以下，显示“屌丝”</p>
<p>SELECT ename, salary,<br>CASE<br>WHEN salary&gt;&#x3D;20000 THEN “高富帅”<br>WHEN salary&gt;&#x3D;15000 THEN “潜力股”<br>WHEN salary&gt;&#x3D;10000 THEN “有为青年”<br>ELSE “屌丝”<br>END AS “标签”<br>FROM t_employee;</p>
<p><strong>case [expr] when相当于switch…case</strong></p>
<p>#查询订单表，显示订单编号，和订单状态，如果订单状态是0，显示新订单，是1，显示已付款…</p>
<p>SELECT oid ,price,<br>CASE state<br>WHEN 0 THEN “新建订单”<br>WHEN 1 THEN “已付款”<br>WHEN 2 THEN “已发货”<br>WHEN 3 THEN “已收货”<br>END<br>FROM t_order</p>
<h3 id="sql语句执行顺序"><a href="#sql语句执行顺序" class="headerlink" title="sql语句执行顺序"></a>sql语句执行顺序</h3><ol>
<li>from </li>
<li>join </li>
<li>on </li>
<li>where </li>
<li>group by(开始使用select中的别名，后面的语句中都可以使用)</li>
<li>avg,sum…. </li>
<li>having </li>
<li>select </li>
<li>distinct </li>
<li>order by</li>
<li>limit</li>
</ol>
<p>第一步：首先对from子句中的前两个表执行一个笛卡尔乘积，此时生成虚拟表 vt1（选择相对小的表做基础表）。<br>第二步：接下来便是应用on筛选器，on 中的逻辑表达式将应用到 vt1 中的各个行，筛选出满足on逻辑表达式的行，生成虚拟表 vt2 。<br>第三步：如果是outer join 那么这一步就将添加外部行，left outer jion 就把左表在第二步中过滤的添加进来，如果是right outer join 那么就将右表在第二步中过滤掉的行添加进来，这样生成虚拟表 vt3 。</p>
<p>第四步：如果 from 子句中的表数目多余两个表，那么就将vt3和第三个表连接从而计算笛卡尔乘积，生成虚拟表，该过程就是一个重复1-3的步骤，最终得到一个新的虚拟表 vt3。 </p>
<p>第五步：应用where筛选器，对上一步生产的虚拟表引用where筛选器，生成虚拟表vt4，在这有个比较重要的细节不得不说一下，对于包含outer join子句的查询，就有一个让人感到困惑的问题，到底在on筛选器还是用where筛选器指定逻辑表达式呢？on和where的最大区别在于，如果在on应用逻辑表达式那么在第三步outer join中还可以把移除的行再次添加回来，而where的移除的最终的。举个简单的例子，有一个学生表（班级,姓名）和一个成绩表(姓名,成绩)，我现在需要返回一个x班级的全体同学的成绩，但是这个班级有几个学生缺考，也就是说在成绩表中没有记录。为了得到我们预期的结果我们就需要在on子句指定学生和成绩表的关系（学生.姓名&#x3D;成绩.姓名）那么我们是否发现在执行第二步的时候，对于没有参加考试的学生记录就不会出现在vt2中，因为他们被on的逻辑表达式过滤掉了,但是我们用left outer join就可以把左表（学生）中没有参加考试的学生找回来，因为我们想返回的是x班级的所有学生，如果在on中应用学生.班级&#x3D;’x’的话，left outer join会把x班级的所有学生记录找回，所以只能在where筛选器中应用学生.班级&#x3D;’x’ 因为它的过滤是最终的。 </p>
<p>第六步：group by 子句将中的唯一的值组合成为一组，得到虚拟表vt5。如果应用了group by，那么后面的所有步骤都只能得到的vt5的列或者是聚合函数（count、sum、avg等）。原因在于最终的结果集中只为每个组包含一行。这一点请牢记。 </p>
<p>第七步：应用cube或者rollup选项，为vt5生成超组，生成vt6.<br>第八步：应用having筛选器，生成vt7。having筛选器是第一个也是为唯一一个应用到已分组数据的筛选器。<br>第九步：处理select子句。将vt7中的在select中出现的列筛选出来。生成vt8. </p>
<p>第十步：应用distinct子句，vt8中移除相同的行，生成vt9。事实上如果应用了group by子句那么distinct是多余的，原因同样在于，分组的时候是将列中唯一的值分成一组，同时只为每一组返回一行记录，那么所以的记录都将是不相同的。 </p>
<p>第十一步：应用order by子句。按照order_by_condition排序vt9，此时返回的一个游标，而不是虚拟表。sql是基于集合的理论的，集合不会预先对他的行排序，它只是成员的逻辑集合，成员的顺序是无关紧要的。对表进行排序的查询可以返回一个对象，这个对象包含特定的物理顺序的逻辑组织。这个对象就叫游标。正因为返回值是游标，那么使用order by 子句查询不能应用于表表达式。排序是很需要成本的，除非你必须要排序，否则最好不要指定order by，最后，在这一步中是第一个也是唯一一个可以使用select列表中别名的步骤。 </p>
<p>第十二步：应用top选项。此时才返回结果给请求者即用户。 </p>
<h3 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h3><p><img src="C:\Users\hufei\AppData\Roaming\Typora\typora-user-images\image-20220311014136188.png" alt="image-20220311014136188"></p>
<p><img src="C:\Users\hufei\AppData\Roaming\Typora\typora-user-images\image-20220311013953804.png" alt="image-20220311013953804"></p>
<p>外键：</p>
<p><img src="C:\Users\hufei\AppData\Roaming\Typora\typora-user-images\image-20220311014811937.png" alt="image-20220311014811937"></p>
<h3 id="多表关系"><a href="#多表关系" class="headerlink" title="多表关系"></a>多表关系</h3><p>表与表之间的三种关系<br>一对多关系：最常见的关系：学生对班级 ， 员工对部门<br>多对多关系：学生与课程 ， 用户与角色<br>一对一关系：使用较少，因为一对一关系可以合成为一张表</p>
<p>一对多关系 （常见）</p>
<p>　　　　例如： 班级和学生， 部门和员工， 客户和订单， 分类和商品</p>
<p>　　　　建表原则： 在从表（多方）创建一个字段， 字段作为外键指向主表（一方）的主键</p>
<p><img src="C:\Users\hufei\AppData\Roaming\Typora\typora-user-images\image-20220314204301248.png" alt="image-20220314204301248"></p>
<p>多对多关系 （常见）</p>
<p>　　　　例如：老师和学生， 学生和课程， 用户和角色</p>
<p>　　　　建表原则： 需要创建第三行表，中间表中至少有两个字段，这两个字段分别作为外键，指向各自一方的主键</p>
<p>　　　　</p>
<p> <img src="C:\Users\hufei\AppData\Roaming\Typora\typora-user-images\image-20220314204333533.png" alt="image-20220314204333533"></p>
<p>  一对一关系（了解）</p>
<p>　　　　在实际开发中应用不多，因为一对一可以创建成一张表</p>
<p>　　　　建表原则： 外键唯一， 主表的主键和从表的唯一外键，形成主外键关系， 外键唯一用UNIQUE修饰</p>
<p><img src="C:\Users\hufei\AppData\Roaming\Typora\typora-user-images\image-20220314204340789.png" alt="image-20220314204340789"></p>
<h3 id="多表查询"><a href="#多表查询" class="headerlink" title="多表查询"></a>多表查询</h3><p>等值连接是从关系R与S的广义笛卡儿积中选取A、B属性值相等的元组。</p>
<p>给出教师信息表A如下：</p>
<table>
<thead>
<tr>
<th><strong>教师号</strong></th>
<th><strong>教师名</strong></th>
</tr>
</thead>
<tbody><tr>
<td>2017</td>
<td>司小东</td>
</tr>
<tr>
<td>2018</td>
<td>魏大勇</td>
</tr>
</tbody></table>
<p>课程表B如下：</p>
<table>
<thead>
<tr>
<th>教师名</th>
<th>课程名</th>
</tr>
</thead>
<tbody><tr>
<td>司小东</td>
<td>数学模型</td>
</tr>
<tr>
<td>魏大勇</td>
<td>数据库原理</td>
</tr>
</tbody></table>
<p>如果我想通过教师号获得课程名，那就需要把两个表连接起来了，按照教师名这个属性来连接，<br>结果如下：</p>
<table>
<thead>
<tr>
<th>教师号</th>
<th>A.教师名</th>
<th>B.教师名</th>
<th>课程名</th>
</tr>
</thead>
<tbody><tr>
<td>2017</td>
<td>司小东</td>
<td>司小东</td>
<td>数学模型</td>
</tr>
<tr>
<td>2018</td>
<td>魏大勇</td>
<td>魏大勇</td>
<td>数据库原理</td>
</tr>
</tbody></table>
<p><strong>自然连接是一种特殊的等值连接，它会把重复列消除。</strong></p>
<p>所以对于自然连接后的结果应该是：</p>
<table>
<thead>
<tr>
<th>教师号</th>
<th>教师名</th>
<th>课程名</th>
</tr>
</thead>
<tbody><tr>
<td>2017</td>
<td>司小东</td>
<td>数学模型</td>
</tr>
<tr>
<td>2018</td>
<td>魏大勇</td>
<td>数据库原理</td>
</tr>
</tbody></table>
<p><strong>等值连接要求相等的分量,不一定是公共属性;而自然连接要求相等的分量必须是公共属性。</strong></p>
<p><strong>单表可以进行自连接</strong></p>
<p><img src="C:\Users\hufei\AppData\Roaming\Typora\typora-user-images\image-20220315233135576.png" alt="image-20220315233135576"></p>
<h4 id="联合查询"><a href="#联合查询" class="headerlink" title="联合查询"></a>联合查询</h4><p>联合查询可以把多次查询结果集合并，形成一个新的结果集</p>
<p><img src="C:\Users\hufei\AppData\Roaming\Typora\typora-user-images\image-20220315233531404.png" alt="image-20220315233531404"></p>
<h4 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h4><p><img src="C:\Users\hufei\AppData\Roaming\Typora\typora-user-images\image-20220315233744692.png" alt="image-20220315233744692"></p>
<p><img src="C:\Users\hufei\AppData\Roaming\Typora\typora-user-images\image-20220315234206480.png" alt="image-20220315234206480"></p>
<p><img src="C:\Users\hufei\AppData\Roaming\Typora\typora-user-images\image-20220315234836449.png" alt="image-20220315234836449"></p>
<p><img src="C:\Users\hufei\AppData\Roaming\Typora\typora-user-images\image-20220315235257760.png" alt="image-20220315235257760"></p>
<h2 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h2><h3 id="锁的分类"><a href="#锁的分类" class="headerlink" title="锁的分类"></a>锁的分类</h3><h4 id="全局锁"><a href="#全局锁" class="headerlink" title="全局锁"></a>全局锁</h4><p>要使用全局锁，则要执行这条命令：flush tables with read lock</p>
<p>执行后，<strong>整个数据库就处于只读状态了</strong>，这时其他线程执行以下操作，都会被阻塞：</p>
<ul>
<li>对数据的增删查改操作，比如 select、insert、delete、update等语句；</li>
<li>对表结构的更改操作，比如 alter table、drop table 等语句。</li>
</ul>
<p>如果要释放全局锁，则要执行这条命令：unlock tables。当然，当会话断开了，全局锁会被自动释放。</p>
<p><strong>应用场景</strong></p>
<p>全局锁主要应用于做<strong>全库逻辑备份</strong>，这样在备份数据库期间，不会因为数据或表结构的更新，而出现备份文件的数据与预期的不一样。</p>
<p>在全库逻辑备份期间，假设不加全局锁的场景，看看会出现什么意外的情况。</p>
<p>如果在全库逻辑备份期间，有用户购买了一件商品，一般购买商品的业务逻辑是会涉及到多张数据库表的更细，比如在用户表更新该用户的余额，然后在商品表更新被购买的商品的库存。</p>
<p>那么，有可能出现这样的顺序：</p>
<ol>
<li>先备份了用户表的数据；</li>
<li>然后有用户发起了购买商品的操作；</li>
<li>接着再备份商品表的数据。</li>
</ol>
<p>也就是在备份用户表和商品表之间，有用户购买了商品。</p>
<p>这种情况下，备份的结果是用户表中该用户的余额并没有扣除，反而商品表中该商品的库存被减少了，如果后面用这个备份文件恢复数据库数据的话，用户钱没少，而库存少了，等于用户白嫖了一件商品。</p>
<p><strong>缺点</strong></p>
<p>加上全局锁，意味着整个数据库都是只读状态。</p>
<p>那么如果数据库里有很多数据，备份就会花费很多的时间，关键是备份期间，业务只能读数据，而不能更新数据，这样会造成业务停滞。</p>
<p><strong>解决方法</strong></p>
<p>在可重复读的隔离级别下，即使其他事务更新了表的数据，也不会影响备份数据库时的 Read View，这样备份期间备份的数据一直是在开启事务时的数据。</p>
<p>备份数据库的工具是 mysqldump，在使用 mysqldump 时加上 <code>–single-transaction</code> 参数的时候，就会在备份数据库之前先开启事务。这种方法只适用于支持「可重复读隔离级别的事务」的存储引擎，如InnoDB</p>
<p>但是，对于 MyISAM 这种不支持事务的引擎，在备份数据库时就要使用全局锁的方法。</p>
<h4 id="表级锁"><a href="#表级锁" class="headerlink" title="表级锁"></a>表级锁</h4><p>MySQL 里面表级别的锁有这几种：</p>
<ul>
<li>表锁；</li>
<li>元数据锁（MDL）;</li>
<li>意向锁；</li>
<li>AUTO-INC 锁；</li>
</ul>
<h5 id="表锁"><a href="#表锁" class="headerlink" title="表锁"></a>表锁</h5><p>如果我们想对学生表（t_student）加表锁，可以使用下面的命令：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">/</span><span class="operator">/</span>表级别的共享锁，也就是读锁；</span><br><span class="line">lock tables t_student read;</span><br><span class="line"></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>表级别的独占锁，也就是写锁；</span><br><span class="line">lock tables t_stuent wirte;</span><br></pre></td></tr></table></figure>

<p>需要注意的是，表锁除了会限制别的线程的读写外，<strong>也会限制本线程接下来的读写操作</strong>。</p>
<p>也就是说如果本线程对学生表加了共享表锁，那么本线程接下来如果要对学生表执行写操作的语句，是会被阻塞的，当然其他线程对学生表进行写操作时也会被阻塞，直到锁被释放。</p>
<p>要释放表锁，可以使用下面这条命令，会释放当前会话的所有表锁：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unlock tables</span><br></pre></td></tr></table></figure>

<p>另外，当会话退出后，也会释放所有表锁。</p>
<h5 id="元数据锁（metadata-lock）"><a href="#元数据锁（metadata-lock）" class="headerlink" title="元数据锁（metadata lock）"></a><strong>元数据锁（metadata lock）</strong></h5><p>我们不需要显示的使用 MDL，因为当我们对数据库表进行操作时，会自动给这个表加上 MDL：</p>
<ul>
<li>对一张表进行 CRUD 操作时，加的是 <strong>MDL 读锁</strong>；</li>
<li>对一张表做结构变更操作的时候，加的是 <strong>MDL 写锁</strong>；</li>
</ul>
<p><strong>作用</strong></p>
<p>在MySQL5.5.3之前，有一个著名的bug#989，大致如下:</p>
<p>session1:<br>BEGIN;<br>INSERT INTO t … ;<br>COMMIT;</p>
<p>session2:<br>DROP TABLE t;</p>
<p>然而上面的操作流程在binlog记录的顺序是：<br>DROP TABLE t;</p>
<p>BEGIN;<br>INSERT INTO t … ;<br>COMMIT;</p>
<p>很显然备库执行binlog恢复数据时会先删除表t，然后执行insert 会报error，导致复制中断。为了解决该bug,MySQL 在5.5.3引入了MDL锁（metadata lock），来保护表的元数据信息，用于解决或者<strong>保证DDL操作与DML操作之间的一致性</strong>。</p>
<p>简单的例子，如果你在查询一个表的过程中，另外一个session对该表删除了一个列，那前面的查询到底该显示什么呢？事物中再次执行相同的语句还会和之前结果一致吗？为了防止这种情况，表查询开始MySQL会在表上加一个锁，来防止被别的session修改了表定义，这个锁就叫MDL</p>
<p><strong>与行锁的区别</strong></p>
<p>mdl是表级锁，是在server层加的，适用于所有存储引擎。<strong>mdl为了解决ddl和dml之间的冲突，而行锁则是解决dml内的冲突</strong>。所有的dml操作都会在表上加一个metadata读锁；所有的ddl操作都会在表上加一个metadata写锁。读锁和写锁的阻塞关系如下：</p>
<ul>
<li>读锁和写锁之间相互阻塞，即同一个表上的dml和ddl之间互相阻塞。</li>
<li>写锁和写锁之间互相阻塞，即两个session不能对表同时做表定义变更，需要串行操作。</li>
<li>读锁和读锁之间不会产生阻塞。也就是<strong>增删改查不会因为mdl产生阻塞</strong>，可以并发执行，日常工作中大家看到的dml之间的锁等待是innodb行锁引起的，和mdl无关。</li>
</ul>
<p><strong>MDL为什么会造成系统崩溃</strong></p>
<p>MDL申请锁是串行队列排队申请，若队列前有事务阻塞，则后面的事务则可能无法申请到锁。</p>
<p>如事务1对表t1执行一个简单的查询；事务2对t1加一个字段；事务3来对t1做一个查询；</p>
<p>若事务1没有提交，则会导致事务2的ddl操作被阻塞，事务3本身不会被事务1阻塞，但由于在锁队列中，事务2排队更早，它准备加的是MDL写锁，阻塞了事务3的读锁。如果t1是一个执行频繁的表，show processlist会发现大量waiting for table metadata lock的线程，数据库连接很快就会消耗完，导致业务系统无法正常响应。</p>
<p>最新版本的mysql已经解决了这个问题，事务2不会再阻塞事务3。</p>
<p><strong>MDL生命周期</strong></p>
<p>MDL 在语句执行前申请，事务提交后才会释放，这意味着<strong>事务执行期间，MDL 是一直持有的</strong>。若执行完语句就释放，可能会导致事务中途其他事务删除或改变表，无法保证一致性。</p>
<p><strong>注意事项</strong></p>
<ul>
<li>生产环境的任何大表或频繁操作的小表，ddl都要非常慎重，最好在业务低峰期执行。同时ddl前需要检测是否存在长事务，若有长事务最好先kill掉，不能会导致阻塞。</li>
<li>设计上要尽可能避免长事务，长事务不仅仅会带来各种锁问题，还好引起复制延迟&#x2F;回滚空间爆满等各类问题。</li>
<li>要及时提交事务，经常发现客户端设置了事务手工提交，但sql执行后忘记点击提交按钮，导致事务长时间无法提交。建议监控实例中的长事务，避免由于各种原因导致事务没有及时提交。</li>
</ul>
<h5 id="意向锁"><a href="#意向锁" class="headerlink" title="意向锁"></a>意向锁</h5><p>意向锁是一种<strong>快速判断表锁与之前可能存在的行锁冲突的机制</strong>，在添加行锁之前必须先申请意向锁。在添加表锁时会先查有没有意向锁，有则阻塞。</p>
<p><strong>表锁和行锁冲突</strong></p>
<p>事务A锁住了表中的<strong>一行</strong>，让这一行只能读，不能写。</p>
<p>之后，事务B申请<strong>整个表</strong>的写锁。</p>
<p>如果事务B申请成功，那么理论上它就能修改表中的任意一行，这与A持有的行锁是冲突的。</p>
<p>因此表锁在申请时除了判断表是否已被其他事务用表锁锁表，还需要遍历每行判断表中是否有某行已被行锁锁住，效率低。</p>
<p>那么有了意向锁，由于在对记录加行锁前，先会加上表级别的意向锁，那么在加表锁时，直接查该表是否有意向锁，如果有就意味着表里已经有记录被加了行锁，这样就不用去遍历表里的记录。</p>
<h5 id="AUTO-INC-锁"><a href="#AUTO-INC-锁" class="headerlink" title="AUTO-INC 锁"></a>AUTO-INC 锁</h5><p> AUTO-INC 锁是为了在插入数据时，保证声明 <code>AUTO_INCREMENT</code> 属性的字段可以连续递增。</p>
<p>AUTO-INC 锁是特殊的表锁机制，锁不是再一个事务提交后才释放，而是<strong>在执行完插入语句后就会立即释放。</strong></p>
<p><strong>在插入数据时，会加一个表级别的 AUTO-INC 锁</strong>，然后为被 <code>AUTO_INCREMENT</code> 修饰的字段赋值递增的值，等插入语句执行完成后，才会把 AUTO-INC 锁释放掉。</p>
<p>那么，一个事务在持有 AUTO-INC 锁的过程中，其他事务的如果要向该表插入语句都会被阻塞，从而保证插入数据时，被 <code>AUTO_INCREMENT</code> 修饰的字段的值是连续递增的。</p>
<p>但是， AUTO-INC 锁再对大量数据进行插入的时候，会影响插入性能，因为另一个事务中的插入会被阻塞。</p>
<p>因此， 在 MySQL 5.1.22 版本开始，InnoDB 存储引擎提供了一种<strong>轻量级的锁</strong>来实现自增。</p>
<p>一样也是在插入数据的时候，会为被 <code>AUTO_INCREMENT</code> 修饰的字段加上轻量级锁，<strong>然后给该字段赋值一个自增的值，就把这个轻量级锁释放了，而不需要等待整个插入语句执行完后才释放锁</strong>。</p>
<p>InnoDB 存储引擎提供了个 innodb_autoinc_lock_mode 的系统变量，是用来控制选择用 AUTO-INC 锁，还是轻量级的锁。</p>
<ul>
<li>当 innodb_autoinc_lock_mode &#x3D; 0，就采用 AUTO-INC 锁；</li>
<li>当 innodb_autoinc_lock_mode &#x3D; 2，就采用轻量级锁；</li>
<li>当 innodb_autoinc_lock_mode &#x3D; 1，这个是默认值，两种锁混着用，如果能够确定插入记录的数量就采用轻量级锁，不确定时就采用 AUTO-INC 锁。</li>
</ul>
<p>不过，当 innodb_autoinc_lock_mode &#x3D; 2 是性能最高的方式，但是会带来一定的问题。因为并发插入的存在，在每次插入时，自增长的值可能不是连续的，<strong>这在有主从复制的场景中是不安全的</strong>。</p>
<h4 id="行锁"><a href="#行锁" class="headerlink" title="行锁"></a>行锁</h4><p>InnoDB 引擎是支持行级锁的，而 MyISAM 引擎并不支持行级锁。</p>
<p><strong>InnoDB有三种行锁：</strong></p>
<p>1，Record Lock：单个行记录上的锁。包括共享锁和独占锁（不包括其他行，所以会出现幻读）</p>
<p>2，Gap Lock：间隙锁，锁定一个范围，但不包括记录本身。GAP锁的目的，是为了防止同一事务的两次当前读，出现幻读的情况。</p>
<p>3，Next-Key Lock：1+2，锁定记录本身和记录左边的间隙，即一个左开右闭区间。主要目的是解决幻读。</p>
<p>在查询时主动对记录加行锁，可以使用下面这两个方式：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">/</span><span class="operator">/</span>对读取的记录加共享锁</span><br><span class="line"><span class="keyword">select</span> ... lock <span class="keyword">in</span> share mode;</span><br><span class="line"></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>对读取的记录加独占锁</span><br><span class="line"><span class="keyword">select</span> ... <span class="keyword">for</span> <span class="keyword">update</span>;</span><br></pre></td></tr></table></figure>

<p>存储引擎还会在读写时会自动加锁，详情看InnoDB的事务隔离级别的实现。</p>
<p><strong>提高锁的性能</strong></p>
<p><strong>修改事务中操作的顺序可以提高性能</strong>。</p>
<p>在InnoDB事务中，行锁是在需要的时候才加上的，但并不是不需要了就立刻释放，而是要等到事务结束时才释放。这个就是两阶段锁协议。</p>
<p>如果你的事务中需要锁多个行，要把最可能造成锁冲突、最可能影响并发度的锁尽量往后放。</p>
<p>假设你负责实现一个电影票在线交易业务，顾客A要在影院B购买电影票。我们简化一点，这个业务需要涉及到以下操作：</p>
<ol>
<li>从顾客A账户余额中扣除电影票价；</li>
<li>给影院B的账户余额增加这张电影票价；</li>
<li>记录一条交易日志。</li>
</ol>
<p>也就是说，要完成这个交易，我们需要update两条记录，并insert一条记录。当然，为了保证交易的原子性，我们要把这三个操作放在一个事务中。那么，你会怎样安排这三个语句在事务中的顺序呢？</p>
<p>试想如果同时有另外一个顾客C要在影院B买票，那么这两个事务冲突的部分就是语句2了。因为它们要更新同一个影院账户的余额，需要修改同一行数据。</p>
<p>根据两阶段锁协议，不论你怎样安排语句顺序，所有的操作需要的行锁都是在事务提交的时候才释放的。所以，如果你把语句2安排在最后，比如按照3、1、2这样的顺序，那么影院账户余额这一行的锁时间就最少。这就最大程度地减少了事务之间的锁等待，提升了并发度。</p>
<h4 id="死锁和死锁检测"><a href="#死锁和死锁检测" class="headerlink" title="死锁和死锁检测"></a>死锁和死锁检测</h4><p>当并发系统中不同线程出现循环资源依赖，涉及的线程都在等待别的线程释放资源时，就会导致这几个线程都进入无限等待的状态，称为死锁。</p>
<p>以行锁为例：</p>
<table>
<thead>
<tr>
<th>事务A</th>
<th>事务B</th>
</tr>
</thead>
<tbody><tr>
<td>update t set k&#x3D;k+1 where id&#x3D;2</td>
<td></td>
</tr>
<tr>
<td></td>
<td>update t set k&#x3D;k+1 where id&#x3D;1</td>
</tr>
<tr>
<td>update t set k&#x3D;k+1 where id&#x3D;1</td>
<td></td>
</tr>
<tr>
<td></td>
<td>update t set k&#x3D;k+1 where id&#x3D;2</td>
</tr>
</tbody></table>
<p>这时候，事务A在等待事务B释放id&#x3D;1的行锁，而事务B在等待事务A释放id&#x3D;2的行锁。 事务A和事务B在互相等待对方的资源释放，就是进入了死锁状态。当出现死锁以后，有两种策略：</p>
<ul>
<li>一种策略是，直接进入等待，直到超时。这个超时时间可以通过参数innodb_lock_wait_timeout来设置。</li>
<li>另一种策略是，发起死锁检测，发现死锁后，主动回滚死锁链条中的某一个事务，让其他事务得以继续执行。将参数innodb_deadlock_detect设置为on，表示开启这个逻辑。</li>
</ul>
<p>在InnoDB中，innodb_lock_wait_timeout的默认值是50s，当出现死锁以后，第一个被锁住的线程要过50s才会超时退出，然后其他线程才有可能继续执行。时间过长。</p>
<p>若时间很短，比如1s。这样当出现死锁的时候，确实很快就可以解开，但如果不是死锁，而是简单的锁等待呢？所以，超时时间设置太短的话，会出现很多误伤。</p>
<p>正常情况下我们还是要采用第二种策略，即：<strong>主动死锁检测</strong>，而且innodb_deadlock_detect的默认值本身就是on。主动死锁检测在发生死锁的时候，是能够快速发现并进行处理的，但是它也是有额外负担的。每当一个事务被锁的时候，就要看看它所依赖的线程有没有被别人锁住，如此循环，最后判断是否出现了循环等待，也就是死锁。</p>
<p>如果所有事务都要更新同一行的场景，每个新来的被堵住的线程，都要判断会不会由于自己的加入导致了死锁，这是一个时间复杂度是O(n)的操作。假设有1000个并发线程要同时更新同一行，那么死锁检测操作就是100万这个量级的。这期间要消耗大量的CPU资源。</p>
<p><strong>死锁检测优化办法</strong></p>
<p>1.<strong>如果你能确保这个业务一定不会出现死锁，可以临时把死锁检测关掉。</strong>但是这种操作本身带有一定的风险</p>
<p>2.<strong>控制并发度。</strong>比如同一行同时最多只有10个线程在更新，那么死锁检测的成本很低，就不会出现这个问题。一个直接的想法就是，在客户端做并发控制。但是因为客户端很多，即使每个客户端控制到只有5个并发线程，汇总到数据库服务端以后，峰值并发数也可能会很高。因此，这个<strong>并发控制要做在数据库服务端</strong>。如果你有中间件，可以考虑在中间件实现；如果你的团队有能修改MySQL源码的人，也可以做在MySQL里面。基本思路就是，<strong>对于相同行的更新，在进入引擎之前排队</strong>。这样在InnoDB内部就不会有大量的死锁检测工作了。</p>
<p>3.<strong>从设计上优化</strong>。可以考虑通过将一行改成逻辑上的多行来减少锁冲突。还是以影院账户为例，可以考虑放在多条记录上，比如10个记录，影院的账户总额等于这10个记录的值的总和。这样每次要给影院账户加金额的时候，随机选其中一条记录来加。这样每次冲突概率变成原来的1&#x2F;10，可以减少锁等待个数，也就减少了死锁检测的CPU消耗。</p>
<h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><p><strong>一条sql语句默认为一个事务</strong></p>
<p><img src="C:\Users\hufei\AppData\Roaming\Typora\typora-user-images\image-20220316000331849.png" alt="image-20220316000331849"></p>
<h3 id="事务的四大特性"><a href="#事务的四大特性" class="headerlink" title="事务的四大特性"></a>事务的四大特性</h3><ol>
<li>原子性：原子性是指事务是一个不可分割的工作单位，事务中的操作要么全部成功，要么全部失败。部分操作失败时会进行回滚，从而保证原子性</li>
<li>一致性：事务执行的结果必须是使数据库从一个一致性状态变到另一个一致性状态。也就是说数据库应该只包含成功事务提交的结果时</li>
<li>隔离性：一个事务的执行不能其它事务干扰。多个并发事务之间要相互隔离</li>
<li>持久性：持久性是指一个事务一旦被提交，它对数据库中数据的改变就是永久性的，不能回滚。并且接下来即使数据库发生故障也不应该对其有任何影响。</li>
</ol>
<h3 id="事务的隔离级别"><a href="#事务的隔离级别" class="headerlink" title="事务的隔离级别"></a>事务的隔离级别</h3><p>事务隔离级别要实际解决的三大问题</p>
<ol>
<li><p>脏读：脏读指的是读到了其他事务未提交的数据，未提交意味着这些数据可能会回滚，也就是可能最终不会存到数据库中的数据。</p>
</li>
<li><p>不可重复读：不可重复读针对其他事务的update和delete操作。指的是在同一事务内，不同的时刻读到的同一批数据可能是不一样的，可能会受到其他事务的影响，比如其他事务改了这批数据并提交了。</p>
</li>
<li><p>幻读：针对的是其他事务的insert操作。在事务A中同样的查询在不同的时间产生了不同的结果，这就是幻读。原因是事务B中在两次查询间隔中间插入了新的数据。</p>
</li>
</ol>
<p>SQL 标准定义了四种隔离级别，MySQL 全都支持。这四种隔离级别分别是：</p>
<ol>
<li>读未提交（READ UNCOMMITTED）</li>
<li>读提交 （READ COMMITTED）</li>
<li>可重复读 （REPEATABLE READ）</li>
<li>串行化 （SERIALIZABLE）</li>
</ol>
<p>从上往下，隔离强度逐渐增强，性能逐渐变差。采用哪种隔离级别要根据系统需求权衡决定，其中，<strong>可重复读</strong>是 MySQL 的默认级别。</p>
<p>事务隔离其实就是为了解决上面提到的脏读、不可重复读、幻读这几个问题，下面展示了 4 种隔离级别对这三个问题的解决程度。</p>
<table>
<thead>
<tr>
<th>隔离级别</th>
<th>脏读</th>
<th>不可重复读</th>
<th>幻读</th>
</tr>
</thead>
<tbody><tr>
<td>读未提交</td>
<td>未解决</td>
<td>未解决</td>
<td>未解决</td>
</tr>
<tr>
<td>读提交</td>
<td>解决</td>
<td>未解决</td>
<td>未解决</td>
</tr>
<tr>
<td>可重复读</td>
<td>解决</td>
<td>解决</td>
<td>未解决</td>
</tr>
<tr>
<td>串行化</td>
<td>解决</td>
<td>解决</td>
<td>解决</td>
</tr>
</tbody></table>
<p>MySQL <strong>事务隔离其实是依靠锁来实现的</strong>，锁是通过索引来锁住记录的(每个表都至少有一个聚集索引)。加锁自然会带来性能的损失，因此隔离级别越高性能越差。</p>
<p>加行锁的过程要<strong>分有索引和无索引两种情况</strong>，有索引的情况，MySQL 直接就在索引数中找到了这行数据，然后干净利落的加上行锁就可以了。</p>
<p>无索引时MySQL 无法直接定位到这行数据。MySQL 会为这张表中所有行加行锁，在加上行锁后，MySQL 会进行一遍过滤，发现不满足的行就释放锁，最终只留下符合条件的行，因此更新无索引的数据非常影响性能。</p>
<h3 id="锁和事务详解"><a href="#锁和事务详解" class="headerlink" title="锁和事务详解"></a>锁和事务详解</h3><p>几个概念：</p>
<p><strong>锁定读</strong>：在一个事务中，主动给读加锁，如SELECT … LOCK IN SHARE MODE 和 SELECT … FOR UPDATE。分别加上了行共享锁和行排他锁。共享锁可以和共享锁共存，所以可以多事务同时读。排他锁独占，所以加了排他锁之后其他事务不可以读和写。</p>
<p><strong>一致性非锁定读</strong>：InnoDB在读提交和可重复读隔离级别处理SELECT语句的默认模式。一致性非锁定读不会对其访问的表设置任何锁，因此，在对表执行一致性非锁定读的同时，其它事务可以同时并发的读取或者修改它们。</p>
<p><strong>当前读</strong>：读取的是最新版本，像<strong>UPDATE、DELETE、INSERT、SELECT … LOCK IN SHARE MODE、SELECT … FOR UPDATE</strong>这些操作都是一种当前读，为什么叫当前读？就是它读取的是记录的最新版本，读取时还要保证其他并发事务不能修改当前记录，会对读取的记录进行加锁。</p>
<p><strong>快照读</strong>：读取的是快照版本，也就是历史版本，像不加锁的<strong>SELECT</strong>操作就是快照读，即不加锁的非阻塞读；</p>
<p><strong>隐式锁定</strong>：InnoDB在事务执行过程中，使用两阶段锁协议（不主动进行显示锁定的情况）：</p>
<ul>
<li>随时都可以执行锁定，InnoDB会根据隔离级别在需要的时候自动加锁；</li>
<li>锁只有在执行commit或者rollback的时候才会释放，并且所有的锁都是在同一时刻被释放。</li>
</ul>
<p><strong>显式锁定</strong>：如SELECT … LOCK IN SHARE MODE 和 SELECT … FOR UPDATE（存储引擎层）；lock table和unlock table（server层）</p>
<p><strong>InnoDB有三种行锁的算法：</strong></p>
<p>1，Record Lock：单个行记录上的锁。（不包括其他行，所以会出现幻读）</p>
<p>2，Gap Lock：间隙锁，锁定一个范围，但不包括记录本身。GAP锁的目的，是为了防止同一事务的两次当前读，出现幻读的情况。</p>
<p>3，Next-Key Lock：1+2，锁定记录本身和记录左边的间隙，即一个左开右闭区间。主要目的是解决幻读。</p>
<p><strong>InnoDB的事务具体实现</strong></p>
<table>
<thead>
<tr>
<th>事务隔离级别</th>
<th>实现方式</th>
</tr>
</thead>
<tbody><tr>
<td>未提交读（RU）</td>
<td>事务对当前被读取的数据不加锁，都是<strong>当前读</strong>；  事务在更新某数据的瞬间（就是发生更新的瞬间），必须先对其加<strong>行级共享锁</strong>，直到事务结束才释放。</td>
</tr>
<tr>
<td>提交读（RC）</td>
<td>事务对当前被读取的数据不加锁，且是<strong>快照读</strong>；  事务在更新某数据的瞬间（就是发生更新的瞬间），必须先对其加<strong>行级排他锁（Record）</strong>，直到事务结束才释放。</td>
</tr>
<tr>
<td>可重复读（RR）</td>
<td>事务对当前被读取的数据不加锁，且是<strong>快照读</strong>；  事务在更新某数据的瞬间（就是发生更新的瞬间），必须先对其加<strong>行级排他锁（Record，GAP，Next-Key）</strong>，直到事务结束才释放。  <strong>通过间隙锁，在这个级别MySQL就解决了幻读的问题</strong>  <strong>通过快照，在这个级别MySQL就解决了不可重复读的问题</strong></td>
</tr>
<tr>
<td>序列化读（S）</td>
<td>事务在读取数据时，必须先对其加<strong>表级共享锁</strong> ，直到事务结束才释放，都是<strong>当前读</strong>；  事务在更新数据时，必须先对其加<strong>表级排他锁</strong> ，直到事务结束才释放。</td>
</tr>
</tbody></table>
<p><strong>RR级别的锁都是next-key锁，可以解决幻读的问题，但是需要主动加锁</strong>。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">begin</span>;</span><br><span class="line"></span><br><span class="line">#假设users表为空，下面查出来的数据为空</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> users lock <span class="keyword">in</span> share mode; #加上共享锁</span><br><span class="line"></span><br><span class="line">#此时另一个事务B想提交且插入了一条id<span class="operator">=</span><span class="number">1</span>的数据，由于有间隙锁，所以要等待</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> users; #读快照，查出来的数据为空</span><br><span class="line"></span><br><span class="line"><span class="keyword">update</span> users <span class="keyword">set</span> name<span class="operator">=</span><span class="string">&#x27;mysql&#x27;</span> <span class="keyword">where</span> id<span class="operator">=</span><span class="number">1</span>;#<span class="keyword">update</span>是当前读，由于不存在数据，不进行更新</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> users; #读快照，查出来的数据为空</span><br><span class="line"></span><br><span class="line"><span class="keyword">commit</span>;</span><br><span class="line"></span><br><span class="line">#事务B提交成功并插入数据</span><br></pre></td></tr></table></figure>

<h3 id="mvcc（多版本并发控制）"><a href="#mvcc（多版本并发控制）" class="headerlink" title="mvcc（多版本并发控制）"></a>mvcc（多版本并发控制）</h3><p>需要mvcc的原因：锁住一个资源后会禁止其他任何线程访问同一个资源。但是很多应用的一个特点都是读多写少的场景——&gt;使用了一种读写锁的方法，读锁和读锁之间不互斥，而写锁和写锁、读锁都互斥——&gt;让读写之间也不冲突的方法，就是读取数据时通过一种类似快照的方式将数据保存下来，这样读锁就和写锁不冲突了，不同的事务session会看到自己特定版本的数据。</p>
<p>mvcc：对于Mysql中的每一个数据行都有可能存在多个版本，在每次事务更新数据的时候都会同时记录undo log（未提交的也会记录undo log），并且把自己的事务id赋值给当前版本的row trx_id。记录上的最新值，通过回滚操作，都可以得到前一个版本的值。这就是mvcc</p>
<p>假如三个事务更新了同一行数据，那么就会有对应的三个数据版本。</p>
<p><img src="C:\Users\hufei\AppData\Roaming\Typora\typora-user-images\image-20220317221606939.png" alt="image-20220317221606939"></p>
<p>系统会判断，<strong>当没有事务再需要用到这些回滚日志时，回滚日志会被删除。</strong>就是当系统里没有比这个回滚日志更早的视图的时候。</p>
<p>因此最好避免使用长事务，长事务意味着系统里面会存在很老的事务视图。由于这些事务随时可能访问数据库里面的任何数据，所以这个事务提交之前，数据库里面它可能用到的回滚记录都必须保留，这就会导致大量占用存储空间。</p>
<p>不同时刻启动的事务会有不同的快照，记录数据的值。</p>
<p>在实现可重复读的隔离级别，只需要在<strong>事务开始的时候创建快照</strong>，之后的查询里都共用这个快照，后续的事务对数据的更改是对当前事务是不可见的，这样就实现了可重复读。</p>
<p>而读提交，每一个<strong>语句执行前都会重新计算</strong>出一个新的快照。</p>
<h3 id="快照原理"><a href="#快照原理" class="headerlink" title="快照原理"></a>快照原理</h3><p>快照并非为每个事务存储真正的行数据，而是而是每次需要的时候根据当前版本和undo log计算出来的。</p>
<p>InnoDB为每个事务构造了一个活跃事务数组，用来保存这个事务启动瞬间，当前正在“活跃”的所有事务ID。“活跃”指的就是，启动了但还没提交。</p>
<p>譬如数组为[47,49,52]，事务id为60，那么小于47的事务都已经提交，对事务60来说是可见的；id大于60的事务还未创建，是不可见的。</p>
<p>对于<strong>可重复读，这个数组不会变</strong>；而<strong>读提交则会在每次读取时更新活跃数组</strong>；</p>
<p>可重复读事务创建时，就要顺着undo log往前找，直到找到某个版本的事务id小于60并且不在活跃数组中，这个版本的数据就是事务的快照。</p>
<p>而读提交事务每次读取数据时，先会更新活跃数组，然后顺着undo log往前找，直到找到某个版本的事务不在活跃数组中即可。</p>
<p>需要注意快照不适用于并发写的情况，因为写的时候(如update k&#x3D;k+1)需要读取最新版本的数据，并且会给版本加排他锁（不影响读其他版本的数据），等到事务结束才释放。</p>
<p><img src="C:\Users\hufei\AppData\Roaming\Typora\typora-user-images\b7bd3c773392176bba242235f4da000f.webp" alt="b7bd3c773392176bba242235f4da000f"></p>
<p>如B读到的数据是3而不是2。</p>
<h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><h3 id="索引结构优劣分析"><a href="#索引结构优劣分析" class="headerlink" title="索引结构优劣分析"></a>索引结构优劣分析</h3><p>设计一个适合 MySQL 索引的数据结构，至少满足以下要求：</p>
<ul>
<li>能在尽可能少的磁盘的 I&#x2F;O 操作中完成查询工作；</li>
<li>要能高效地查询某一个记录，也要能高效地执行范围查找；</li>
</ul>
<p><strong>数组</strong></p>
<p>优点：查询最快，可用二分查找</p>
<p>缺点：维护困难，插入删除效率低。适合存储静态数据，比如你要保存的是2017年某个城市的所有人口信息，这类不会再修改的数据。</p>
<p><strong>红黑树，avl树</strong></p>
<p>优点：相比数组维护简单，插入删除效率高</p>
<p>缺点：一个节点只能有两个子节点，树过高，需要的I&#x2F;O操作多</p>
<p><strong>哈希表</strong></p>
<p>优点：查询速度快</p>
<p>缺点：只支持精确匹配，不支持范围查询；不支持根据索引排序</p>
<p><strong>B树</strong></p>
<p>优点：多叉树，树的高度低，磁盘I&#x2F;O次数少</p>
<p>缺点： B 树的每个节点都包含数据（索引+记录），而用户的记录数据的大小很有可能远远超过了索引数据，这就需要花费更多的磁盘 I&#x2F;O 操作次数来读到有用的索引数据。因此B树的查询速度不平均，有可能很快，有可能很慢； B 树做范围查询，需要使用中序遍历，这会涉及多个节点的磁盘 I&#x2F;O 问题，从而导致整体速度下降；B树插入和删除可能发生树变形，效率低</p>
<p><strong>B+树</strong></p>
<p>优点：记录都保存在叶子节点，相比B树，每个节点索引更多，树更矮，磁盘I&#x2F;O次数少，查询速度平均；记录用双向链表相连，支持范围查询和排序；存在冗余节点，插入和删除不会发生严重的树变形，相比B树效率更高</p>
<p>缺点：单记录查询平均I&#x2F;O次数相比B树更多(因此mongodb使用B树。不使用哈希表是因为哈希表范围查询太慢，做了综合考虑)</p>
<h3 id="自增主键的好处"><a href="#自增主键的好处" class="headerlink" title="自增主键的好处"></a>自增主键的好处</h3><p>自增主键的插入数据模式，正符合了我们前面提到的递增插入的场景。每次插入一条新记录，都是追加操作，都不涉及到挪动其他记录，也不会触发叶子节点的分裂。</p>
<p>而有业务逻辑的字段做主键，则往往不容易保证有序插入，这样写数据成本相对较高。</p>
<p>除了考虑性能外，我们还可以从存储空间的角度来看。假设你的表中确实有一个唯一字段，比如字符串类型的身份证号，那应该用身份证号做主键，还是用自增字段做主键呢？</p>
<p>由于每个二级索引的叶子节点上都是主键的值。如果用身份证号做主键，那么每个二级索引的叶子节点占用约20个字节，而如果用整型做主键，则只要4个字节，如果是长整型（bigint）则是8个字节。</p>
<p><strong>显然，主键长度越小，普通索引的叶子节点就越小，普通索引占用的空间也就越小。</strong></p>
<p>所以，从性能和存储空间方面考量，自增主键往往是更合理的选择。</p>
<p>有没有什么场景适合用业务字段直接做主键的呢？还是有的。比如，有些业务的场景需求是这样的：</p>
<ol>
<li>只有一个索引；</li>
<li>该索引必须是唯一索引。</li>
</ol>
<p>你一定看出来了，这就是典型的KV场景。</p>
<p>由于没有其他索引，所以也就不用考虑其他索引的叶子节点大小的问题。</p>
<p>索引结构：</p>
<table>
<thead>
<tr>
<th>索引结构</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>b+树</td>
<td>最常见的索引类型，大部分引擎支持</td>
</tr>
<tr>
<td>hash索引</td>
<td>用哈希表实现，只支持精确匹配，不支持范围查询</td>
</tr>
<tr>
<td>R-tree(空间索引)</td>
<td>MyISAM引擎的一个特殊索引，主要用于地理空间数据类型，使用少</td>
</tr>
<tr>
<td>Full-text(全文索引)</td>
<td>是一种通过建立倒排索引，快速匹配文档的方式</td>
</tr>
</tbody></table>
<p>各引擎支持索引：</p>
<table>
<thead>
<tr>
<th>索引</th>
<th>InnoDB</th>
<th>MyISAM</th>
<th>Memory</th>
</tr>
</thead>
<tbody><tr>
<td>B+tree索引</td>
<td>支持</td>
<td>支持</td>
<td>支持</td>
</tr>
<tr>
<td>Hash索引</td>
<td>不支持(在指定条件下会自动构建)</td>
<td>不支持</td>
<td>支持</td>
</tr>
<tr>
<td>R-tree</td>
<td>不支持</td>
<td>支持</td>
<td>不支持</td>
</tr>
<tr>
<td>Full-text</td>
<td>5.6版本后支持</td>
<td>支持</td>
<td>不支持</td>
</tr>
</tbody></table>
<p><img src="C:\Users\hufei\AppData\Roaming\Typora\typora-user-images\image-20220318232645585.png" alt="image-20220318232645585"></p>
<p><img src="C:\Users\hufei\AppData\Roaming\Typora\typora-user-images\image-20220318232725678.png" alt="image-20220318232725678"></p>
<p><img src="C:\Users\hufei\AppData\Roaming\Typora\typora-user-images\image-20220318232828330.png" alt="image-20220318232828330"></p>
<p><img src="C:\Users\hufei\AppData\Roaming\Typora\typora-user-images\image-20220318232941993.png" alt="image-20220318232941993"></p>
<h3 id="索引分类"><a href="#索引分类" class="headerlink" title="索引分类"></a>索引分类</h3><table>
<thead>
<tr>
<th>分类</th>
<th>含义</th>
<th>特点</th>
<th>关键字</th>
</tr>
</thead>
<tbody><tr>
<td>主键索引</td>
<td>针对表中主键创建的索引</td>
<td>默认自动创建，只能有一个</td>
<td>PRIMARY</td>
</tr>
<tr>
<td>唯一索引</td>
<td>针对UNIQUE列创建的索引</td>
<td>可以有多个</td>
<td>UNIQUE</td>
</tr>
<tr>
<td>常规索引</td>
<td>快速定位数据</td>
<td>可以有多个</td>
<td></td>
</tr>
<tr>
<td>全文索引</td>
<td>查找文本关键词，而不是比较值</td>
<td>可以有多个</td>
<td>FULLTEXT</td>
</tr>
</tbody></table>
<p>在InnoDB引擎中，根据索引存储形式又可以分为聚集索引和二级索引</p>
<p><strong>聚集索引</strong>：索引的叶子节点保存的是行数据，必须有且只能有一个聚集索引。有主键时主键索引就是聚集索引，没有时第一个唯一索引就是聚集索引，二者都无时自动创建自增主键作为聚集索引。</p>
<p><strong>二级索引</strong>：普通索引，索引的叶子节点存储的是聚集索引的值。可以有多个。</p>
<p>注意，二级索引存放的是聚集索引的索引值（一般也就是行数据对应主键的值），因此得到主键值之后还需要用主键值去聚集索引中再查询一次得到行数据。在这个过程中，<strong>回到主键索引树搜索的过程，我们称为回表</strong>。</p>
<h3 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h3><p>若在查询中避免了回表的过程，就是覆盖索引。如执行的语句是select ID from T where k between 3 and 5，id是主键，已经存放在了二级索引树上，因此只需要查询一次二级索引就可以得到结果。</p>
<p>由于覆盖索引可以减少树的搜索次数，显著提升查询性能，所以<strong>使用覆盖索引是一个常用的性能优化手段</strong>。</p>
<p><strong>除了查询主键的情况还有什么办法可以使用到覆盖索引呢？</strong></p>
<p>如在一个市民表上需要查询市民的身份证号和名字，那么我们可以将身份证号和名字建立一个联合索引，那么二级索引的叶子节点上就包括了身份证号和名字，无需再回表查询了。</p>
<p>当然增加索引会造成额外的维护代价，需要综合考虑。</p>
<h3 id="联合索引"><a href="#联合索引" class="headerlink" title="联合索引"></a>联合索引</h3><p>多个普通字段组合在一起创建的索引就叫做联合索引</p>
<p><img src="C:\Users\hufei\AppData\Roaming\Typora\typora-user-images\index.png" alt="image-20220319032542383"></p>
<p>索引会先根据第一个索引列排序，如果相同，再根据后面的索引列进行排序。</p>
<h3 id="最左前缀原则"><a href="#最左前缀原则" class="headerlink" title="最左前缀原则"></a>最左前缀原则</h3><p>在通过联合索引检索数据时，从索引中最左边的列开始，一直向右匹配，并且不跳过索引中的列。</p>
<p>比如，如果创建了一个 <code>(a, b, c)</code> 联合索引，如果查询条件是以下这几种，就可以匹配上联合索引：</p>
<ul>
<li>where a&#x3D;1；</li>
<li>where a&#x3D;1 and b&#x3D;2 and c&#x3D;3；</li>
<li>where a&#x3D;1 and b&#x3D;2；</li>
</ul>
<p>需要注意的是，因为<strong>有查询优化器</strong>，所以 <strong>a 字段在 where 子句的顺序并不重要</strong>。</p>
<p>但是，如果查询条件是以下这几种，因为不符合最左匹配原则，所以就无法匹配上联合索引，联合索引就会失效:</p>
<ul>
<li>where b&#x3D;2；</li>
<li>where c&#x3D;3；</li>
<li>where b&#x3D;2 and c&#x3D;3；</li>
</ul>
<h3 id="索引下推"><a href="#索引下推" class="headerlink" title="索引下推"></a>索引下推</h3><p>索引下推功能，可以在索引遍历过程中，在存储引擎层对索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数。</p>
<p>假设我们想从一开始创建的表中，查询 name 以 ‘L’ 开头，并且 age 为 17 的人员信息。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t_user <span class="keyword">where</span> name <span class="keyword">like</span> <span class="string">&#x27;L%&#x27;</span> <span class="keyword">and</span> age <span class="operator">=</span> <span class="number">17</span>;</span><br></pre></td></tr></table></figure>

<p>在不用索引下推的情况下，根据前边”最左匹配原则”描述的那样，该查询在联合索引中只有 name 列可以使用到索引，age 列是用不到索引的。在扫描 (‘name’, age) 索引树时，根据 name like ‘L%’ 这个条件，可以查找到 LiLei、Lili、Lisa、Lucy 四条索引数据，接下来，再根据这四条索引数据中的 id 值，逐一进行回表扫描，从聚簇索引中找到相应的行数据，将找到的行数据返回给 server 层。server 层中，再根据 age &#x3D; 17 这个条件进行筛选，最终只留下 Lucy 用户的数据信息。</p>
<p>在使用索引下推的情况下，存储引擎层还是先根据 name like ‘L%’ 这个条件，查找到 LiLei、Lili、Lisa、Lucy 四条索引数据，不过接下来不是直接进行回表操作，而是根据 age &#x3D; 17 这个条件，对四条索引数据进行判断筛选，将符合条件的索引对应的 id 进行回表扫描，最终将找到的行数据返回给 server 层。（也就是我们把本应该在 server 层进行筛选的条件，下推到存储引擎层来进行筛选判断了。这个下推的前提是索引中有 age 列信息，如果是其它条件，如 gender &#x3D; 0，这个即使下推下来也没用）</p>
<p>使用索引下推优化，可以有效减少回表次数，也可以减少 server 层从存储引擎层接收数据的次数，从而大大提升查询效率。</p>
<h3 id="唯一索引和普通索引的选择"><a href="#唯一索引和普通索引的选择" class="headerlink" title="唯一索引和普通索引的选择"></a>唯一索引和普通索引的选择</h3><p>假设你在维护一个市民系统，每个人都有一个唯一的身份证号，而且业务代码已经保证了不会写入两个重复的身份证号。如果市民系统需要按照身份证号查姓名，就会执行类似这样的SQL语句：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select name from CUser where id_card = &#x27;xxxxxxxyyyyyyzzzzz&#x27;;</span><br></pre></td></tr></table></figure>

<p>此时选择普通索引还是唯一索引</p>
<p><strong>查询性能分析</strong></p>
<p>查询时两种索引性能差距很小。</p>
<p>假设，执行查询的语句是 select id from T where k&#x3D;5。这个查询语句在索引树上查找的过程，先是通过B+树从树根开始，按层搜索到叶子节点，也就是图中右下角的这个数据页，然后可以认为<strong>数据页内部通过二分法来定位记录</strong>（所以不同的索引节点不能放在同一页）。</p>
<ul>
<li>对于普通索引来说，查找到满足条件的第一个记录(5,500)后，需要查找下一个记录，直到碰到第一个不满足k&#x3D;5条件的记录。</li>
<li>对于唯一索引来说，由于索引定义了唯一性，查找到第一个满足条件的记录后，就会停止继续检索。</li>
</ul>
<p>那么，这个不同带来的性能差距会有多少呢？<strong>答案是，微乎其微。</strong></p>
<p>你知道的，InnoDB的数据是按数据页为单位来读写的。也就是说，当需要读一条记录的时候，并不是将这个记录本身从磁盘读出来，而是以页为单位，将其整体读入内存。在InnoDB中，每个数据页的大小默认是16KB。</p>
<p>因为引擎是按页读写的，所以说，当找到k&#x3D;5的记录的时候，它所在的数据页就都在内存里了。那么，对于普通索引来说，要多做的那一次“查找和判断下一条记录”的操作，就只需要一次指针寻找和一次计算。</p>
<p>当然，如果k&#x3D;5这个记录刚好是这个数据页的最后一个记录，那么要取下一个记录，必须读取下一个数据页，这个操作会稍微复杂一些。</p>
<p>但是，我们之前计算过，对于整型字段，一个数据页可以放近千个key，因此出现这种情况的概率会很低。所以，我们计算平均性能差异时，仍可以认为这个操作成本对于现在的CPU来说可以忽略不计。</p>
<p><strong>更新性能分析</strong></p>
<p>更新时由于change buffer的存在，在写多读少的业务场景下最好选择普通索引</p>
<h3 id="索引失效"><a href="#索引失效" class="headerlink" title="索引失效"></a>索引失效</h3><p>1.<strong>对索引列使用函数</strong></p>
<p>当我们在查询条件中对索引列使用函数，就会导致索引失效。</p>
<p>因为索引保存的是索引字段的原始值，而不是经过函数计算后的值，自然就没办法走索引了。</p>
<p>不过，从 MySQL 8.0 开始，索引特性增加了函数索引，即可以针对函数计算后的值建立一个索引，也就是说该索引的值是函数计算后的值，所以就可以通过扫描索引来查询数据。</p>
<p>举个例子，我通过下面这条语句，对 length(name) 的计算结果建立一个名为 idx_name_length 的索引。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> t_user <span class="keyword">add</span> key idx_name_length ((length(name)));</span><br></pre></td></tr></table></figure>

<p>2.<strong>对索引列进行表达式计算</strong></p>
<p>在查询条件中对索引进行表达式计算，也是无法走索引的。</p>
<p>比如，下面这条查询语句</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t_user <span class="keyword">where</span> id <span class="operator">+</span> <span class="number">1</span> <span class="operator">=</span> <span class="number">10</span>;</span><br></pre></td></tr></table></figure>

<p>但是，如果把查询语句的条件<strong>改成 where id &#x3D; 10 - 1</strong>，这样就不是在索引字段进行表达式计算了，于是就可以走索引查询了。</p>
<p>原因在索引保存的是索引字段的原始值，而不是 id + 1 表达式计算后的值，所以无法走索引</p>
<p>当然mysql可以进行特殊处理求出索引字段原始值，但是表达式计算的情况多种多样，每种都要考虑的话，代码可能会很臃肿，所以mysql没有这样做。</p>
<p>3.<strong>对索引使用头部模糊匹配</strong></p>
<p>当我们使用头部模糊匹配的时候，也就是 <code>like %xx</code> 或者 <code>like %xx%</code> 这两种方式都会造成索引失效。</p>
<p>如name like ‘林%’有效，name like ‘%林’则会失效</p>
<p>因为索引 B+ 树是按照索引值有序排列存储的，只能根据前缀进行比较。</p>
<p>4.<strong>字符串不加引号</strong></p>
<p>MySQL 在遇到字符串和数字比较的时候，会自动把字符串转为数字，然后再进行比较。</p>
<p>如果字符串是索引列，而条件语句中的输入参数是数字的话，那么索引列会发生隐式类型转换，由于隐式类型转换是通过 CAST 函数实现的，等同于对索引列使用了函数，所以就会导致索引失效。</p>
<p>失效例子：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t_user <span class="keyword">where</span> phone <span class="operator">=</span> <span class="number">1300000001</span>;<span class="operator">/</span><span class="operator">/</span>phone是字符串</span><br></pre></td></tr></table></figure>

<p>phone 字段为字符串，所以 MySQL 要会自动把字符串转为数字，所以这条语句相当于：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t_user <span class="keyword">where</span> <span class="built_in">CAST</span>(phone <span class="keyword">AS</span> signed <span class="type">int</span>) <span class="operator">=</span> <span class="number">1300000001</span>;</span><br></pre></td></tr></table></figure>

<p>可以看到，CAST 函数是作用在了 phone 字段，而 phone 字段是索引，也就是<strong>对索引使用了函数</strong>！而前面我们也说了，对索引使用函数是会导致索引失效的。</p>
<p>不失效例子：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t_user <span class="keyword">where</span> id <span class="operator">=</span> &quot;1&quot;;<span class="operator">/</span><span class="operator">/</span>id是数字</span><br></pre></td></tr></table></figure>

<p>这时因为字符串部分是输入参数，也就需要将字符串转为数字，所以这条语句相当于：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t_user <span class="keyword">where</span> id <span class="operator">=</span> <span class="built_in">CAST</span>(&quot;1&quot; <span class="keyword">AS</span> signed <span class="type">int</span>);</span><br></pre></td></tr></table></figure>

<p>可以看到，索引字段并没有用任何函数，CAST 函数是用在了输入参数，因此是可以走索引扫描的。</p>
<p>5.<strong>WHERE 子句中 OR 前的条件列是索引列，而在 OR 后的条件列不是索引列</strong></p>
<p>举个例子，比如下面的查询语句，id 是主键，age 是普通列，从执行计划的结果看，是走了全表扫描。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t_user <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1</span> <span class="keyword">or</span> age <span class="operator">=</span> <span class="number">18</span>;</span><br></pre></td></tr></table></figure>

<p>这是因为 OR 的含义就是两个只要满足一个即可，因此两个条件的记录都要查询，然后进行合并。只要有条件列不是索引列，就会进行全表扫描。</p>
<p>6.<strong>联合索引不遵守最左前缀法则</strong></p>
<p>7.<strong>联合索引范围查询(&gt;、&lt;、between、like等)</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> testTable <span class="keyword">where</span> a<span class="operator">&gt;</span><span class="number">1</span> <span class="keyword">and</span> b<span class="operator">=</span><span class="number">2</span></span><br></pre></td></tr></table></figure>

<p>首先a字段在B+树上是有序的，所以可以用二分查找法定位到1，然后将所有大于1的数据取出来，a可以用到索引。</p>
<p>b有序的前提是a是确定的值，那么现在a的值是取大于1的，可能有10个大于1的a，也可能有一百个a。</p>
<p>大于1的a那部分的B+树里，b字段是无序的，所以<strong>b不能用二分查找来查询</strong>，b用不到索引。（索引失效关键在于能不能使用二分查找）</p>
<p>8.<strong>优化器导致索引失效</strong></p>
<p>因为回表的原因，走索引效率不一定更高。优化器会判断走索引和全表扫描谁的效率高，若全表扫描更高时不会走索引</p>
<p><img src="C:\Users\hufei\AppData\Roaming\Typora\typora-user-images\image-20220319034349465.png" alt="image-20220319034349465"></p>
<p><img src="C:\Users\hufei\AppData\Roaming\Typora\typora-user-images\image-20220319035020522.png" alt="image-20220319035020522"></p>
<p><img src="C:\Users\hufei\AppData\Roaming\Typora\typora-user-images\image-20220319035416073.png" alt="image-20220319035416073"></p>
<p><img src="C:\Users\hufei\AppData\Roaming\Typora\typora-user-images\image-20220319035556705.png" alt="image-20220319035556705"></p>
<h3 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h3><p><code>show global status like &#39;Com______&#39;</code>&#x2F;&#x2F;查询数据库增删改查各自的访问频次</p>
<p><img src="C:\Users\hufei\AppData\Roaming\Typora\typora-user-images\image-20220319030133337.png" alt="image-20220319030133337"></p>
<p><img src="C:\Users\hufei\AppData\Roaming\Typora\typora-user-images\image-20220319030637629.png" alt="image-20220319030637629"></p>
<p><img src="C:\Users\hufei\AppData\Roaming\Typora\typora-user-images\image-20220319031045669.png" alt="image-20220319031045669"></p>
<h3 id="sql优化"><a href="#sql优化" class="headerlink" title="sql优化"></a>sql优化</h3><h4 id="插入优化"><a href="#插入优化" class="headerlink" title="插入优化"></a>插入优化</h4><p><img src="C:\Users\hufei\AppData\Roaming\Typora\typora-user-images\image-20220320212637861.png" alt="image-20220320212637861"></p>
<p>插入大批量数据使用load</p>
<h4 id="主键优化"><a href="#主键优化" class="headerlink" title="主键优化"></a>主键优化</h4><p><img src="C:\Users\hufei\AppData\Roaming\Typora\typora-user-images\image-20220320213439189.png" alt="image-20220320213439189"></p>
<p><img src="C:\Users\hufei\AppData\Roaming\Typora\typora-user-images\image-20220320213503174.png" alt="image-20220320213503174"></p>
<p><img src="C:\Users\hufei\AppData\Roaming\Typora\typora-user-images\image-20220320213613180.png" alt="image-20220320213613180"></p>
<h4 id="排序优化"><a href="#排序优化" class="headerlink" title="排序优化"></a>排序优化</h4><p><img src="C:\Users\hufei\AppData\Roaming\Typora\typora-user-images\image-20220320214021525.png" alt="image-20220320214021525"></p>
<h4 id="分组优化"><a href="#分组优化" class="headerlink" title="分组优化"></a>分组优化</h4><p><img src="C:\Users\hufei\AppData\Roaming\Typora\typora-user-images\image-20220320214238071.png" alt="image-20220320214238071"></p>
<h4 id="limit优化"><a href="#limit优化" class="headerlink" title="limit优化"></a>limit优化</h4><p><img src="C:\Users\hufei\AppData\Roaming\Typora\typora-user-images\image-20220320214906293.png" alt="image-20220320214906293"></p>
<h4 id="count优化"><a href="#count优化" class="headerlink" title="count优化"></a>count优化</h4><p><img src="C:\Users\hufei\AppData\Roaming\Typora\typora-user-images\image-20220320215359582.png" alt="image-20220320215359582"></p>
<p><img src="C:\Users\hufei\AppData\Roaming\Typora\typora-user-images\image-20220320215330621.png" alt="image-20220320215330621"></p>
<h4 id="update优化"><a href="#update优化" class="headerlink" title="update优化"></a>update优化</h4><p><img src="C:\Users\hufei\AppData\Roaming\Typora\typora-user-images\image-20220320220409456.png" alt="image-20220320220409456"></p>
<h3 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h3><p><img src="C:\Users\hufei\AppData\Roaming\Typora\typora-user-images\image-20220320221846951.png" alt="image-20220320221846951"></p>
<p><img src="C:\Users\hufei\AppData\Roaming\Typora\typora-user-images\image-20220320221528463.png" alt="image-20220320221528463"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/01/22/mysql/" data-id="cld6uiojg000cacsf7csbconu" data-title="" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-muduo网络源码" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/01/22/muduo%E7%BD%91%E7%BB%9C%E6%BA%90%E7%A0%81/" class="article-date">
  <time class="dt-published" datetime="2023-01-22T03:54:01.949Z" itemprop="datePublished">2023-01-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="muduo网络源码"><a href="#muduo网络源码" class="headerlink" title="muduo网络源码"></a>muduo网络源码</h1><p>学到的东西：tie延长生命周期；vector的首指针可以直接代替数组首指针；</p>
<h2 id="各个类详解"><a href="#各个类详解" class="headerlink" title="各个类详解"></a>各个类详解</h2><h3 id="channel"><a href="#channel" class="headerlink" title="channel"></a>channel</h3><p>Channel类封装了poll&#x2F;epoll中的 <code>I/O</code> 事件(epoll_event)和事件对应的回调函数，不拥有 <code>fd</code>，可以代表多种实体：<code>listening fd</code>、<code>timer fd</code>、<code>event fd</code> 等。</p>
<p>每个Channel对象自始至终只属于一个EventLoop，因此每个Channel对象都只属于某一个IO线程。</p>
<p>每个Channel对象自始至终只负责一个文件描述符（fd）的IO事件分发，但它并不拥有这个fd，也不会在析构的时候关闭这个fd。</p>
<p>Muduo用户一般不直接使用Channel，而会使用更上层的封装，如TcpConnection。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Channel</span> : noncopyable</span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">typedef</span> std::function&lt;<span class="type">void</span>()&gt; EventCallback;</span><br><span class="line">  <span class="keyword">typedef</span> std::function&lt;<span class="type">void</span>(Timestamp)&gt; ReadEventCallback;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">Channel</span>(EventLoop* loop, <span class="type">int</span> fd);</span><br><span class="line">  ~<span class="built_in">Channel</span>();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">handleEvent</span><span class="params">(Timestamp receiveTime)</span></span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> kNoneEvent;</span><br><span class="line">  <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> kReadEvent;</span><br><span class="line">  <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> kWriteEvent;</span><br><span class="line"></span><br><span class="line">  EventLoop* loop_;</span><br><span class="line">  <span class="type">const</span> <span class="type">int</span>  fd_;</span><br><span class="line">  <span class="type">int</span>        events_;</span><br><span class="line">  <span class="type">int</span>        revents_; <span class="comment">// it&#x27;s the received event types of epoll or poll</span></span><br><span class="line">  <span class="type">int</span>        index_; <span class="comment">// used by Poller.</span></span><br><span class="line"></span><br><span class="line">  ReadEventCallback readCallback_;</span><br><span class="line">  EventCallback writeCallback_;</span><br><span class="line">  EventCallback closeCallback_;</span><br><span class="line">  EventCallback errorCallback_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>events_</code> 是 <code>Channel</code> 关心的事件，<code>Poller</code> 根据这个来设置。<code>revents_</code> 是 <code>Poller</code> 返回的已就绪的事件，<code>handleEvent()</code> 会调用相应的 <code>callback</code> 来处理。</p>
<p>所有需要由 <code>EventLoop</code> 处理的如 <code>Acceptor</code>、<code>TcpConnection</code> 都有 <code>Channel</code> 成员并设置 <code>callback</code> 注册到 <code>EventLoop</code> 中。<code>Muduo</code> 的 <code>callback</code> 基本都是 <code>member function</code>， 用 <code>std::bind()</code> 绑定 <code>this</code> 指针来注册，一些网络库会采用继承接口类来实现回调的注册。</p>
<p><strong>源码分析</strong></p>
<p>Channel.h源码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> MUDUO_NET_CHANNEL_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MUDUO_NET_CHANNEL_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/function.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/noncopyable.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/shared_ptr.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/weak_ptr.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;muduo/base/Timestamp.h&gt;</span></span></span><br><span class="line"><span class="comment">/*个人理解：channel是一个具体来处理事件的类，它与eventloop关系紧密，主要是根据事件宏定义来调用对应的回调函数</span></span><br><span class="line"><span class="comment"> *主要的事件有三种，读事件，写事件和结束事件</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">namespace</span> muduo &#123;</span><br><span class="line">    <span class="keyword">namespace</span> net &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">class</span> <span class="title class_">EventLoop</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// A selectable I/O channel.</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// This class doesn&#x27;t own the file descriptor.</span></span><br><span class="line"><span class="comment">/// The file descriptor could be a socket,</span></span><br><span class="line"><span class="comment">/// an eventfd, a timerfd, or a signalfd</span></span><br><span class="line">        <span class="keyword">class</span> <span class="title class_">Channel</span> : boost::noncopyable &#123;</span><br><span class="line">        <span class="keyword">public</span>:</span><br><span class="line">            <span class="keyword">typedef</span> boost::function&lt;<span class="type">void</span>()&gt; EventCallback;</span><br><span class="line">            <span class="keyword">typedef</span> boost::function&lt;<span class="type">void</span>(Timestamp)&gt; ReadEventCallback;<span class="comment">//读事件的回调函数中必须有参数Timestamp</span></span><br><span class="line"></span><br><span class="line">            <span class="built_in">Channel</span>(EventLoop *loop, <span class="type">int</span> fd);<span class="comment">//一个channel要绑定一个EventLoop和一个文件描述符，但channel无权操作fd</span></span><br><span class="line">            ~<span class="built_in">Channel</span>();</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="type">void</span> <span class="title">handleEvent</span><span class="params">(Timestamp receiveTime)</span></span>;<span class="comment">//处理事件</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">//设置四种事件的回调函数</span></span><br><span class="line">            <span class="function"><span class="type">void</span> <span class="title">setReadCallback</span><span class="params">(<span class="type">const</span> ReadEventCallback &amp;cb)</span> </span>&#123; readCallback_ = cb; &#125;</span><br><span class="line">            <span class="function"><span class="type">void</span> <span class="title">setWriteCallback</span><span class="params">(<span class="type">const</span> EventCallback &amp;cb)</span> </span>&#123; writeCallback_ = cb; &#125;</span><br><span class="line">            <span class="function"><span class="type">void</span> <span class="title">setCloseCallback</span><span class="params">(<span class="type">const</span> EventCallback &amp;cb)</span> </span>&#123; closeCallback_ = cb; &#125;</span><br><span class="line">            <span class="function"><span class="type">void</span> <span class="title">setErrorCallback</span><span class="params">(<span class="type">const</span> EventCallback &amp;cb)</span> </span>&#123; errorCallback_ = cb; &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/// Tie this channel to the owner object managed by shared_ptr,</span></span><br><span class="line">            <span class="comment">/// prevent the owner object being destroyed in handleEvent.</span></span><br><span class="line">            <span class="comment">//这个函数，用于延长某些对象的生命期，使其寿命长过Channel::handleEvent()函数。</span></span><br><span class="line">            <span class="function"><span class="type">void</span> <span class="title">tie</span><span class="params">(<span class="type">const</span> boost::shared_ptr&lt;<span class="type">void</span>&gt; &amp;)</span></span>;<span class="comment">//将一个shared_ptr指针的值赋给tie_</span></span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="type">int</span> <span class="title">fd</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> fd_; &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="type">int</span> <span class="title">events</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> events_; &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="type">void</span> <span class="title">set_revents</span><span class="params">(<span class="type">int</span> revt)</span> </span>&#123; revents_ = revt; &#125; <span class="comment">// used by pollers</span></span><br><span class="line">            <span class="comment">// int revents() const &#123; return revents_; &#125;</span></span><br><span class="line">            <span class="function"><span class="type">bool</span> <span class="title">isNoneEvent</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> events_ == kNoneEvent; &#125;<span class="comment">//判断事件是否为0，也就是没有关注的事件</span></span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="type">void</span> <span class="title">enableReading</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                events_ |= kReadEvent;</span><br><span class="line">                <span class="built_in">update</span>();</span><br><span class="line">            &#125;<span class="comment">//设置读事件，并将当前channel加入到poll队列当中</span></span><br><span class="line">            <span class="comment">// void disableReading() &#123; events_ &amp;= ~kReadEvent; update(); &#125;</span></span><br><span class="line">            <span class="function"><span class="type">void</span> <span class="title">enableWriting</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                events_ |= kWriteEvent;</span><br><span class="line">                <span class="built_in">update</span>();</span><br><span class="line">            &#125;<span class="comment">//设置写事件，并将当前channel加入到poll队列当中</span></span><br><span class="line">            <span class="function"><span class="type">void</span> <span class="title">disableWriting</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                events_ &amp;= ~kWriteEvent;</span><br><span class="line">                <span class="built_in">update</span>();</span><br><span class="line">            &#125;<span class="comment">//关闭写事件，并将当前channel加入到poll队列当中</span></span><br><span class="line">            <span class="function"><span class="type">void</span> <span class="title">disableAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                events_ = kNoneEvent;</span><br><span class="line">                <span class="built_in">update</span>();</span><br><span class="line">            &#125;<span class="comment">//关闭所有事件，并暂时删除当前channel</span></span><br><span class="line">            <span class="function"><span class="type">bool</span> <span class="title">isWriting</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> events_ &amp; kWriteEvent; &#125;<span class="comment">//是否关注写事件</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// for Poller</span></span><br><span class="line">            <span class="function"><span class="type">int</span> <span class="title">index</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> index_; &#125;<span class="comment">//返回序号</span></span><br><span class="line">            <span class="function"><span class="type">void</span> <span class="title">set_index</span><span class="params">(<span class="type">int</span> idx)</span> </span>&#123; index_ = idx; &#125;<span class="comment">//设置序号</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// for debug</span></span><br><span class="line">            <span class="function">string <span class="title">reventsToString</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="type">void</span> <span class="title">doNotLogHup</span><span class="params">()</span> </span>&#123; logHup_ = <span class="literal">false</span>; &#125;<span class="comment">//把挂起标志位置false</span></span><br><span class="line"></span><br><span class="line">            <span class="function">EventLoop *<span class="title">ownerLoop</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> loop_; &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="type">void</span> <span class="title">remove</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span>:</span><br><span class="line">            <span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="type">void</span> <span class="title">handleEventWithGuard</span><span class="params">(Timestamp receiveTime)</span></span>;</span><br><span class="line"></span><br><span class="line">            <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> kNoneEvent;</span><br><span class="line">            <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> kReadEvent;</span><br><span class="line">            <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> kWriteEvent;</span><br><span class="line"></span><br><span class="line">            EventLoop *loop_;            <span class="comment">// 所属EventLoop</span></span><br><span class="line">            <span class="type">const</span> <span class="type">int</span> fd_;            <span class="comment">// 文件描述符，但不负责关闭该文件描述符</span></span><br><span class="line">            <span class="type">int</span> events_;        <span class="comment">// 需要epoll关注的事件</span></span><br><span class="line">            <span class="type">int</span> revents_;        <span class="comment">// poll/epoll wait返回的需要处理的事件</span></span><br><span class="line">            <span class="type">int</span> index_;        <span class="comment">// used by Poller.表示在epoll队列中的状态：1.正在队列中2.曾经在队列中3.从来没在队列中</span></span><br><span class="line">            <span class="type">bool</span> logHup_;        <span class="comment">// for POLLHUP是否被挂起</span></span><br><span class="line"></span><br><span class="line">            boost::weak_ptr&lt;<span class="type">void</span>&gt; tie_;<span class="comment">//保证channel所在的类</span></span><br><span class="line">            <span class="type">bool</span> tied_;</span><br><span class="line">            <span class="type">bool</span> eventHandling_;        <span class="comment">// 是否处于处理事件中</span></span><br><span class="line">            ReadEventCallback readCallback_;<span class="comment">//当文件描述符产生读事件时，最后调用的读函数</span></span><br><span class="line">            EventCallback writeCallback_;<span class="comment">//当文件描述符产生写事件时，最后调用的写函数</span></span><br><span class="line">            EventCallback closeCallback_;<span class="comment">//当文件描述符产生关闭事件时，最后调用的关闭函数</span></span><br><span class="line">            EventCallback errorCallback_;<span class="comment">//当文件描述符产生错误事件时，最后调用的错误函数</span></span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span>  <span class="comment">// MUDUO_NET_CHANNEL_H</span></span></span><br></pre></td></tr></table></figure>

<p>Channel.cc源码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;muduo/base/Logging.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;muduo/net/Channel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;muduo/net/EventLoop.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;poll.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> muduo;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> muduo::net;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> Channel::kNoneEvent = <span class="number">0</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> Channel::kReadEvent = POLLIN | POLLPRI;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> Channel::kWriteEvent = POLLOUT;</span><br><span class="line"></span><br><span class="line">Channel::<span class="built_in">Channel</span>(EventLoop *loop, <span class="type">int</span> fd__)</span><br><span class="line">        : <span class="built_in">loop_</span>(loop),</span><br><span class="line">          <span class="built_in">fd_</span>(fd__),</span><br><span class="line">          <span class="built_in">events_</span>(<span class="number">0</span>),</span><br><span class="line">          <span class="built_in">revents_</span>(<span class="number">0</span>),</span><br><span class="line">          <span class="built_in">index_</span>(<span class="number">-1</span>),<span class="comment">//就是kNew</span></span><br><span class="line">          <span class="built_in">logHup_</span>(<span class="literal">true</span>),</span><br><span class="line">          <span class="built_in">tied_</span>(<span class="literal">false</span>),</span><br><span class="line">          <span class="built_in">eventHandling_</span>(<span class="literal">false</span>) &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Channel::~<span class="built_in">Channel</span>() &#123;</span><br><span class="line">    <span class="built_in">assert</span>(!eventHandling_);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Channel::tie</span><span class="params">(<span class="type">const</span> boost::shared_ptr&lt;<span class="type">void</span>&gt; &amp;obj)</span><span class="comment">//给tie_指针赋值，tie_指针是一个weak_ptr指针</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tie_ = obj;</span><br><span class="line">    tied_ = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Channel::update</span><span class="params">()</span><span class="comment">//把当前的channel加入到poll队列当中</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    loop_-&gt;<span class="built_in">updateChannel</span>(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用这个函数之前确保调用disableAll</span></span><br><span class="line"><span class="comment">// 从EventLoop中移除这个channel</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Channel::remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(<span class="built_in">isNoneEvent</span>());</span><br><span class="line">    loop_-&gt;<span class="built_in">removeChannel</span>(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Channel::handleEvent</span><span class="params">(Timestamp receiveTime)</span><span class="comment">//Timestamp主要用于读事件的回调函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//guard是一个shared_ptr，这样guard指向的对象在智能指针析构前就不会析构了，延长了生命周期</span></span><br><span class="line">    boost::shared_ptr&lt;<span class="type">void</span>&gt; guard;</span><br><span class="line">    <span class="keyword">if</span> (tied_) &#123;</span><br><span class="line">        guard = tie_.<span class="built_in">lock</span>();<span class="comment">//提升tie_为shared_ptr，如果提升成功，说明指向一个存在的对象</span></span><br><span class="line">        <span class="keyword">if</span> (guard) &#123;</span><br><span class="line">            LOG_TRACE &lt;&lt; <span class="string">&quot;[6] usecount=&quot;</span> &lt;&lt; guard.<span class="built_in">use_count</span>();</span><br><span class="line">            <span class="built_in">handleEventWithGuard</span>(receiveTime);</span><br><span class="line">            LOG_TRACE &lt;&lt; <span class="string">&quot;[12] usecount=&quot;</span> &lt;&lt; guard.<span class="built_in">use_count</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">handleEventWithGuard</span>(receiveTime);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Channel::handleEventWithGuard</span><span class="params">(Timestamp receiveTime)</span></span></span><br><span class="line"><span class="function"><span class="comment">//查看epoll/poll返回的具体是什么事件，并根据事件的类型进行相应的处理</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    eventHandling_ = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    if (revents_ &amp; POLLHUP)</span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">        LOG_TRACE &lt;&lt; &quot;1111111111111111&quot;;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    if (revents_ &amp; POLLIN)</span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">        LOG_TRACE &lt;&lt; &quot;2222222222222222&quot;;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">if</span> ((revents_ &amp; POLLHUP) &amp;&amp; !(revents_ &amp; POLLIN))<span class="comment">//当事件为挂起并没有可读事件时</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (logHup_) &#123;</span><br><span class="line">            LOG_WARN &lt;&lt; <span class="string">&quot;Channel::handle_event() POLLHUP&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (closeCallback_) <span class="built_in">closeCallback_</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (revents_ &amp; POLLNVAL)<span class="comment">//描述字不是一个打开的文件描述符</span></span><br><span class="line">    &#123;</span><br><span class="line">        LOG_WARN &lt;&lt; <span class="string">&quot;Channel::handle_event() POLLNVAL&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (revents_ &amp; (POLLERR | POLLNVAL))<span class="comment">//发生错误或者描述符不可打开</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (errorCallback_) <span class="built_in">errorCallback_</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (revents_ &amp; (POLLIN | POLLPRI | POLLRDHUP))<span class="comment">//关于读的事件</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (readCallback_) <span class="built_in">readCallback_</span>(receiveTime);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (revents_ &amp; POLLOUT)<span class="comment">//关于写的事件</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (writeCallback_) <span class="built_in">writeCallback_</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    eventHandling_ = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">string <span class="title">Channel::reventsToString</span><span class="params">()</span> <span class="type">const</span><span class="comment">//把事件转成一个string，用于日志打印debug</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::ostringstream oss;</span><br><span class="line">    oss &lt;&lt; fd_ &lt;&lt; <span class="string">&quot;: &quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> (revents_ &amp; POLLIN)</span><br><span class="line">        oss &lt;&lt; <span class="string">&quot;IN &quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> (revents_ &amp; POLLPRI)</span><br><span class="line">        oss &lt;&lt; <span class="string">&quot;PRI &quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> (revents_ &amp; POLLOUT)</span><br><span class="line">        oss &lt;&lt; <span class="string">&quot;OUT &quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> (revents_ &amp; POLLHUP)</span><br><span class="line">        oss &lt;&lt; <span class="string">&quot;HUP &quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> (revents_ &amp; POLLRDHUP)</span><br><span class="line">        oss &lt;&lt; <span class="string">&quot;RDHUP &quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> (revents_ &amp; POLLERR)</span><br><span class="line">        oss &lt;&lt; <span class="string">&quot;ERR &quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> (revents_ &amp; POLLNVAL)</span><br><span class="line">        oss &lt;&lt; <span class="string">&quot;NVAL &quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> oss.<span class="built_in">str</span>().<span class="built_in">c_str</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Channel::tie()详解</strong></p>
<p>这里是一个智能指针使用的特定场景之一，用于特定时刻延长对象的生命周期。我们知道持有对象的shared_ptr可以延长对象的生命周期，但是如果我们只想在特定时刻延长对象的生命周期怎么办(比如执行对象的成员函数时)。解决方法就是持有对象的weak_ptr，并在函数内升级为shared_ptr。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//给tie_指针赋值，tie_指针是一个weak_ptr指针</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Channel::tie</span><span class="params">(<span class="type">const</span> boost::shared_ptr&lt;<span class="type">void</span>&gt; &amp;obj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tie_ = obj;</span><br><span class="line">    tied_ = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Channel::handleEvent</span><span class="params">(Timestamp receiveTime)</span><span class="comment">//Timestamp主要用于读事件的回调函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//guard是一个shared_ptr，这样guard指向的对象在handleEventWithGuard()函数执行期间就不会析构了，延长了生命周期</span></span><br><span class="line">    boost::shared_ptr&lt;<span class="type">void</span>&gt; guard;</span><br><span class="line">    <span class="keyword">if</span> (tied_) &#123;</span><br><span class="line">        guard = tie_.<span class="built_in">lock</span>();<span class="comment">//提升tie_为shared_ptr，如果提升成功，说明指向一个存在的对象</span></span><br><span class="line">        <span class="keyword">if</span> (guard) &#123;</span><br><span class="line">            LOG_TRACE &lt;&lt; <span class="string">&quot;[6] usecount=&quot;</span> &lt;&lt; guard.<span class="built_in">use_count</span>();</span><br><span class="line">            <span class="built_in">handleEventWithGuard</span>(receiveTime);</span><br><span class="line">            LOG_TRACE &lt;&lt; <span class="string">&quot;[12] usecount=&quot;</span> &lt;&lt; guard.<span class="built_in">use_count</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">handleEventWithGuard</span>(receiveTime);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结合例子分析，看下面的一个调用时序图</p>
<p><img src="https://raw.githubusercontent.com/hufei96/Image/main/muduo_tie.png" alt="img"></p>
<p>当对方断开TCP连接，这个IO事件会触发Channel::handleEvent()调用，后者会调用用户提供的CloseCallback，而用户代码在onClose()中有可能析构Channel对象，这就造成了灾难。等于说Channel::handleEvent()执行到一半的时候，其所属的Channel对象本身被销毁了。这时程序无疑会出错或崩溃。</p>
<p>Muduo的解决办法是提供Channel::tie(const boost::shared_ptr<void>&amp;)这个函数，用于延长某些对象（可以是Channel对象，也可以是其owner对象）的生命周期，使之长过Channel::handleEvent()函数。</p>
<p>Muduo TcpConnection采用shared_ptr管理对象生命期的原因之一就是因为这个。</p>
<p>当有关闭事件时，调用流程如下：</p>
<p>Channel::handleEvent -&gt; TcpConnection::handleClose -&gt;TcpClient::removeConnection -&gt;TcpConnection::connectDestroyed-&gt;channel_-&gt;remove()。</p>
<p>1、为了在Channel::handleEvent处理期间，防止因其owner对象被修改，进而导致Channel被析构，最后出现不可预估错误。 Channel::tie()的作用就是将Channel的owner对象进行绑定保护起来。</p>
<p> 2、另外channel-&gt;remove的作用是删除channel在Poll中的地址拷贝，而不是销毁channel。channel的销毁由其owner对象决定。</p>
<h3 id="poller"><a href="#poller" class="headerlink" title="poller"></a>poller</h3><p>Poller class 是IO multiplexing的封装。在muduo中它是一个抽象类，因为muduo同时支持poll和epoll两种IO multiplexing机制。</p>
<p>Poller是EventLoop的间接成员，只供其owner EventLoop在IO线程中调用，因此无需加锁。其生命周期和EvenLoop相等。Poller并不拥有Channel，Channel在析构前必须自己unregister（EventLoop::removeChannel()）,避免悬空指针。</p>
<p><strong>Poller.h</strong></p>
<p>Poller.h只是一个简单的抽象类</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> MUDUO_NET_POLLER_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MUDUO_NET_POLLER_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/noncopyable.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;muduo/base/Timestamp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;muduo/net/EventLoop.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> muduo &#123;</span><br><span class="line">    <span class="keyword">namespace</span> net &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">class</span> <span class="title class_">Channel</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// Base class for IO Multiplexing</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// This class doesn&#x27;t own the Channel objects.</span></span><br><span class="line">        <span class="comment">// 这个Poller类只是一个抽象类主要实现在EpollPoller/PollPoller中</span></span><br><span class="line">        <span class="keyword">class</span> <span class="title class_">Poller</span> : boost::noncopyable &#123;</span><br><span class="line">        <span class="keyword">public</span>:</span><br><span class="line">            <span class="keyword">typedef</span> std::vector&lt;Channel *&gt; ChannelList;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">Poller</span>(EventLoop *loop);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">virtual</span> ~<span class="built_in">Poller</span>();</span><br><span class="line"></span><br><span class="line">            <span class="comment">/// Polls the I/O events.</span></span><br><span class="line">            <span class="comment">/// Must be called in the loop thread.</span></span><br><span class="line">            <span class="function"><span class="keyword">virtual</span> Timestamp <span class="title">poll</span><span class="params">(<span class="type">int</span> timeoutMs, ChannelList *activeChannels)</span> </span>= <span class="number">0</span>; <span class="comment">// poll函数</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">/// Changes the interested I/O events.</span></span><br><span class="line">            <span class="comment">/// Must be called in the loop thread.</span></span><br><span class="line">            <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">updateChannel</span><span class="params">(Channel *channel)</span> </span>= <span class="number">0</span>;<span class="comment">// 更新Channel</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">/// Remove the channel, when it destructs.</span></span><br><span class="line">            <span class="comment">/// Must be called in the loop thread.</span></span><br><span class="line">            <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">removeChannel</span><span class="params">(Channel *channel)</span> </span>= <span class="number">0</span>;    <span class="comment">// 移除Channel</span></span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="type">static</span> Poller *<span class="title">newDefaultPoller</span><span class="params">(EventLoop *loop)</span></span>;<span class="comment">// 在这里会根据环境变量生成epoll或者poll</span></span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="type">void</span> <span class="title">assertInLoopThread</span><span class="params">()</span> </span>&#123;<span class="comment">// 确保所有的操作都在eventloop的线程中</span></span><br><span class="line">                ownerLoop_-&gt;<span class="built_in">assertInLoopThread</span>();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span>:</span><br><span class="line">            EventLoop *ownerLoop_;    <span class="comment">// Poller所属EventLoop</span></span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span>  <span class="comment">// MUDUO_NET_POLLER_H</span></span></span><br></pre></td></tr></table></figure>

<p><strong>EPollPoller.h</strong></p>
<p>这个类主要利用epoll函数，封装了epoll三个函数，</p>
<p>其中epoll_event.data是一个指向channel类的指针，这里可以等价理解为channel就是epoll_event，用于在epoll队列中注册，删除，更改的结构体。因为文件描述符fd，Channel，以及epoll_event结构体（只有需要添加到epoll上时才有epoll_event结构体）三个都是一一对应的关系Channel.fd应该等于fd，epoll_event.data应该等于&amp;Channel。如果不添加到epoll队列中，Channel和fd一一对应，就没有epoll_event结构体了</p>
<p>从epoll队列中删除有两种删除方法，</p>
<p>第一种暂时删除，就是从epoll队列中删除，并且把标志位置为kDeleted，但是并不从ChannelMap channels_中删除</p>
<p>第二种是完全删除，从epoll队列中删除，并且从ChannelMap channels_中也删除，最后把标志位置kNew。</p>
<p>可以理解为ChannelMap channels_的作用就是：暂时不需要的，就从epoll队列中删除，但是在channels_中保留信息，类似与挂起，这样下次再使用这个channel时，只需要添加到epoll队列中即可。而完全删除，就把channels_中也删除。</p>
<p>下面的源码有详细的注释</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> MUDUO_NET_POLLER_EPOLLPOLLER_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MUDUO_NET_POLLER_EPOLLPOLLER_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;muduo/net/Poller.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">epoll_event</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> muduo &#123;</span><br><span class="line">    <span class="keyword">namespace</span> net &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// IO Multiplexing with epoll(4).</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line">        <span class="keyword">class</span> <span class="title class_">EPollPoller</span> : <span class="keyword">public</span> Poller &#123;</span><br><span class="line">        <span class="keyword">public</span>:</span><br><span class="line">            <span class="built_in">EPollPoller</span>(EventLoop *loop);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">virtual</span> ~<span class="built_in">EPollPoller</span>();</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">virtual</span> Timestamp <span class="title">poll</span><span class="params">(<span class="type">int</span> timeoutMs, ChannelList *activeChannels)</span></span>;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">updateChannel</span><span class="params">(Channel *channel)</span></span>;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">removeChannel</span><span class="params">(Channel *channel)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span>:</span><br><span class="line">            <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> kInitEventListSize = <span class="number">16</span>; <span class="comment">//默认事件数组大小，是用来装epoll_wait()返回的可读或可写事件的</span></span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="type">void</span> <span class="title">fillActiveChannels</span><span class="params">(<span class="type">int</span> numEvents, ChannelList *activeChannels)</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> operation, Channel *channel)</span></span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">typedef</span> std::vector&lt;<span class="keyword">struct</span> epoll_event&gt; EventList;</span><br><span class="line">            <span class="keyword">typedef</span> std::map&lt;<span class="type">int</span>, Channel *&gt; ChannelMap;</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> epollfd_;<span class="comment">//epoll监视的文件描述符</span></span><br><span class="line">            EventList events_;<span class="comment">//用来存储活跃文件描述符的epoll_event结构体数组</span></span><br><span class="line">            ChannelMap channels_;<span class="comment">//记录标志符是kAdded或者kDeleted的channel和fd</span></span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span>  <span class="comment">// MUDUO_NET_POLLER_EPOLLPOLLER_H</span></span></span><br></pre></td></tr></table></figure>

<p><strong>EPollPoller.cc</strong></p>
<p>主要是一些EPollPoller类的具体实现，注释很详细。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;muduo/net/poller/EPollPoller.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;muduo/base/Logging.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;muduo/net/Channel.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/static_assert.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;poll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> muduo;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> muduo::net;</span><br><span class="line"></span><br><span class="line"><span class="comment">// On Linux, the constants of poll(2) and epoll(4)</span></span><br><span class="line"><span class="comment">// are expected to be the same.</span></span><br><span class="line"><span class="built_in">BOOST_STATIC_ASSERT</span>(EPOLLIN</span><br><span class="line">== POLLIN);</span><br><span class="line"><span class="built_in">BOOST_STATIC_ASSERT</span>(EPOLLPRI</span><br><span class="line">== POLLPRI);</span><br><span class="line"><span class="built_in">BOOST_STATIC_ASSERT</span>(EPOLLOUT</span><br><span class="line">== POLLOUT);</span><br><span class="line"><span class="built_in">BOOST_STATIC_ASSERT</span>(EPOLLRDHUP</span><br><span class="line">== POLLRDHUP);</span><br><span class="line"><span class="built_in">BOOST_STATIC_ASSERT</span>(EPOLLERR</span><br><span class="line">== POLLERR);</span><br><span class="line"><span class="built_in">BOOST_STATIC_ASSERT</span>(EPOLLHUP</span><br><span class="line">== POLLHUP);</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> kNew = <span class="number">-1</span>;<span class="comment">//代表不在epoll队列中，也不在ChannelMap channels_中</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> kAdded = <span class="number">1</span>;<span class="comment">//代表正在epoll队列当中</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> kDeleted = <span class="number">2</span>;<span class="comment">//代表曾经在epoll队列当中过，但是被删除了，现在不在了，但是还是在ChannelMap channels_中的</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">EPollPoller::<span class="built_in">EPollPoller</span>(EventLoop *loop)</span><br><span class="line">        : <span class="built_in">Poller</span>(loop),<span class="comment">//所属的EventLoop</span></span><br><span class="line">          <span class="built_in">epollfd_</span>(::<span class="built_in">epoll_create1</span>(EPOLL_CLOEXEC)),<span class="comment">//创建一个epoll文件描述符，用来监听所有注册的事件</span></span><br><span class="line">          <span class="built_in">events_</span>(kInitEventListSize) &#123;<span class="comment">//初始化vector</span></span><br><span class="line">    <span class="keyword">if</span> (epollfd_ &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        LOG_SYSFATAL &lt;&lt; <span class="string">&quot;EPollPoller::EPollPoller&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">EPollPoller::~<span class="built_in">EPollPoller</span>()<span class="comment">//关闭epoll文件描述符</span></span><br><span class="line">&#123;</span><br><span class="line">    ::<span class="built_in">close</span>(epollfd_);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Timestamp <span class="title">EPollPoller::poll</span><span class="params">(<span class="type">int</span> timeoutMs, ChannelList *activeChannels)</span><span class="comment">//封装epoll_wait</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> numEvents = ::<span class="built_in">epoll_wait</span>(epollfd_,</span><br><span class="line">                                 &amp;*events_.<span class="built_in">begin</span>(),<span class="comment">//等价于&amp;events[0],就是传入一个vecotr&lt;struct epoll_event&gt;的首指针进去,用vector首指针代替了数组首指针</span></span><br><span class="line">                                 <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(events_.<span class="built_in">size</span>()),</span><br><span class="line">                                 timeoutMs);</span><br><span class="line">    <span class="function">Timestamp <span class="title">now</span><span class="params">(Timestamp::now())</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (numEvents &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        LOG_TRACE &lt;&lt; numEvents &lt;&lt; <span class="string">&quot; events happended&quot;</span>;</span><br><span class="line">        <span class="built_in">fillActiveChannels</span>(numEvents, activeChannels);</span><br><span class="line">        <span class="comment">//如果返回的事件数目等于当前事件数组大小，就就扩充events_，分配2倍空间,</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">implicit_cast</span>&lt;<span class="type">size_t</span>&gt;(numEvents) == events_.<span class="built_in">size</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            events_.<span class="built_in">resize</span>(events_.<span class="built_in">size</span>() * <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (numEvents == <span class="number">0</span>)<span class="comment">//如果timeoutMs设置的是大于0的数，也就是超时时间有效的话，那么过了超时时间并且没有事件发生，就会出现这种情况</span></span><br><span class="line">    &#123;</span><br><span class="line">        LOG_TRACE &lt;&lt; <span class="string">&quot; nothing happended&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        LOG_SYSERR &lt;&lt; <span class="string">&quot;EPollPoller::poll()&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> now;<span class="comment">//返回的是事件发生时的时间</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">EPollPoller::fillActiveChannels</span><span class="params">(<span class="type">int</span> numEvents,</span></span></span><br><span class="line"><span class="params"><span class="function">                                     ChannelList *activeChannels)</span> <span class="type">const</span> <span class="comment">//epoll_event转为channel</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(<span class="built_in">implicit_cast</span>&lt;<span class="type">size_t</span>&gt;(numEvents) &lt;= events_.<span class="built_in">size</span>());</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numEvents; ++i)<span class="comment">//将返回的活跃epoll_event转成channel放到activeChannels列表中</span></span><br><span class="line">    &#123;</span><br><span class="line">        Channel *channel = <span class="built_in">static_cast</span>&lt;Channel *&gt;(events_[i].data.ptr);<span class="comment">//把产生事件的channel变量拿出来</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">这是epoll模式epoll_event事件的数据结构，其中data不仅可以保存fd，也可以保存一个void*类型的指针。</span></span><br><span class="line"><span class="comment">typedef union epoll_data &#123;</span></span><br><span class="line"><span class="comment">               void    *ptr;</span></span><br><span class="line"><span class="comment">               int      fd;</span></span><br><span class="line"><span class="comment">               uint32_t u32;</span></span><br><span class="line"><span class="comment">               uint64_t u64;</span></span><br><span class="line"><span class="comment">           &#125; epoll_data_t;</span></span><br><span class="line"><span class="comment">           struct epoll_event &#123;</span></span><br><span class="line"><span class="comment">               uint32_t     events;    // Epoll events</span></span><br><span class="line"><span class="comment">               epoll_data_t data;      //User data variable</span></span><br><span class="line"><span class="comment">           &#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> NDEBUG<span class="comment">//在调试时会执行下面的代码，否则就直接忽视</span></span></span><br><span class="line">        <span class="type">int</span> fd = channel-&gt;<span class="built_in">fd</span>();</span><br><span class="line">        ChannelMap::const_iterator it = channels_.<span class="built_in">find</span>(fd);</span><br><span class="line">        <span class="built_in">assert</span>(it != channels_.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">assert</span>(it-&gt;second == channel);<span class="comment">//判断ChannelMap中key和value的对应关系是否准确</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">        channel-&gt;<span class="built_in">set_revents</span>(events_[i].events);<span class="comment">//把已经触发的事件写入channel中</span></span><br><span class="line">        activeChannels-&gt;<span class="built_in">push_back</span>(channel);<span class="comment">//把channel放入要处理的channel列表中</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">EPollPoller::updateChannel</span><span class="params">(Channel *channel)</span><span class="comment">//根据channel的序号在epoll队列中来删除，增加channel或者改变channel</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Poller::<span class="built_in">assertInLoopThread</span>();<span class="comment">//负责epoll_wait的线程和创建eventloop的线程为同一个</span></span><br><span class="line">    LOG_TRACE &lt;&lt; <span class="string">&quot;fd = &quot;</span> &lt;&lt; channel-&gt;<span class="built_in">fd</span>() &lt;&lt; <span class="string">&quot; events = &quot;</span> &lt;&lt; channel-&gt;<span class="built_in">events</span>();</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> index = channel-&gt;<span class="built_in">index</span>();</span><br><span class="line">    <span class="keyword">if</span> (index == kNew || index == kDeleted)<span class="comment">//如果是完全没在或者曾经在epoll队列中的，就添加到epoll队列中</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// a new one, add with EPOLL_CTL_ADD</span></span><br><span class="line">        <span class="type">int</span> fd = channel-&gt;<span class="built_in">fd</span>();</span><br><span class="line">        <span class="keyword">if</span> (index == kNew) &#123;<span class="comment">//完全没在epoll队列中</span></span><br><span class="line">            <span class="built_in">assert</span>(channels_.<span class="built_in">find</span>(fd) == channels_.<span class="built_in">end</span>());<span class="comment">//确保这个channel的文件描述符不在channels_中</span></span><br><span class="line">            channels_[fd] = channel;<span class="comment">//将新添加的fd和channel添加到channels_中</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="comment">// index == kDeleted  曾经在epoll队列中</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">assert</span>(channels_.<span class="built_in">find</span>(fd) != channels_.<span class="built_in">end</span>());<span class="comment">//确保这个channel的文件描述符在channels_中</span></span><br><span class="line">            <span class="built_in">assert</span>(channels_[fd] == channel);<span class="comment">//确保在epoll队列中channel和fd一致</span></span><br><span class="line">        &#125;</span><br><span class="line">        channel-&gt;<span class="built_in">set_index</span>(kAdded);<span class="comment">//修改index为已在队列中</span></span><br><span class="line">        <span class="built_in">update</span>(EPOLL_CTL_ADD, channel);</span><br><span class="line">    &#125; <span class="keyword">else</span><span class="comment">//如果是现在就在epoll队列中的，如果没有关注事件了，就暂时删除，如果有关注事件，就修改</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// update existing one with EPOLL_CTL_MOD/DEL</span></span><br><span class="line">        <span class="type">int</span> fd = channel-&gt;<span class="built_in">fd</span>();</span><br><span class="line">        (<span class="type">void</span>) fd;</span><br><span class="line">        <span class="built_in">assert</span>(channels_.<span class="built_in">find</span>(fd) != channels_.<span class="built_in">end</span>());<span class="comment">//channels_中是否有这个文件描述符</span></span><br><span class="line">        <span class="built_in">assert</span>(channels_[fd] == channel);<span class="comment">//channels_中channel和fd是否一致</span></span><br><span class="line">        <span class="built_in">assert</span>(index == kAdded);<span class="comment">//标志位是否正在队列中</span></span><br><span class="line">        <span class="keyword">if</span> (channel-&gt;<span class="built_in">isNoneEvent</span>()) &#123;</span><br><span class="line">            <span class="built_in">update</span>(EPOLL_CTL_DEL, channel);</span><br><span class="line">            channel-&gt;<span class="built_in">set_index</span>(kDeleted);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">update</span>(EPOLL_CTL_MOD, channel);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">EPollPoller::removeChannel</span><span class="params">(Channel *channel)</span><span class="comment">//完全删除channel</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Poller::<span class="built_in">assertInLoopThread</span>();</span><br><span class="line">    <span class="type">int</span> fd = channel-&gt;<span class="built_in">fd</span>();</span><br><span class="line">    LOG_TRACE &lt;&lt; <span class="string">&quot;fd = &quot;</span> &lt;&lt; fd;</span><br><span class="line">    <span class="built_in">assert</span>(channels_.<span class="built_in">find</span>(fd) != channels_.<span class="built_in">end</span>());<span class="comment">//channels_中是否有这个文件描述符</span></span><br><span class="line">    <span class="built_in">assert</span>(channels_[fd] == channel);<span class="comment">//channels_中channel和fd是否一致</span></span><br><span class="line">    <span class="built_in">assert</span>(channel-&gt;<span class="built_in">isNoneEvent</span>());<span class="comment">//channel中要关注的事件是否为空</span></span><br><span class="line">    <span class="type">int</span> index = channel-&gt;<span class="built_in">index</span>();</span><br><span class="line">    <span class="built_in">assert</span>(index == kAdded || index == kDeleted);<span class="comment">//标志位必须是kAdded或者kDeleted</span></span><br><span class="line">    <span class="type">size_t</span> n = channels_.<span class="built_in">erase</span>(fd);</span><br><span class="line">    (<span class="type">void</span>) n;</span><br><span class="line">    <span class="built_in">assert</span>(n == <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (index == kAdded) &#123;</span><br><span class="line">        <span class="built_in">update</span>(EPOLL_CTL_DEL, channel);<span class="comment">//从epoll队列中删除这个channel</span></span><br><span class="line">    &#125;</span><br><span class="line">    channel-&gt;<span class="built_in">set_index</span>(kNew);<span class="comment">//设置标志位是kNew，相当于完全删除</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">EPollPoller::update</span><span class="params">(<span class="type">int</span> operation, Channel *channel)</span><span class="comment">//主要执行epoll_ctl函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">epoll_event</span> event;</span><br><span class="line">    <span class="built_in">bzero</span>(&amp;event, <span class="keyword">sizeof</span> event);</span><br><span class="line">    event.events = channel-&gt;<span class="built_in">events</span>();</span><br><span class="line">    event.data.ptr = channel;<span class="comment">//设置epoll_event结构体</span></span><br><span class="line">    <span class="type">int</span> fd = channel-&gt;<span class="built_in">fd</span>();</span><br><span class="line">    <span class="keyword">if</span> (::<span class="built_in">epoll_ctl</span>(epollfd_, operation, fd, &amp;event) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (operation == EPOLL_CTL_DEL) &#123;</span><br><span class="line">            LOG_SYSERR &lt;&lt; <span class="string">&quot;epoll_ctl op=&quot;</span> &lt;&lt; operation &lt;&lt; <span class="string">&quot; fd=&quot;</span> &lt;&lt; fd;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            LOG_SYSFATAL &lt;&lt; <span class="string">&quot;epoll_ctl op=&quot;</span> &lt;&lt; operation &lt;&lt; <span class="string">&quot; fd=&quot;</span> &lt;&lt; fd;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="acceptor"><a href="#acceptor" class="headerlink" title="acceptor"></a>acceptor</h3><p><code>Acceptor</code> 用于初始化socket，监听端口，接受连接并调用传入的 <code>callback</code> 创建连接：</p>
<p>Acceptor的数据成员包括Socket、Channel。</p>
<p>Acceptor的socket是listening socket（即server socket）。</p>
<p>Channel用于观察此socket的readable事件，并Acceptor::handleRead()，后者调用accept(2)来接受连接，并回调用户callback。</p>
<p>Acceptor类在上层应用程序中我们不直接使用，而是把它封装作为TcpServer的成员。</p>
<p>Acceptor.h源码分析</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*就是用一个Acceptor类专门用一个channel来创建套接字，绑定，监听等操作*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> MUDUO_NET_ACCEPTOR_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MUDUO_NET_ACCEPTOR_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/function.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/noncopyable.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;muduo/net/Channel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;muduo/net/Socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> muduo &#123;</span><br><span class="line">    <span class="keyword">namespace</span> net &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">class</span> <span class="title class_">EventLoop</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">class</span> <span class="title class_">InetAddress</span>;</span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// Acceptor of incoming TCP connections.</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line">        <span class="keyword">class</span> <span class="title class_">Acceptor</span> : boost::noncopyable &#123;</span><br><span class="line">        <span class="keyword">public</span>:</span><br><span class="line">            <span class="keyword">typedef</span> boost::function&lt;<span class="type">void</span>(<span class="type">int</span> sockfd,<span class="type">const</span> InetAddress &amp;)&gt; NewConnectionCallback;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">Acceptor</span>(EventLoop *loop, <span class="type">const</span> InetAddress &amp;listenAddr);</span><br><span class="line"></span><br><span class="line">            ~<span class="built_in">Acceptor</span>();</span><br><span class="line">            <span class="comment">//newConnectionCallback_是在Acceptor::handleRead里面执行的，也就是在acceptChannel_的读事件发生的时候会被调用</span></span><br><span class="line">            <span class="function"><span class="type">void</span> <span class="title">setNewConnectionCallback</span><span class="params">(<span class="type">const</span> NewConnectionCallback &amp;cb)</span> </span>&#123; newConnectionCallback_ = cb; &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="type">bool</span> <span class="title">listenning</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> listenning_; &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="type">void</span> <span class="title">listen</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span>:</span><br><span class="line">            <span class="function"><span class="type">void</span> <span class="title">handleRead</span><span class="params">()</span></span>;<span class="comment">//可读回调函数，绑定在acceptChannel_的读函数上</span></span><br><span class="line"></span><br><span class="line">            EventLoop *loop_;<span class="comment">//所属的EventLoop对象</span></span><br><span class="line">            Socket acceptSocket_;<span class="comment">//监听套接字</span></span><br><span class="line">            Channel acceptChannel_;<span class="comment">//和监听套接字绑定的通道 acceptChannel_和监听套接字acceptSocket_绑定</span></span><br><span class="line">            NewConnectionCallback newConnectionCallback_;<span class="comment">//一旦有新连接发生，执行的回调函数</span></span><br><span class="line">            <span class="type">bool</span> listenning_;<span class="comment">//acceptChannel所处的eventloop是否处于监听状态</span></span><br><span class="line">            <span class="type">int</span> idleFd_;<span class="comment">//预留一个fd，用来解决文件描述符过多，引起电平触发不断触发的问题，详见handleRead函数的最后</span></span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span>  <span class="comment">// MUDUO_NET_ACCEPTOR_H</span></span></span><br></pre></td></tr></table></figure>

<p>Acceptor.cc源码分析</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;muduo/net/Acceptor.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;muduo/net/EventLoop.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;muduo/net/InetAddress.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;muduo/net/SocketsOps.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/bind.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="comment">//#include &lt;sys/types.h&gt;</span></span><br><span class="line"><span class="comment">//#include &lt;sys/stat.h&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> muduo;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> muduo::net;</span><br><span class="line"></span><br><span class="line">Acceptor::<span class="built_in">Acceptor</span>(EventLoop *loop, <span class="type">const</span> InetAddress &amp;listenAddr)</span><br><span class="line">        : <span class="built_in">loop_</span>(loop),</span><br><span class="line">          <span class="built_in">acceptSocket_</span>(sockets::<span class="built_in">createNonblockingOrDie</span>()),<span class="comment">//设置监听套接字</span></span><br><span class="line">          <span class="built_in">acceptChannel_</span>(loop, acceptSocket_.<span class="built_in">fd</span>()),</span><br><span class="line">          <span class="built_in">listenning_</span>(<span class="literal">false</span>),</span><br><span class="line">          <span class="built_in">idleFd_</span>(::<span class="built_in">open</span>(<span class="string">&quot;/dev/null&quot;</span>, O_RDONLY | O_CLOEXEC))<span class="comment">//这个描述符打开一个linux系统的空文件，所有写入的内容都会被丢弃</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">assert</span>(idleFd_ &gt;= <span class="number">0</span>);</span><br><span class="line">    acceptSocket_.<span class="built_in">setReuseAddr</span>(<span class="literal">true</span>);</span><br><span class="line">    acceptSocket_.<span class="built_in">bindAddress</span>(listenAddr);</span><br><span class="line">    acceptChannel_.<span class="built_in">setReadCallback</span>(boost::<span class="built_in">bind</span>(&amp;Acceptor::handleRead, <span class="keyword">this</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Acceptor::~<span class="built_in">Acceptor</span>() &#123;</span><br><span class="line">    acceptChannel_.<span class="built_in">disableAll</span>();</span><br><span class="line">    acceptChannel_.<span class="built_in">remove</span>();</span><br><span class="line">    ::<span class="built_in">close</span>(idleFd_);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Acceptor::listen</span><span class="params">()</span><span class="comment">//开启监听</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    loop_-&gt;<span class="built_in">assertInLoopThread</span>();</span><br><span class="line">    listenning_ = <span class="literal">true</span>;</span><br><span class="line">    acceptSocket_.<span class="built_in">listen</span>();</span><br><span class="line">    acceptChannel_.<span class="built_in">enableReading</span>();<span class="comment">//将socket套接字挂到eventloop的epoll上，并开启读监听</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Acceptor::handleRead</span><span class="params">()</span><span class="comment">//读的回调函数，一旦socket套接字监听到连接，epoll就会立刻调用回调函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    loop_-&gt;<span class="built_in">assertInLoopThread</span>();</span><br><span class="line">    <span class="function">InetAddress <span class="title">peerAddr</span><span class="params">(<span class="number">0</span>)</span></span>;<span class="comment">//对端的</span></span><br><span class="line">    <span class="comment">//FIXME loop until no more</span></span><br><span class="line">    <span class="type">int</span> connfd = acceptSocket_.<span class="built_in">accept</span>(&amp;peerAddr);</span><br><span class="line">    <span class="keyword">if</span> (connfd &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// string hostport = peerAddr.toIpPort();</span></span><br><span class="line">        <span class="comment">// LOG_TRACE &lt;&lt; &quot;Accepts of &quot; &lt;&lt; hostport;</span></span><br><span class="line">        <span class="keyword">if</span> (newConnectionCallback_) &#123;</span><br><span class="line">            <span class="built_in">newConnectionCallback_</span>(connfd, peerAddr);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            sockets::<span class="built_in">close</span>(connfd);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Read the section named &quot;The special problem of</span></span><br><span class="line">        <span class="comment">// accept()ing when you can&#x27;t&quot; in libev&#x27;s doc.</span></span><br><span class="line">        <span class="comment">// By Marc Lehmann, author of livev.</span></span><br><span class="line">        <span class="comment">//在监听套接字可读事件触发时，我们会调用accept接受连接。如果此时注册过回调函数，就执行它。如果没有就直接关闭！</span></span><br><span class="line">        <span class="comment">//另一方面，如果已用文件描述符过多，accept会返回-1，我们构造函数中注册的idleFd_就派上用场了。</span></span><br><span class="line">        <span class="comment">// 当前文件描述符过多，无法接收新的连接。但是由于我们采用LT模式，如果无法接收，可读事件会一直触发。</span></span><br><span class="line">        <span class="comment">// 那么在这个地方的处理机制就是，关掉之前创建的idleFd_，然后去accept让这个事件不会一直触发，</span></span><br><span class="line">        <span class="comment">// 然后再关掉该文件描述符，重新将它设置为空文件描述符。</span></span><br><span class="line">        <span class="comment">//这种机制可以让网络库在处理连接过多，文件描述符不够用时，不至于因为LT模式一直触发而产生坏的影响。</span></span><br><span class="line">        <span class="keyword">if</span> (errno == EMFILE)<span class="comment">//当accept函数出错时，是因为文件描述符太多了</span></span><br><span class="line">        &#123;</span><br><span class="line">            ::<span class="built_in">close</span>(idleFd_);<span class="comment">//就关闭一个空闲描述符，相当于现在就有一个空的文件描述符位置了</span></span><br><span class="line">            idleFd_ = ::<span class="built_in">accept</span>(acceptSocket_.<span class="built_in">fd</span>(), <span class="literal">NULL</span>, <span class="literal">NULL</span>);<span class="comment">//然后把刚才没有接受的描述符接受进来</span></span><br><span class="line">            ::<span class="built_in">close</span>(idleFd_);<span class="comment">//把这个描述符给关闭，相当于忽略这个请求连接了</span></span><br><span class="line">            idleFd_ = ::<span class="built_in">open</span>(<span class="string">&quot;/dev/null&quot;</span>, O_RDONLY | O_CLOEXEC);<span class="comment">//重新开启这个空闲描述符</span></span><br><span class="line">        &#125;<span class="comment">//之所以这样，是因为poll使用的是水平触发，如果没有这个if判断，就会一直触发</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="tcp-server和tcp-connection"><a href="#tcp-server和tcp-connection" class="headerlink" title="tcp server和tcp connection"></a>tcp server和tcp connection</h3><p><strong>TcpServer</strong></p>
<p>TcpServer相当于主线程reactor， 此时主线程循环只负责TCP连接的建立，及任务的分配，需要让哪个线程干活， 就把timer或连接分配给那个线程即可；对实时性有要求的connection可以单独用一个线程； 数据量大的connection可以独占一个线程；并把数据处理任务分摊到另几个计算线程中（用线程池）；其他次要的辅助性connections共享一个线程。</p>
<p>分配连接主要通过EventLoopThreadPool 线程池实现，新建TcpConnection时从event loop pool里分配一个loop给TcpConnection。 TcpServer自己的EventLoop只用来接受新连接， 而新连接会用其他EventLoop来执行IO。</p>
<p><strong>EventLoopThreadPool</strong></p>
<p>TcpServer每次新建一条TcpConnection就会通过EventLoopThreadPool::getNextLoop()方法来取一个EventLoop， 目前的getNextLoop()只是循环的从池中取一条loop，如果提供给每条TcpConncetion的是均等的服务，那么这样就能很均匀的分配系统的资源了。</p>
<p> TcpServer的工作方式取决于EventLoopThreadPool中线程的创建数量。</p>
<p>0 意味着所有的I&#x2F;O 都在TcpServer的主事件循环中，不会创建新的线程。</p>
<p>1 意味着所有的 I&#x2F;O 在另一个线程中 ，TcpServer的主线程只负责建立连接。</p>
<p>N 意味着新的连接会被循环的分配到N条线程中工作。</p>
<p>TcpServer.h</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 这个类相当于把TcpConnection以及Accept类整合起来，完全能够实现Tcp通信，也就是socket函数都实现了</span></span><br><span class="line"><span class="comment"> * 一个TcpServer类中，有Acceptor，EventLoopThreadPool各一个，以及多个TcpConnection类的指针，</span></span><br><span class="line"><span class="comment"> * 在TcpServer类的启动函数中，先开启EventLoopThreadPool线程池，然后将Acceptor监听函数放入eventloop中去执行</span></span><br><span class="line"><span class="comment"> * 在TcpServer类的构造函数中，就已经把一个成功连接的回调函数绑定在Acceptor类的连接回调函数中，如果Acceptor监听</span></span><br><span class="line"><span class="comment"> * 到有连接进来，先调监听socket描述符的回调函数，把这个连接accept进来，然后再调用newConnectionCallback_函数</span></span><br><span class="line"><span class="comment"> * 来处理连接，每个连接都有一个对应的TcpConnection类来作为缓冲区</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> MUDUO_NET_TCPSERVER_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MUDUO_NET_TCPSERVER_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;muduo/base/Types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;muduo/net/TcpConnection.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/noncopyable.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/scoped_ptr.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> muduo &#123;</span><br><span class="line">    <span class="keyword">namespace</span> net &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">class</span> <span class="title class_">Acceptor</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">class</span> <span class="title class_">EventLoop</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">class</span> <span class="title class_">EventLoopThreadPool</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// TCP server, supports single-threaded and thread-pool models.</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// This is an interface class, so don&#x27;t expose too much details.</span></span><br><span class="line">        <span class="keyword">class</span> <span class="title class_">TcpServer</span> : boost::noncopyable &#123;</span><br><span class="line">        <span class="keyword">public</span>:</span><br><span class="line">            <span class="keyword">typedef</span> boost::function&lt;<span class="type">void</span>(EventLoop *)&gt; ThreadInitCallback;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//TcpServer(EventLoop* loop, const InetAddress&amp; listenAddr);</span></span><br><span class="line">            <span class="built_in">TcpServer</span>(EventLoop *loop,</span><br><span class="line">                      <span class="type">const</span> InetAddress &amp;listenAddr,</span><br><span class="line">                      <span class="type">const</span> string &amp;nameArg);</span><br><span class="line"></span><br><span class="line">            ~<span class="built_in">TcpServer</span>();  <span class="comment">// force out-line dtor, for scoped_ptr members.</span></span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="type">const</span> string &amp;<span class="title">hostport</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> hostport_; &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="type">const</span> string &amp;<span class="title">name</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> name_; &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/// Set the number of threads for handling input.</span></span><br><span class="line">            <span class="comment">///</span></span><br><span class="line">            <span class="comment">/// Always accepts new connection in loop&#x27;s thread.</span></span><br><span class="line">            <span class="comment">/// Must be called before @c start</span></span><br><span class="line">            <span class="comment">/// @param numThreads</span></span><br><span class="line">            <span class="comment">/// - 0 means all I/O in loop&#x27;s thread, no thread will created.</span></span><br><span class="line">            <span class="comment">///   this is the default value.</span></span><br><span class="line">            <span class="comment">/// - 1 means all I/O in another thread.</span></span><br><span class="line">            <span class="comment">/// - N means a thread pool with N threads, new connections</span></span><br><span class="line">            <span class="comment">///   are assigned on a round-robin basis.</span></span><br><span class="line">            <span class="function"><span class="type">void</span> <span class="title">setThreadNum</span><span class="params">(<span class="type">int</span> numThreads)</span></span>;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="type">void</span> <span class="title">setThreadInitCallback</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">                    <span class="type">const</span> ThreadInitCallback &amp;cb)</span> </span>&#123; threadInitCallback_ = cb; &#125;<span class="comment">//这个函数会作为EventLoopThreadPool::start的入口参数</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">/// Starts the server if it&#x27;s not listenning.</span></span><br><span class="line">            <span class="comment">///</span></span><br><span class="line">            <span class="comment">/// It&#x27;s harmless to call it multiple times.</span></span><br><span class="line">            <span class="comment">/// Thread safe.</span></span><br><span class="line">            <span class="function"><span class="type">void</span> <span class="title">start</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/// Set connection callback.</span></span><br><span class="line">            <span class="comment">/// Not thread safe.</span></span><br><span class="line">            <span class="comment">// 设置连接到来或者连接关闭回调函数,这个函数指针会赋值给TcpConnection::connectionCallback_函数，就是在连接建立之后，和连接断开之前会调用</span></span><br><span class="line">            <span class="function"><span class="type">void</span> <span class="title">setConnectionCallback</span><span class="params">(<span class="type">const</span> ConnectionCallback &amp;cb)</span> </span>&#123; connectionCallback_ = cb; &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/// Set message callback.</span></span><br><span class="line">            <span class="comment">/// Not thread safe.</span></span><br><span class="line">            <span class="comment">//  设置消息到来回调函数，这个函数指针在TcpConnection::handleread函数中调用，也就是TcpConnection的Channel的读函数的一部分</span></span><br><span class="line">            <span class="function"><span class="type">void</span> <span class="title">setMessageCallback</span><span class="params">(<span class="type">const</span> MessageCallback &amp;cb)</span> </span>&#123; messageCallback_ = cb; &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/// Set write complete callback.</span></span><br><span class="line">            <span class="comment">/// Not thread safe.</span></span><br><span class="line">            <span class="comment">/// 在发送完消息以后调用，这个函数指针会赋值给TcpConnection::writeCompleteCallback_函数</span></span><br><span class="line">            <span class="function"><span class="type">void</span> <span class="title">setWriteCompleteCallback</span><span class="params">(<span class="type">const</span> WriteCompleteCallback &amp;cb)</span> </span>&#123; writeCompleteCallback_ = cb; &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span>:</span><br><span class="line">            <span class="comment">/// Not thread safe, but in loop</span></span><br><span class="line">            <span class="function"><span class="type">void</span> <span class="title">newConnection</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> InetAddress &amp;peerAddr)</span></span>;</span><br><span class="line">            <span class="comment">//这个函数会赋值给Acceptor::newConnectionCallback_，在新连接建立以后调用</span></span><br><span class="line">            <span class="comment">/// Thread safe.</span></span><br><span class="line">            <span class="comment">/// 会赋值给TcpConnection::closeCallback_函数，也就是当连接描述符关闭以后调用这个</span></span><br><span class="line">            <span class="function"><span class="type">void</span> <span class="title">removeConnection</span><span class="params">(<span class="type">const</span> TcpConnectionPtr &amp;conn)</span></span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/// Not thread safe, but in loop，在上面这个函数removeConnection中调用</span></span><br><span class="line">            <span class="function"><span class="type">void</span> <span class="title">removeConnectionInLoop</span><span class="params">(<span class="type">const</span> TcpConnectionPtr &amp;conn)</span></span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">typedef</span> std::map &lt;string, TcpConnectionPtr&gt; ConnectionMap;</span><br><span class="line"></span><br><span class="line">            EventLoop *loop_;  <span class="comment">// the acceptor loop</span></span><br><span class="line">            <span class="type">const</span> string hostport_;        <span class="comment">// 服务的ip:端口</span></span><br><span class="line">            <span class="type">const</span> string name_;            <span class="comment">// 服务名</span></span><br><span class="line">            boost::scoped_ptr &lt;Acceptor&gt; acceptor_; <span class="comment">// avoid revealing Acceptor</span></span><br><span class="line">            boost::scoped_ptr &lt;EventLoopThreadPool&gt; threadPool_;</span><br><span class="line">            ConnectionCallback connectionCallback_;</span><br><span class="line">            MessageCallback messageCallback_;</span><br><span class="line">            WriteCompleteCallback writeCompleteCallback_;        <span class="comment">// 数据发送完毕，会回调此函数</span></span><br><span class="line">            ThreadInitCallback threadInitCallback_;    <span class="comment">// IO线程池中的线程在进入事件循环前，会回调用此函数</span></span><br><span class="line">            <span class="type">bool</span> started_;</span><br><span class="line">            <span class="comment">// always in loop thread</span></span><br><span class="line">            <span class="type">int</span> nextConnId_;                <span class="comment">// 下一个连接ID,每次增加一个就加1</span></span><br><span class="line">            ConnectionMap connections_;    <span class="comment">// 连接列表</span></span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span>  <span class="comment">// MUDUO_NET_TCPSERVER_H</span></span></span><br></pre></td></tr></table></figure>

<p>TcpServer.cc</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;muduo/net/TcpServer.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;muduo/base/Logging.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;muduo/net/Acceptor.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;muduo/net/EventLoop.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;muduo/net/EventLoopThreadPool.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;muduo/net/SocketsOps.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/bind.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span>  <span class="comment">// snprintf</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> muduo;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> muduo::net;</span><br><span class="line"></span><br><span class="line">TcpServer::<span class="built_in">TcpServer</span>(EventLoop *loop, <span class="type">const</span> InetAddress &amp;listenAddr,</span><br><span class="line">                     <span class="type">const</span> string &amp;nameArg)</span><br><span class="line">        : <span class="built_in">loop_</span>(<span class="built_in">CHECK_NOTNULL</span>(loop)),</span><br><span class="line">          <span class="built_in">hostport_</span>(listenAddr.<span class="built_in">toIpPort</span>()),</span><br><span class="line">          <span class="built_in">name_</span>(nameArg),</span><br><span class="line">          <span class="built_in">acceptor_</span>(<span class="keyword">new</span> <span class="built_in">Acceptor</span>(loop, listenAddr)),</span><br><span class="line">          <span class="built_in">threadPool_</span>(<span class="keyword">new</span> <span class="built_in">EventLoopThreadPool</span>(loop)),</span><br><span class="line">          <span class="built_in">connectionCallback_</span>(defaultConnectionCallback),</span><br><span class="line">          <span class="built_in">messageCallback_</span>(defaultMessageCallback),</span><br><span class="line">          <span class="built_in">started_</span>(<span class="literal">false</span>),</span><br><span class="line">          <span class="built_in">nextConnId_</span>(<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">// Acceptor::handleRead函数中会回调用TcpServer::newConnection</span></span><br><span class="line">    <span class="comment">// _1对应的是socket文件描述符，_2对应的是对等方的地址(InetAddress)</span></span><br><span class="line">    acceptor_-&gt;<span class="built_in">setNewConnectionCallback</span>(</span><br><span class="line">            boost::<span class="built_in">bind</span>(&amp;TcpServer::newConnection, <span class="keyword">this</span>, _1, _2));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">TcpServer::~<span class="built_in">TcpServer</span>() &#123;</span><br><span class="line">    loop_-&gt;<span class="built_in">assertInLoopThread</span>();</span><br><span class="line">    LOG_TRACE &lt;&lt; <span class="string">&quot;TcpServer::~TcpServer [&quot;</span> &lt;&lt; name_ &lt;&lt; <span class="string">&quot;] destructing&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (ConnectionMap::iterator <span class="built_in">it</span>(connections_.<span class="built_in">begin</span>());</span><br><span class="line">         it != connections_.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">        TcpConnectionPtr conn = it-&gt;second;</span><br><span class="line">        it-&gt;second.<span class="built_in">reset</span>();        <span class="comment">// 释放当前所控制的对象，引用计数减一</span></span><br><span class="line">        conn-&gt;<span class="built_in">getLoop</span>()-&gt;<span class="built_in">runInLoop</span>(</span><br><span class="line">                boost::<span class="built_in">bind</span>(&amp;TcpConnection::connectDestroyed, conn));</span><br><span class="line">        conn.<span class="built_in">reset</span>();            <span class="comment">// 释放当前所控制的对象，引用计数减一</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TcpServer::setThreadNum</span><span class="params">(<span class="type">int</span> numThreads)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(<span class="number">0</span> &lt;= numThreads);</span><br><span class="line">    threadPool_-&gt;<span class="built_in">setThreadNum</span>(numThreads);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 该函数多次调用是无害的</span></span><br><span class="line"><span class="comment">// 该函数可以跨线程调用</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TcpServer::start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!started_) &#123;</span><br><span class="line">        started_ = <span class="literal">true</span>;</span><br><span class="line">        threadPool_-&gt;<span class="built_in">start</span>(threadInitCallback_);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!acceptor_-&gt;<span class="built_in">listenning</span>()) &#123;</span><br><span class="line">        <span class="comment">// get_pointer返回原生指针</span></span><br><span class="line">        loop_-&gt;<span class="built_in">runInLoop</span>(</span><br><span class="line">                boost::<span class="built_in">bind</span>(&amp;Acceptor::listen, <span class="built_in">get_pointer</span>(acceptor_)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TcpServer::newConnection</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> InetAddress &amp;peerAddr)</span><span class="comment">//建立新连接以后的回调函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    loop_-&gt;<span class="built_in">assertInLoopThread</span>();</span><br><span class="line">    <span class="comment">// 按照轮叫的方式选择一个EventLoop</span></span><br><span class="line">    EventLoop *ioLoop = threadPool_-&gt;<span class="built_in">getNextLoop</span>();</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">32</span>];</span><br><span class="line">    <span class="built_in">snprintf</span>(buf, <span class="keyword">sizeof</span> buf, <span class="string">&quot;:%s#%d&quot;</span>, hostport_.<span class="built_in">c_str</span>(), nextConnId_);<span class="comment">//buf的内容是 ip:端口#nextConnId_</span></span><br><span class="line">    ++nextConnId_;</span><br><span class="line">    string connName = name_ + buf;</span><br><span class="line"></span><br><span class="line">    LOG_INFO &lt;&lt; <span class="string">&quot;TcpServer::newConnection [&quot;</span> &lt;&lt; name_</span><br><span class="line">             &lt;&lt; <span class="string">&quot;] - new connection [&quot;</span> &lt;&lt; connName</span><br><span class="line">             &lt;&lt; <span class="string">&quot;] from &quot;</span> &lt;&lt; peerAddr.<span class="built_in">toIpPort</span>();</span><br><span class="line">    <span class="function">InetAddress <span class="title">localAddr</span><span class="params">(sockets::getLocalAddr(sockfd))</span></span>;</span><br><span class="line">    <span class="comment">// FIXME poll with zero timeout to double confirm the new connection</span></span><br><span class="line">    <span class="comment">// FIXME use make_shared if necessary</span></span><br><span class="line">    <span class="comment">/*TcpConnectionPtr conn(new TcpConnection(loop_,</span></span><br><span class="line"><span class="comment">                                            connName,</span></span><br><span class="line"><span class="comment">                                            sockfd,</span></span><br><span class="line"><span class="comment">                                            localAddr,</span></span><br><span class="line"><span class="comment">                                            peerAddr));*/</span></span><br><span class="line"></span><br><span class="line">    <span class="function">TcpConnectionPtr <span class="title">conn</span><span class="params">(<span class="keyword">new</span> TcpConnection(ioLoop,</span></span></span><br><span class="line"><span class="params"><span class="function">                                            connName,</span></span></span><br><span class="line"><span class="params"><span class="function">                                            sockfd,</span></span></span><br><span class="line"><span class="params"><span class="function">                                            localAddr,</span></span></span><br><span class="line"><span class="params"><span class="function">                                            peerAddr))</span></span>;</span><br><span class="line"></span><br><span class="line">    LOG_TRACE &lt;&lt; <span class="string">&quot;[1] usecount=&quot;</span> &lt;&lt; conn.<span class="built_in">use_count</span>();</span><br><span class="line">    connections_[connName] = conn;<span class="comment">//将连接名和TCPConnection的指针拷贝进连接列表中，这样就有两个shared_ptr指针指向conn了，</span></span><br><span class="line">    <span class="comment">//如果没有这一句程序，这个conn在newConnection函数执行结束以后就会析构掉，所以真正要删除时，也要把这个列表中的对应元素也删除了。</span></span><br><span class="line">    LOG_TRACE &lt;&lt; <span class="string">&quot;[2] usecount=&quot;</span> &lt;&lt; conn.<span class="built_in">use_count</span>();</span><br><span class="line">    <span class="comment">//设置回调函数</span></span><br><span class="line">    conn-&gt;<span class="built_in">setConnectionCallback</span>(connectionCallback_);</span><br><span class="line">    conn-&gt;<span class="built_in">setMessageCallback</span>(messageCallback_);</span><br><span class="line">    conn-&gt;<span class="built_in">setWriteCompleteCallback</span>(writeCompleteCallback_);<span class="comment">//无论是否非空，都可以先设置，在使用之前会有判断</span></span><br><span class="line"></span><br><span class="line">    conn-&gt;<span class="built_in">setCloseCallback</span>(</span><br><span class="line">            boost::<span class="built_in">bind</span>(&amp;TcpServer::removeConnection, <span class="keyword">this</span>, _1));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// conn-&gt;connectEstablished();</span></span><br><span class="line">    ioLoop-&gt;<span class="built_in">runInLoop</span>(boost::<span class="built_in">bind</span>(&amp;TcpConnection::connectEstablished, conn));</span><br><span class="line">    <span class="comment">//bind在绑定类成员函数时，后面跟的参数一定比输入参数多一个，就是一个类指针，表明这个函数属于那个类变量的，</span></span><br><span class="line">    <span class="comment">//一般都使用this，而这里是用的TcpConnectionPtr</span></span><br><span class="line">    LOG_TRACE &lt;&lt; <span class="string">&quot;[5] usecount=&quot;</span> &lt;&lt; conn.<span class="built_in">use_count</span>();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TcpServer::removeConnection</span><span class="params">(<span class="type">const</span> TcpConnectionPtr &amp;conn)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">  loop_-&gt;assertInLoopThread();</span></span><br><span class="line"><span class="comment">  LOG_INFO &lt;&lt; &quot;TcpServer::removeConnectionInLoop [&quot; &lt;&lt; name_</span></span><br><span class="line"><span class="comment">           &lt;&lt; &quot;] - connection &quot; &lt;&lt; conn-&gt;name();</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  LOG_TRACE &lt;&lt; &quot;[8] usecount=&quot; &lt;&lt; conn.use_count();</span></span><br><span class="line"><span class="comment">  size_t n = connections_.erase(conn-&gt;name());</span></span><br><span class="line"><span class="comment">  LOG_TRACE &lt;&lt; &quot;[9] usecount=&quot; &lt;&lt; conn.use_count();</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  (void)n;</span></span><br><span class="line"><span class="comment">  assert(n == 1);</span></span><br><span class="line"><span class="comment">  </span></span><br><span class="line"><span class="comment">  loop_-&gt;queueInLoop(</span></span><br><span class="line"><span class="comment">      boost::bind(&amp;TcpConnection::connectDestroyed, conn));</span></span><br><span class="line"><span class="comment">  LOG_TRACE &lt;&lt; &quot;[10] usecount=&quot; &lt;&lt; conn.use_count();</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"></span><br><span class="line">    loop_-&gt;<span class="built_in">runInLoop</span>(boost::<span class="built_in">bind</span>(&amp;TcpServer::removeConnectionInLoop, <span class="keyword">this</span>, conn));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TcpServer::removeConnectionInLoop</span><span class="params">(<span class="type">const</span> TcpConnectionPtr &amp;conn)</span><span class="comment">//就是把TcpConnection从Eventloop中移除</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    loop_-&gt;<span class="built_in">assertInLoopThread</span>();</span><br><span class="line">    LOG_INFO &lt;&lt; <span class="string">&quot;TcpServer::removeConnectionInLoop [&quot;</span> &lt;&lt; name_</span><br><span class="line">             &lt;&lt; <span class="string">&quot;] - connection &quot;</span> &lt;&lt; conn-&gt;<span class="built_in">name</span>();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    LOG_TRACE &lt;&lt; <span class="string">&quot;[8] usecount=&quot;</span> &lt;&lt; conn.<span class="built_in">use_count</span>();</span><br><span class="line">    <span class="type">size_t</span> n = connections_.<span class="built_in">erase</span>(conn-&gt;<span class="built_in">name</span>());</span><br><span class="line">    LOG_TRACE &lt;&lt; <span class="string">&quot;[9] usecount=&quot;</span> &lt;&lt; conn.<span class="built_in">use_count</span>();</span><br><span class="line"></span><br><span class="line">    (<span class="type">void</span>) n;</span><br><span class="line">    <span class="built_in">assert</span>(n == <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    EventLoop *ioLoop = conn-&gt;<span class="built_in">getLoop</span>();</span><br><span class="line">    ioLoop-&gt;<span class="built_in">queueInLoop</span>(</span><br><span class="line">            boost::<span class="built_in">bind</span>(&amp;TcpConnection::connectDestroyed, conn));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//loop_-&gt;queueInLoop(</span></span><br><span class="line">    <span class="comment">//    boost::bind(&amp;TcpConnection::connectDestroyed, conn));</span></span><br><span class="line">    LOG_TRACE &lt;&lt; <span class="string">&quot;[10] usecount=&quot;</span> &lt;&lt; conn.<span class="built_in">use_count</span>();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>TcpConnection</strong></p>
<p>TcpConnection类主要负责封装一次TCP连接，向Channel类注册回调函数（可读、可写、可关闭、错误处理），将来当Channel类上的事件发生时，调用相应的回调函数进行数据收发或者错误处理。</p>
<p>TcpConnection是使用shared_ptr来管理的类，因为它的生命周期模糊。TcpConnection表示已经建立或正在建立的连接，建立连接后，用户只需要在上层类如TcpServer中设置连接到来和消息到来的处理函数，继而回调TcpConnection中的 setConnectionCallback和setMessageCallback函数，实现对事件的处理。用户需要关心的事件是有限的，其他都由网络库负责。</p>
<p>TcpConnection中封装了InputBuffer和OutputBuffer，用来表示应用层的缓冲区。在发送数据时，如果不能一次将Buffer中的数据发送完毕，它还会继续关注Channel中的可写事件，当sockfd可写时，会再次发送。</p>
<p>前面提到TcpConnection的生存期模糊，主要是因为我们不能在TcpServer中直接erase掉TcpConnection对象，因为此时有可能Channel中的handleEvent还在执行，如果析构TcpConnection对象，那么他的成员channel_也会被析构，会导致core dump。也就是说我们需要TcpConnection 对象生存期要长于handleEvent() 函数，直到执行完connectDestroyed() 后才会析构。</p>
<p><strong>断开连接：</strong></p>
<p>TcpConnection的断开是采用被动方式，即对方先关闭连接，本地read(2)返回0后，调用顺序如下：</p>
<p>handleClose()-&gt;TcpServer::removeConnection-&gt;TcpConnection::connectDestroyed()。</p>
<p>连接关闭时序图：</p>
<p>​    <img src="https://raw.githubusercontent.com/hufei96/Image/main/muduo_tcp_close.png" alt="img"></p>
<p>当连接到来，创建一个TcpConnection对象，立刻用shared_ptr来管理，引用计数为1，在Channel中维护一个weak_ptr（tie_），将这个shared_ptr对象赋值给_tie，引用计数仍然为1。当连接关闭时，在handleEvent中，将tie_提升，得到一个shard_ptr对象，引用计数就变成了2。当shared_ptr的计数不为0时，TcpConnection不会被销毁。</p>
<p>TcpConnection.h</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*这个类主要用来和buffer类一起作为非阻塞IO的一个读取桥梁，其中主要封装的函数是从文件描述符中读取传输的数据到</span></span><br><span class="line"><span class="comment"> *接受缓冲区中，或者把规定数据，或者触发写事件的输出缓冲区的数据写入对应的文件描述符中。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> MUDUO_NET_TCPCONNECTION_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MUDUO_NET_TCPCONNECTION_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;muduo/base/Mutex.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;muduo/base/StringPiece.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;muduo/base/Types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;muduo/net/Callbacks.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;muduo/net/Buffer.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;muduo/net/InetAddress.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/any.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/enable_shared_from_this.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/noncopyable.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/scoped_ptr.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/shared_ptr.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> muduo &#123;</span><br><span class="line">    <span class="keyword">namespace</span> net &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">class</span> <span class="title class_">Channel</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">class</span> <span class="title class_">EventLoop</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">class</span> <span class="title class_">Socket</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// TCP connection, for both client and server usage.</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// This is an interface class, so don&#x27;t expose too much details.</span></span><br><span class="line">        <span class="keyword">class</span> <span class="title class_">TcpConnection</span> : boost::noncopyable,<span class="keyword">public</span> boost::enable_shared_from_this&lt;TcpConnection&gt; &#123;</span><br><span class="line">        <span class="keyword">public</span>:</span><br><span class="line">            <span class="comment">/// Constructs a TcpConnection with a connected sockfd</span></span><br><span class="line">            <span class="comment">///</span></span><br><span class="line">            <span class="comment">/// User should not create this object.</span></span><br><span class="line">            <span class="built_in">TcpConnection</span>(EventLoop *loop,<span class="type">const</span> string &amp;name,<span class="type">int</span> sockfd,</span><br><span class="line">                          <span class="type">const</span> InetAddress &amp;localAddr,</span><br><span class="line">                          <span class="type">const</span> InetAddress &amp;peerAddr);</span><br><span class="line"></span><br><span class="line">            ~<span class="built_in">TcpConnection</span>();</span><br><span class="line"></span><br><span class="line">            <span class="function">EventLoop *<span class="title">getLoop</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> loop_; &#125;<span class="comment">//获取当前TcpConnection所在的Eventloop</span></span><br><span class="line">            <span class="function"><span class="type">const</span> string &amp;<span class="title">name</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> name_; &#125;<span class="comment">//</span></span><br><span class="line">            <span class="function"><span class="type">const</span> InetAddress &amp;<span class="title">localAddress</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> localAddr_; &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="type">const</span> InetAddress &amp;<span class="title">peerAddress</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> peerAddr_; &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="type">bool</span> <span class="title">connected</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> state_ == kConnected; &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// void send(string&amp;&amp; message); // C++11</span></span><br><span class="line">            <span class="function"><span class="type">void</span> <span class="title">send</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *message, <span class="type">size_t</span> len)</span></span>;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="type">void</span> <span class="title">send</span><span class="params">(<span class="type">const</span> StringPiece &amp;message)</span></span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// void send(Buffer&amp;&amp; message); // C++11</span></span><br><span class="line">            <span class="function"><span class="type">void</span> <span class="title">send</span><span class="params">(Buffer *message)</span></span>;  <span class="comment">// this one will swap data</span></span><br><span class="line">            <span class="function"><span class="type">void</span> <span class="title">shutdown</span><span class="params">()</span></span>; <span class="comment">// NOT thread safe, no simultaneous calling</span></span><br><span class="line">            <span class="function"><span class="type">void</span> <span class="title">setTcpNoDelay</span><span class="params">(<span class="type">bool</span> on)</span></span>;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="type">void</span> <span class="title">setContext</span><span class="params">(<span class="type">const</span> boost::any &amp;context)</span> </span>&#123; context_ = context; &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="type">const</span> boost::any &amp;<span class="title">getContext</span><span class="params">()</span> <span class="type">const</span><span class="comment">//得到常数值的context_</span></span></span><br><span class="line"><span class="function">            </span>&#123; <span class="keyword">return</span> context_; &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function">boost::any *<span class="title">getMutableContext</span><span class="params">()</span><span class="comment">//得到可以改变的context_</span></span></span><br><span class="line"><span class="function">            </span>&#123; <span class="keyword">return</span> &amp;context_; &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="type">void</span> <span class="title">setConnectionCallback</span><span class="params">(<span class="type">const</span> ConnectionCallback &amp;cb)</span> </span>&#123; connectionCallback_ = cb; &#125;</span><br><span class="line">            <span class="comment">//在handleClose，connectEstablished，connectDestroyed中调用，个人理解这个连接回调函数主要起到</span></span><br><span class="line">            <span class="comment">//显示作用，就是在和连接描述符建立连接或者关闭连接前，显示连接状态的，表明还在连接中</span></span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="type">void</span> <span class="title">setMessageCallback</span><span class="params">(<span class="type">const</span> MessageCallback &amp;cb)</span> </span>&#123; messageCallback_ = cb; &#125;</span><br><span class="line">            <span class="comment">//在handleRead函数当中调用了，也可以理解为channel_写函数的一部分</span></span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="type">void</span> <span class="title">setWriteCompleteCallback</span><span class="params">(<span class="type">const</span> WriteCompleteCallback &amp;cb)</span> </span>&#123; writeCompleteCallback_ = cb; &#125;</span><br><span class="line">            <span class="comment">//在handleWrite和sendInLoop写函数中，写完调用的</span></span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="type">void</span> <span class="title">setHighWaterMarkCallback</span><span class="params">(<span class="type">const</span> HighWaterMarkCallback &amp;cb, <span class="type">size_t</span> highWaterMark)</span> </span>&#123;</span><br><span class="line">                highWaterMarkCallback_ = cb;</span><br><span class="line">                highWaterMark_ = highWaterMark;</span><br><span class="line">            &#125;<span class="comment">//都在sendInLoop中调用了</span></span><br><span class="line"></span><br><span class="line">            <span class="function">Buffer *<span class="title">inputBuffer</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> &amp;inputBuffer_; &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/// Internal use only.</span></span><br><span class="line">            <span class="function"><span class="type">void</span> <span class="title">setCloseCallback</span><span class="params">(<span class="type">const</span> CloseCallback &amp;cb)</span> </span>&#123; closeCallback_ = cb; &#125;<span class="comment">//在handleClose函数中调用</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// called when TcpServer accepts a new connection</span></span><br><span class="line">            <span class="function"><span class="type">void</span> <span class="title">connectEstablished</span><span class="params">()</span></span>;   <span class="comment">// should be called only once</span></span><br><span class="line">            <span class="comment">// called when TcpServer has removed me from its map</span></span><br><span class="line">            <span class="function"><span class="type">void</span> <span class="title">connectDestroyed</span><span class="params">()</span></span>;  <span class="comment">// should be called only once</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span>:</span><br><span class="line">            <span class="keyword">enum</span> <span class="title class_">StateE</span> &#123;</span><br><span class="line">                kDisconnected, kConnecting, kConnected, kDisconnecting</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="type">void</span> <span class="title">handleRead</span><span class="params">(Timestamp receiveTime)</span></span>;<span class="comment">//绑定channel_的读函数</span></span><br><span class="line">            <span class="function"><span class="type">void</span> <span class="title">handleWrite</span><span class="params">()</span></span>;<span class="comment">//绑定channel_的写函数</span></span><br><span class="line">            <span class="function"><span class="type">void</span> <span class="title">handleClose</span><span class="params">()</span></span>;<span class="comment">//绑定channel_的关闭函数，同时也在handleRead中调用</span></span><br><span class="line">            <span class="function"><span class="type">void</span> <span class="title">handleError</span><span class="params">()</span></span>;<span class="comment">////绑定channel_的错误函数</span></span><br><span class="line">            <span class="function"><span class="type">void</span> <span class="title">sendInLoop</span><span class="params">(<span class="type">const</span> StringPiece &amp;message)</span></span>;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="type">void</span> <span class="title">sendInLoop</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *message, <span class="type">size_t</span> len)</span></span>;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="type">void</span> <span class="title">shutdownInLoop</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="type">void</span> <span class="title">setState</span><span class="params">(StateE s)</span> </span>&#123; state_ = s; &#125;<span class="comment">//设置状态位</span></span><br><span class="line"></span><br><span class="line">            EventLoop *loop_;            <span class="comment">// 所属EventLoop</span></span><br><span class="line">            string name_;                <span class="comment">// 连接名</span></span><br><span class="line">            StateE state_;  <span class="comment">// <span class="doctag">FIXME:</span> use atomic variable</span></span><br><span class="line">            <span class="comment">// we don&#x27;t expose those classes to client.</span></span><br><span class="line">            <span class="comment">//连接状态</span></span><br><span class="line">            boost::scoped_ptr &lt;Socket&gt; socket_;</span><br><span class="line">            boost::scoped_ptr &lt;Channel&gt; channel_;</span><br><span class="line">            <span class="comment">//channel_在TCPServer中绑定了连接套接字，就是能够实现通信的那个connfd套接字，这个套接字是从Socket::accept函数得到的</span></span><br><span class="line">            <span class="comment">//在Tcpclient绑定的是创建的套接字，因为客户端只需要一个套接字就可以了，这个套接字是从socket()函数中得到的</span></span><br><span class="line">            InetAddress localAddr_;<span class="comment">//当前服务端的地址</span></span><br><span class="line">            InetAddress peerAddr_;<span class="comment">//当前建立连接的客户端地址</span></span><br><span class="line">            ConnectionCallback connectionCallback_;</span><br><span class="line">            MessageCallback messageCallback_;</span><br><span class="line">            WriteCompleteCallback writeCompleteCallback_;        <span class="comment">// 数据发送完毕回调函数，即所有的用户数据都已拷贝到内核缓冲区时回调该函数</span></span><br><span class="line">            <span class="comment">// outputBuffer_被清空也会回调该函数，可以理解为低水位标回调函数</span></span><br><span class="line">            HighWaterMarkCallback highWaterMarkCallback_;        <span class="comment">// 高水位标回调函数</span></span><br><span class="line">            CloseCallback closeCallback_;</span><br><span class="line">            <span class="type">size_t</span> highWaterMark_;        <span class="comment">// 高水位标</span></span><br><span class="line">            Buffer inputBuffer_;            <span class="comment">// 应用层接收缓冲区</span></span><br><span class="line">            Buffer outputBuffer_;            <span class="comment">// 应用层发送缓冲区</span></span><br><span class="line">            boost::any context_;            <span class="comment">// 绑定一个未知类型的上下文对象，一般用来放HttpContext类的</span></span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">typedef</span> boost::shared_ptr &lt;TcpConnection&gt; TcpConnectionPtr;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span>  <span class="comment">// MUDUO_NET_TCPCONNECTION_H</span></span></span><br></pre></td></tr></table></figure>

<p>TcpConnection.cc</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;muduo/net/TcpConnection.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;muduo/base/Logging.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;muduo/net/Channel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;muduo/net/EventLoop.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;muduo/net/Socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;muduo/net/SocketsOps.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/bind.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> muduo;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> muduo::net;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> muduo::net::<span class="built_in">defaultConnectionCallback</span>(<span class="type">const</span> TcpConnectionPtr &amp;conn)<span class="comment">//默认的连接回调函数，输出连接状态</span></span><br><span class="line">&#123;</span><br><span class="line">    LOG_TRACE &lt;&lt; conn-&gt;<span class="built_in">localAddress</span>().<span class="built_in">toIpPort</span>() &lt;&lt; <span class="string">&quot; -&gt; &quot;</span></span><br><span class="line">              &lt;&lt; conn-&gt;<span class="built_in">peerAddress</span>().<span class="built_in">toIpPort</span>() &lt;&lt; <span class="string">&quot; is &quot;</span></span><br><span class="line">              &lt;&lt; (conn-&gt;<span class="built_in">connected</span>() ? <span class="string">&quot;UP&quot;</span> : <span class="string">&quot;DOWN&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> muduo::net::<span class="built_in">defaultMessageCallback</span>(<span class="type">const</span> TcpConnectionPtr &amp;, Buffer *buf, Timestamp)</span><br><span class="line"><span class="comment">//默认的有消息时执行的回调函数，把缓冲区读指针和写指针回到初始化的位置</span></span><br><span class="line"><span class="comment">//可以理解为将缓冲区清零</span></span><br><span class="line">&#123;</span><br><span class="line">    buf-&gt;<span class="built_in">retrieveAll</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">TcpConnection::<span class="built_in">TcpConnection</span>(EventLoop *loop, <span class="type">const</span> string &amp;nameArg, <span class="type">int</span> sockfd,</span><br><span class="line">                             <span class="type">const</span> InetAddress &amp;localAddr,</span><br><span class="line">                             <span class="type">const</span> InetAddress &amp;peerAddr)</span><br><span class="line">        : <span class="built_in">loop_</span>(<span class="built_in">CHECK_NOTNULL</span>(loop)), <span class="comment">// 所属EventLoop</span></span><br><span class="line">          <span class="built_in">name_</span>(nameArg),<span class="comment">// 连接名</span></span><br><span class="line">          <span class="built_in">state_</span>(kConnecting),<span class="comment">//连接状态</span></span><br><span class="line">          <span class="built_in">socket_</span>(<span class="keyword">new</span> <span class="built_in">Socket</span>(sockfd)),<span class="comment">//连接套接字</span></span><br><span class="line">          <span class="built_in">channel_</span>(<span class="keyword">new</span> <span class="built_in">Channel</span>(loop, sockfd)),</span><br><span class="line">          <span class="comment">//channel_在TCPServer中绑定了连接套接字，就是能够实现通信的那个connfd套接字，这个套接字是从Socket::accept函数得到的</span></span><br><span class="line">          <span class="comment">//在Tcpclient绑定的是创建的套接字，因为客户端只需要一个套接字就可以了，这个套接字是从socket()函数中得到的</span></span><br><span class="line">          <span class="built_in">localAddr_</span>(localAddr),<span class="comment">//当前服务端的地址</span></span><br><span class="line">          <span class="built_in">peerAddr_</span>(peerAddr),<span class="comment">//当前建立连接的客户端地址</span></span><br><span class="line">          <span class="built_in">highWaterMark_</span>(<span class="number">64</span> * <span class="number">1024</span> * <span class="number">1024</span>) &#123;</span><br><span class="line">    <span class="comment">// 通道可读事件到来的时候，回调TcpConnection::handleRead，_1是事件发生时间</span></span><br><span class="line">    channel_-&gt;<span class="built_in">setReadCallback</span>(boost::<span class="built_in">bind</span>(&amp;TcpConnection::handleRead, <span class="keyword">this</span>, _1));</span><br><span class="line">    <span class="comment">// 通道可写事件到来的时候，回调TcpConnection::handleWrite</span></span><br><span class="line">    channel_-&gt;<span class="built_in">setWriteCallback</span>(boost::<span class="built_in">bind</span>(&amp;TcpConnection::handleWrite, <span class="keyword">this</span>));</span><br><span class="line">    <span class="comment">// 连接关闭，回调TcpConnection::handleClose</span></span><br><span class="line">    channel_-&gt;<span class="built_in">setCloseCallback</span>(boost::<span class="built_in">bind</span>(&amp;TcpConnection::handleClose, <span class="keyword">this</span>));</span><br><span class="line">    <span class="comment">// 发生错误，回调TcpConnection::handleError</span></span><br><span class="line">    channel_-&gt;<span class="built_in">setErrorCallback</span>(boost::<span class="built_in">bind</span>(&amp;TcpConnection::handleError, <span class="keyword">this</span>));</span><br><span class="line">    LOG_DEBUG &lt;&lt; <span class="string">&quot;TcpConnection::ctor[&quot;</span> &lt;&lt; name_ &lt;&lt; <span class="string">&quot;] at &quot;</span> &lt;&lt; <span class="keyword">this</span>&lt;&lt; <span class="string">&quot; fd=&quot;</span> &lt;&lt; sockfd;</span><br><span class="line">    socket_-&gt;<span class="built_in">setKeepAlive</span>(<span class="literal">true</span>);<span class="comment">//定期探测连接是否存在，类似于心跳包</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">TcpConnection::~<span class="built_in">TcpConnection</span>() &#123;</span><br><span class="line">    LOG_DEBUG &lt;&lt; <span class="string">&quot;TcpConnection::dtor[&quot;</span> &lt;&lt; name_ &lt;&lt; <span class="string">&quot;] at &quot;</span> &lt;&lt; <span class="keyword">this</span></span><br><span class="line">              &lt;&lt; <span class="string">&quot; fd=&quot;</span> &lt;&lt; channel_-&gt;<span class="built_in">fd</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程安全，可以跨线程调用</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TcpConnection::send</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *data, <span class="type">size_t</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (state_ == kConnected) &#123;</span><br><span class="line">        <span class="keyword">if</span> (loop_-&gt;<span class="built_in">isInLoopThread</span>()) &#123;</span><br><span class="line">            <span class="built_in">sendInLoop</span>(data, len);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            string <span class="built_in">message</span>(<span class="built_in">static_cast</span>&lt;<span class="type">const</span> <span class="type">char</span> *&gt;(data), len);</span><br><span class="line">            loop_-&gt;<span class="built_in">runInLoop</span>(boost::<span class="built_in">bind</span>(&amp;TcpConnection::sendInLoop,<span class="keyword">this</span>,message));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程安全，可以跨线程调用</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TcpConnection::send</span><span class="params">(<span class="type">const</span> StringPiece &amp;message)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (state_ == kConnected) &#123;</span><br><span class="line">        <span class="keyword">if</span> (loop_-&gt;<span class="built_in">isInLoopThread</span>()) &#123;</span><br><span class="line">            <span class="built_in">sendInLoop</span>(message);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            loop_-&gt;<span class="built_in">runInLoop</span>(boost::<span class="built_in">bind</span>(&amp;TcpConnection::sendInLoop,<span class="keyword">this</span>,message.<span class="built_in">as_string</span>()));</span><br><span class="line">            <span class="comment">//std::forward&lt;string&gt;(message)));</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程安全，可以跨线程调用</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TcpConnection::send</span><span class="params">(Buffer *buf)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (state_ == kConnected) &#123;</span><br><span class="line">        <span class="keyword">if</span> (loop_-&gt;<span class="built_in">isInLoopThread</span>()) &#123;</span><br><span class="line">            <span class="built_in">sendInLoop</span>(buf-&gt;<span class="built_in">peek</span>(), buf-&gt;<span class="built_in">readableBytes</span>());</span><br><span class="line">            buf-&gt;<span class="built_in">retrieveAll</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            loop_-&gt;<span class="built_in">runInLoop</span>(boost::<span class="built_in">bind</span>(&amp;TcpConnection::sendInLoop,<span class="keyword">this</span>,buf-&gt;<span class="built_in">retrieveAllAsString</span>()));</span><br><span class="line">            <span class="comment">//std::forward&lt;string&gt;(message)));</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TcpConnection::sendInLoop</span><span class="params">(<span class="type">const</span> StringPiece &amp;message)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">sendInLoop</span>(message.<span class="built_in">data</span>(), message.<span class="built_in">size</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TcpConnection::sendInLoop</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *data, <span class="type">size_t</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    loop_-&gt;assertInLoopThread();</span></span><br><span class="line"><span class="comment">    sockets::write(channel_-&gt;fd(), data, len);</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    loop_-&gt;<span class="built_in">assertInLoopThread</span>();</span><br><span class="line">    <span class="type">ssize_t</span> nwrote = <span class="number">0</span>;</span><br><span class="line">    <span class="type">size_t</span> remaining = len;</span><br><span class="line">    <span class="type">bool</span> error = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (state_ == kDisconnected) &#123;</span><br><span class="line">        LOG_WARN &lt;&lt; <span class="string">&quot;disconnected, give up writing&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// if no thing in output queue, try writing directly</span></span><br><span class="line">    <span class="comment">// 通道没有关注可写事件并且发送缓冲区没有数据，直接write</span></span><br><span class="line">    <span class="keyword">if</span> (!channel_-&gt;<span class="built_in">isWriting</span>() &amp;&amp; outputBuffer_.<span class="built_in">readableBytes</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">        nwrote = sockets::<span class="built_in">write</span>(channel_-&gt;<span class="built_in">fd</span>(), data, len);</span><br><span class="line">        <span class="keyword">if</span> (nwrote &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            remaining = len - nwrote;</span><br><span class="line">            <span class="comment">// 写完了，回调writeCompleteCallback_</span></span><br><span class="line">            <span class="keyword">if</span> (remaining == <span class="number">0</span> &amp;&amp; writeCompleteCallback_) &#123;</span><br><span class="line">                loop_-&gt;<span class="built_in">queueInLoop</span>(boost::<span class="built_in">bind</span>(writeCompleteCallback_, <span class="built_in">shared_from_this</span>()));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="comment">// nwrote &lt; 0</span></span><br><span class="line">        &#123;</span><br><span class="line">            nwrote = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (errno != EWOULDBLOCK) &#123;</span><br><span class="line">                LOG_SYSERR &lt;&lt; <span class="string">&quot;TcpConnection::sendInLoop&quot;</span>;</span><br><span class="line">                <span class="keyword">if</span> (errno == EPIPE) <span class="comment">// <span class="doctag">FIXME:</span> any others?</span></span><br><span class="line">                &#123;</span><br><span class="line">                    error = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">assert</span>(remaining &lt;= len);</span><br><span class="line">    <span class="comment">// 没有错误，并且还有未写完的数据（说明内核发送缓冲区满，要将未写完的数据添加到output buffer中）</span></span><br><span class="line">    <span class="keyword">if</span> (!error &amp;&amp; remaining &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        LOG_TRACE &lt;&lt; <span class="string">&quot;I am going to write more data&quot;</span>;</span><br><span class="line">        <span class="type">size_t</span> oldLen = outputBuffer_.<span class="built_in">readableBytes</span>();</span><br><span class="line">        <span class="comment">// 如果超过highWaterMark_（高水位标），回调highWaterMarkCallback_</span></span><br><span class="line">        <span class="keyword">if</span> (oldLen + remaining &gt;= highWaterMark_</span><br><span class="line">            &amp;&amp; oldLen &lt; highWaterMark_</span><br><span class="line">            &amp;&amp; highWaterMarkCallback_) &#123;</span><br><span class="line">            loop_-&gt;<span class="built_in">queueInLoop</span>(boost::<span class="built_in">bind</span>(highWaterMarkCallback_, <span class="built_in">shared_from_this</span>(), oldLen + remaining));</span><br><span class="line">        &#125;</span><br><span class="line">        outputBuffer_.<span class="built_in">append</span>(<span class="built_in">static_cast</span>&lt;<span class="type">const</span> <span class="type">char</span> *&gt;(data) + nwrote, remaining);<span class="comment">//将剩余数据存入应用层发送缓冲区</span></span><br><span class="line">        <span class="keyword">if</span> (!channel_-&gt;<span class="built_in">isWriting</span>()) &#123;</span><br><span class="line">            channel_-&gt;<span class="built_in">enableWriting</span>();        <span class="comment">// 关注POLLOUT事件</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TcpConnection::shutdown</span><span class="params">()</span><span class="comment">//关闭连接</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">FIXME:</span> use compare and swap</span></span><br><span class="line">    <span class="keyword">if</span> (state_ == kConnected) &#123;</span><br><span class="line">        <span class="built_in">setState</span>(kDisconnecting);</span><br><span class="line">        <span class="comment">// <span class="doctag">FIXME:</span> shared_from_this()?</span></span><br><span class="line">        loop_-&gt;<span class="built_in">runInLoop</span>(boost::<span class="built_in">bind</span>(&amp;TcpConnection::shutdownInLoop, <span class="keyword">this</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TcpConnection::shutdownInLoop</span><span class="params">()</span><span class="comment">//在loop中关闭写半边，还是可以读数据</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    loop_-&gt;<span class="built_in">assertInLoopThread</span>();</span><br><span class="line">    <span class="keyword">if</span> (!channel_-&gt;<span class="built_in">isWriting</span>()) &#123;</span><br><span class="line">        <span class="comment">// we are not writing</span></span><br><span class="line">        socket_-&gt;<span class="built_in">shutdownWrite</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TcpConnection::setTcpNoDelay</span><span class="params">(<span class="type">bool</span> on)</span><span class="comment">//设置TCP延迟连接</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    socket_-&gt;<span class="built_in">setTcpNoDelay</span>(on);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TcpConnection::connectEstablished</span><span class="params">()</span><span class="comment">//这个建立连接是TcpConnection类中的channel加入到对应的比如Tcpclient或者Tcpserver类所属的eventloop中</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    loop_-&gt;<span class="built_in">assertInLoopThread</span>();</span><br><span class="line">    <span class="built_in">assert</span>(state_ == kConnecting);<span class="comment">//设置正在连接状态</span></span><br><span class="line">    <span class="built_in">setState</span>(kConnected);</span><br><span class="line">    LOG_TRACE &lt;&lt; <span class="string">&quot;[3] usecount=&quot;</span> &lt;&lt; <span class="built_in">shared_from_this</span>().<span class="built_in">use_count</span>();</span><br><span class="line">    channel_-&gt;<span class="built_in">tie</span>(<span class="built_in">shared_from_this</span>());</span><br><span class="line">    channel_-&gt;<span class="built_in">enableReading</span>();    <span class="comment">// TcpConnection所对应的通道加入到Poller关注</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">connectionCallback_</span>(<span class="built_in">shared_from_this</span>());</span><br><span class="line">    LOG_TRACE &lt;&lt; <span class="string">&quot;[4] usecount=&quot;</span> &lt;&lt; <span class="built_in">shared_from_this</span>().<span class="built_in">use_count</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TcpConnection::connectDestroyed</span><span class="params">()</span><span class="comment">//取消连接，从对应的Eventloop上的epoll队列中去除</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    loop_-&gt;<span class="built_in">assertInLoopThread</span>();</span><br><span class="line">    <span class="keyword">if</span> (state_ == kConnected) &#123;</span><br><span class="line">        <span class="built_in">setState</span>(kDisconnected);</span><br><span class="line">        channel_-&gt;<span class="built_in">disableAll</span>();</span><br><span class="line"></span><br><span class="line">        <span class="built_in">connectionCallback_</span>(<span class="built_in">shared_from_this</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    channel_-&gt;<span class="built_in">remove</span>();<span class="comment">//将channel从epoll队列中移除</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TcpConnection::handleRead</span><span class="params">(Timestamp receiveTime)</span><span class="comment">//处理读事件的函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    loop_-&gt;assertInLoopThread();</span></span><br><span class="line"><span class="comment">    int savedErrno = 0;</span></span><br><span class="line"><span class="comment">    ssize_t n = inputBuffer_.readFd(channel_-&gt;fd(), &amp;savedErrno);</span></span><br><span class="line"><span class="comment">    if (n &gt; 0)</span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">      messageCallback_(shared_from_this(), &amp;inputBuffer_, receiveTime);</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    else if (n == 0)</span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">      handleClose();</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    else</span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">      errno = savedErrno;</span></span><br><span class="line"><span class="comment">      LOG_SYSERR &lt;&lt; &quot;TcpConnection::handleRead&quot;;</span></span><br><span class="line"><span class="comment">      handleError();</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    loop_-&gt;assertInLoopThread();</span></span><br><span class="line"><span class="comment">    int savedErrno = 0;</span></span><br><span class="line"><span class="comment">    char buf[65536];</span></span><br><span class="line"><span class="comment">    ssize_t n = ::read(channel_-&gt;fd(), buf, sizeof buf);</span></span><br><span class="line"><span class="comment">    if (n &gt; 0)</span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">      messageCallback_(shared_from_this(), buf, n);</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    else if (n == 0)</span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">      handleClose();</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    else</span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">      errno = savedErrno;</span></span><br><span class="line"><span class="comment">      LOG_SYSERR &lt;&lt; &quot;TcpConnection::handleRead&quot;;</span></span><br><span class="line"><span class="comment">      handleError();</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    loop_-&gt;<span class="built_in">assertInLoopThread</span>();</span><br><span class="line">    <span class="type">int</span> savedErrno = <span class="number">0</span>;</span><br><span class="line">    <span class="type">ssize_t</span> n = inputBuffer_.<span class="built_in">readFd</span>(channel_-&gt;<span class="built_in">fd</span>(), &amp;savedErrno);<span class="comment">//直接将数据读到inputBuffer_缓冲区</span></span><br><span class="line">    <span class="keyword">if</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">messageCallback_</span>(<span class="built_in">shared_from_this</span>(), &amp;inputBuffer_, receiveTime);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">handleClose</span>();<span class="comment">//如果读到的数据为0，就自动退出</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        errno = savedErrno;</span><br><span class="line">        LOG_SYSERR &lt;&lt; <span class="string">&quot;TcpConnection::handleRead&quot;</span>;</span><br><span class="line">        <span class="built_in">handleError</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听到写事件了，就调用这个函数，此时服务器已经把要写的内容写到outputBuffer_中去了，所以要写的内容从读指针处开始</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TcpConnection::handleWrite</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    loop_-&gt;<span class="built_in">assertInLoopThread</span>();</span><br><span class="line">    <span class="keyword">if</span> (channel_-&gt;<span class="built_in">isWriting</span>())<span class="comment">//查看是否有写事件需要关注</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">ssize_t</span> n = sockets::<span class="built_in">write</span>(channel_-&gt;<span class="built_in">fd</span>(),</span><br><span class="line">                                   outputBuffer_.<span class="built_in">peek</span>(),</span><br><span class="line">                                   outputBuffer_.<span class="built_in">readableBytes</span>());<span class="comment">//写到文件描述符中去</span></span><br><span class="line">        <span class="keyword">if</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            outputBuffer_.<span class="built_in">retrieve</span>(n);<span class="comment">//处理读写指针</span></span><br><span class="line">            <span class="keyword">if</span> (outputBuffer_.<span class="built_in">readableBytes</span>() == <span class="number">0</span>)     <span class="comment">// 发送缓冲区已清空</span></span><br><span class="line">            &#123;</span><br><span class="line">                channel_-&gt;<span class="built_in">disableWriting</span>();        <span class="comment">// 停止关注POLLOUT事件，以免出现busy loop</span></span><br><span class="line">                <span class="keyword">if</span> (writeCompleteCallback_)        <span class="comment">// 回调writeCompleteCallback_</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// 应用层发送缓冲区被清空，就回调用writeCompleteCallback_</span></span><br><span class="line">                    <span class="comment">// 发送给IO线程进行处理</span></span><br><span class="line">                    loop_-&gt;<span class="built_in">queueInLoop</span>(boost::<span class="built_in">bind</span>(writeCompleteCallback_, <span class="built_in">shared_from_this</span>()));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (state_ == kDisconnecting)    <span class="comment">// 发送缓冲区已清空并且连接状态是kDisconnecting, 要关闭连接</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">shutdownInLoop</span>();        <span class="comment">// 关闭写连接</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                LOG_TRACE &lt;&lt; <span class="string">&quot;I am going to write more data&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            LOG_SYSERR &lt;&lt; <span class="string">&quot;TcpConnection::handleWrite&quot;</span>;</span><br><span class="line">            <span class="comment">// if (state_ == kDisconnecting)</span></span><br><span class="line">            <span class="comment">// &#123;</span></span><br><span class="line">            <span class="comment">//   shutdownInLoop();</span></span><br><span class="line">            <span class="comment">// &#125;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        LOG_TRACE &lt;&lt; <span class="string">&quot;Connection fd = &quot;</span> &lt;&lt; channel_-&gt;<span class="built_in">fd</span>()</span><br><span class="line">                  &lt;&lt; <span class="string">&quot; is down, no more writing&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TcpConnection::handleClose</span><span class="params">()</span><span class="comment">//关闭事件处理，也是epoll如果发生关闭事件的回调函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    loop_-&gt;<span class="built_in">assertInLoopThread</span>();</span><br><span class="line">    LOG_TRACE &lt;&lt; <span class="string">&quot;fd = &quot;</span> &lt;&lt; channel_-&gt;<span class="built_in">fd</span>() &lt;&lt; <span class="string">&quot; state = &quot;</span> &lt;&lt; state_;</span><br><span class="line">    <span class="built_in">assert</span>(state_ == kConnected || state_ == kDisconnecting);</span><br><span class="line">    <span class="comment">// we don&#x27;t close fd, leave it to dtor, so we can find leaks easily.</span></span><br><span class="line">    <span class="built_in">setState</span>(kDisconnected);</span><br><span class="line">    channel_-&gt;<span class="built_in">disableAll</span>();</span><br><span class="line"></span><br><span class="line">    <span class="function">TcpConnectionPtr <span class="title">guardThis</span><span class="params">(shared_from_this())</span></span>;</span><br><span class="line">    <span class="built_in">connectionCallback_</span>(guardThis);        <span class="comment">// 在结束前，最后一次处理一下，这一行，可以不调用</span></span><br><span class="line">    LOG_TRACE &lt;&lt; <span class="string">&quot;[7] usecount=&quot;</span> &lt;&lt; guardThis.<span class="built_in">use_count</span>();</span><br><span class="line">    <span class="comment">// must be the last line</span></span><br><span class="line">    <span class="built_in">closeCallback_</span>(guardThis);    <span class="comment">// 调用TcpServer::removeConnection</span></span><br><span class="line">    LOG_TRACE &lt;&lt; <span class="string">&quot;[11] usecount=&quot;</span> &lt;&lt; guardThis.<span class="built_in">use_count</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TcpConnection::handleError</span><span class="params">()</span><span class="comment">//处理错误的函数，也是epoll如果发生错误事件的回调函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> err = sockets::<span class="built_in">getSocketError</span>(channel_-&gt;<span class="built_in">fd</span>());</span><br><span class="line">    LOG_ERROR &lt;&lt; <span class="string">&quot;TcpConnection::handleError [&quot;</span> &lt;&lt; name_</span><br><span class="line">              &lt;&lt; <span class="string">&quot;] - SO_ERROR = &quot;</span> &lt;&lt; err &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; <span class="built_in">strerror_tl</span>(err);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="timer"><a href="#timer" class="headerlink" title="timer"></a>timer</h3><p>Muduo的定时器功能主要由三个class实现，TimerId，Timer，TimerQueue，TimerQueue的接口只有两个addTimer()和cancel()，addTimer()是提供给EventLoop使用的， EventLoop会把它封装成更好用的三个函数：runAt()、runAfter()、runEvery()。</p>
<p><strong>大体实现</strong></p>
<p>muduo 定时器封装了 Timer.h 里面保存的是超时时间和回调函数, TimerQueue.h 使用set容器保存多个定时器, 然后在TimerQueue中使用timerfd_create创建一个timerfd句柄, 插入定时器A后先比较A的触发时间和TimerQueue的触发时间, 如果A的触发时间比其小就使用timerfd_settime重置TimerQueue的timerfd的触发时间, TimerQueue中的timerfd的触发时间永远与保存的定时器中触发时间最小的那个相同, 然后timerfd触发可读后, 遍历保存的多个定时器, 看看有没有同时到期的, 有执行回调函数</p>
<p>TimerQueue的封装是为了让未到期的时间Timer有序的排列起来，这样，能够更具当前时间找到已经到期的Timer也能高效的添加和删除Timer。</p>
<p>所谓的到期与未到期，与当前在当前时间之前表示已经到期，之后则是未到期。为了方便计算，muduo重载了operator&lt;主要是用来比较微秒大小。</p>
<p>到期的时间应该被清除去执行相应的回调，未到期的时间则应该有序的排列起来。</p>
<p> 对于TimerQueue的数据结构，作者提出了几个方案。</p>
<p>1.传统线性表，查找复杂度为O(n)</p>
<p>2.二叉堆实现优先级队列，不过C++标准的make_heap()不能高效地完成删除操作。</p>
<p> 最终，为了防止时间相同所导致的Key相同的情况，使用set和pair</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">typedef std::pair&lt;Timestamp, Timer*&gt;Entry;</span><br><span class="line"></span><br><span class="line">typedef std::set&lt;Entry&gt;TimerList;</span><br><span class="line"></span><br><span class="line">TimerList timers_;</span><br></pre></td></tr></table></figure>

<p><strong>timerfd介绍</strong></p>
<p>这节介绍muduo中定时器的实现。先看一个2.6内核新增的有关定时的系统调用，基于这几个系统调用可以实现基于文件描述符的定时器。使文件描述符在某一特定时间可读。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/timerfd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">timerfd_create</span><span class="params">(<span class="type">int</span> clockid, <span class="type">int</span> flags)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">timerfd_settime</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span> flags,</span></span></span><br><span class="line"><span class="params"><span class="function">           <span class="type">const</span> <span class="keyword">struct</span> itimerspec * new_value,</span></span></span><br><span class="line"><span class="params"><span class="function">           <span class="keyword">struct</span> itimerspec * old_value)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">timerfd_gettime</span><span class="params">(<span class="type">int</span> fd, <span class="keyword">struct</span> itimerspec *curr_value)</span></span>;</span><br></pre></td></tr></table></figure>

<p>1、timerfd_create用于创建一个定时器文件，函数返回值是一个文件句柄fd。</p>
<p>2、timerfd_settime用于设置新的超时时间，并开始计时。flag为0表示相对时间，为1表示绝对时间。new_value为这次设置的新时间，old_value为上次设置的时间。返回0表示设置成功。</p>
<p>3、timerfd_gettime用于获得定时器距离下次超时还剩下的时间。如果调用时定时器已经到期，并且该定时器处于循环模式（设置超时时间时struct itimerspec::it_interval不为0），那么调用此函数之后定时器重新开始计时。</p>
<p><strong>TimerId介绍</strong></p>
<p>TimerId非常简单，它被设计用来取消Timer的，它的结构很简单，只有一个Timer指针和其序列号。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*封装了timer类到构造和析构函数中，我的理解就是RAII的思想</span></span><br><span class="line"><span class="comment"> * TimerId非常简单，它被设计用来取消Timer的，它的结构很简单，只有一个Timer指针和其序列号。*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> MUDUO_NET_TIMERID_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MUDUO_NET_TIMERID_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;muduo/base/copyable.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> muduo &#123;</span><br><span class="line">    <span class="keyword">namespace</span> net &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">class</span> <span class="title class_">Timer</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// An opaque identifier, for canceling Timer.</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line">        <span class="keyword">class</span> <span class="title class_">TimerId</span> : <span class="keyword">public</span> muduo::copyable &#123;</span><br><span class="line">        <span class="keyword">public</span>:</span><br><span class="line">            <span class="built_in">TimerId</span>()</span><br><span class="line">                    : <span class="built_in">timer_</span>(<span class="literal">NULL</span>),</span><br><span class="line">                      <span class="built_in">sequence_</span>(<span class="number">0</span>) &#123;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">TimerId</span>(Timer *timer, <span class="type">int64_t</span> seq)</span><br><span class="line">                    : <span class="built_in">timer_</span>(timer),</span><br><span class="line">                      <span class="built_in">sequence_</span>(seq) &#123;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// default copy-ctor, dtor and assignment are okay</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">TimerQueue</span>;<span class="comment">//友元，就是可以访问类的私有成员变量，但不是类中的成员</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span>:</span><br><span class="line">            Timer *timer_;</span><br><span class="line">            <span class="type">int64_t</span> sequence_;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span>  <span class="comment">// MUDUO_NET_TIMERID_H</span></span></span><br></pre></td></tr></table></figure>

<p><strong>Timer</strong></p>
<p>Timer封装了定时器的一些参数，例如超时回调函数、超时时间、定时器是否重复、重复间隔时间、定时器的序列号。其函数大都是设置这些参数，run()用来调用回调函数，restart()用来重启定时器（如果设置为重复）。其源码相对简单</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*计时器类*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> MUDUO_NET_TIMER_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MUDUO_NET_TIMER_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/noncopyable.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;muduo/base/Atomic.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;muduo/base/Timestamp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;muduo/net/Callbacks.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> muduo &#123;</span><br><span class="line">    <span class="keyword">namespace</span> net &#123;</span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// Internal class for timer event.</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line">        <span class="keyword">class</span> <span class="title class_">Timer</span> : boost::noncopyable &#123;</span><br><span class="line">        <span class="keyword">public</span>:</span><br><span class="line">            <span class="built_in">Timer</span>(<span class="type">const</span> TimerCallback &amp;cb, Timestamp when, <span class="type">double</span> interval)</span><br><span class="line">                    : <span class="built_in">callback_</span>(cb),<span class="comment">//回调函数</span></span><br><span class="line">                      <span class="built_in">expiration_</span>(when),<span class="comment">//超时时间</span></span><br><span class="line">                      <span class="built_in">interval_</span>(interval),<span class="comment">//如果重复，间隔时间</span></span><br><span class="line">                      <span class="built_in">repeat_</span>(interval &gt; <span class="number">0.0</span>),<span class="comment">//如果间隔大于0，就重复</span></span><br><span class="line">                      <span class="built_in">sequence_</span>(s_numCreated_.<span class="built_in">incrementAndGet</span>()) &#123;&#125;<span class="comment">//当前定时器的序列号</span></span><br><span class="line">            <span class="comment">//调用回调函数.</span></span><br><span class="line">            <span class="function"><span class="type">void</span> <span class="title">run</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">                <span class="built_in">callback_</span>();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function">Timestamp <span class="title">expiration</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> expiration_; &#125;<span class="comment">//返回超时时刻</span></span><br><span class="line">            <span class="function"><span class="type">bool</span> <span class="title">repeat</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> repeat_; &#125;<span class="comment">//返回是否重复</span></span><br><span class="line">            <span class="function"><span class="type">int64_t</span> <span class="title">sequence</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> sequence_; &#125;<span class="comment">//返回定时器序号</span></span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="type">void</span> <span class="title">restart</span><span class="params">(Timestamp now)</span></span>;<span class="comment">//重新开始</span></span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="type">static</span> <span class="type">int64_t</span> <span class="title">numCreated</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> s_numCreated_.<span class="built_in">get</span>(); &#125;<span class="comment">//返回最新的序号值</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span>:</span><br><span class="line">            <span class="type">const</span> TimerCallback callback_;        <span class="comment">// 定时器回调函数</span></span><br><span class="line">            Timestamp expiration_;                <span class="comment">// 下一次的超时时间戳类</span></span><br><span class="line">            <span class="type">const</span> <span class="type">double</span> interval_;                <span class="comment">// 超时时间间隔，如果是一次性定时器，该值为0</span></span><br><span class="line">            <span class="type">const</span> <span class="type">bool</span> repeat_;                    <span class="comment">// 是否重复</span></span><br><span class="line">            <span class="type">const</span> <span class="type">int64_t</span> sequence_;                <span class="comment">// 定时器序号，不会重复</span></span><br><span class="line"></span><br><span class="line">            <span class="type">static</span> AtomicInt64 s_numCreated_;        <span class="comment">// 定时器计数，当前已经创建的定时器数量</span></span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span>  <span class="comment">// MUDUO_NET_TIMER_H</span></span></span><br></pre></td></tr></table></figure>

<p><strong>TimerQueue</strong></p>
<p>虽然TimerQueue中有Queue，但是其实现时基于Set的，而不是Queue。这样可以高效地插入、删除定时器，且找到当前已经超时的定时器。TimerQueue的public接口只有两个，添加和删除。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">void addTimerInLoop(Timer* timer);</span><br><span class="line"></span><br><span class="line">void cancelInLoop(TimerId timerId);</span><br></pre></td></tr></table></figure>

<p>定时器管理类，其中timer类就是TimerQueue需要管理的元素，而timerId就是一个简单的timer封装，避免销毁和创建操作</p>
<p>但是要注意的是timer并没有自己计时的功能，所以需要依靠timerfd这个系统函数统一计时timerfd是一个系统计时函数，当所设置的时间到了，会通过timerfd这个文件描述符进行提示通信，而其他计时函数可能是通过信号量，或者其他方式，但是都没有文件描述符好，并且也可以用timerfd监听。</p>
<p>如何使用timerfd来为所有的计时器计时：timerfd每次都设置在计时器列表中到期时间最近的那个到期时间，这样timerfd到期以后，也就是最近的那个计时器到期，所以每次都是手动重置timerfd的计时时间，为最近的计时器到期时间</p>
<p>内部有channel，和timerfd关联。添加新的Timer后，在超时后，timerfd可读，会处理channel事件，之后调用Timer的回调函数；在timerfd的事件处理后，还有检查一遍超时定时器，如果其属性为重复还有再次添加到定时器集合中。</p>
<p>内部有两种类型的Set</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">typedef std::pair&lt;Timestamp, Timer*&gt; Entry;</span><br><span class="line"></span><br><span class="line">typedef std::set&lt;Entry&gt; TimerList;</span><br><span class="line"></span><br><span class="line">typedef std::pair&lt;Timer*, int64_t&gt; ActiveTimer;</span><br><span class="line"></span><br><span class="line">typedef std::set&lt;ActiveTimer&gt; ActiveTimerSet;</span><br></pre></td></tr></table></figure>

<p>TimerQueue.h</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> MUDUO_NET_TIMERQUEUE_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MUDUO_NET_TIMERQUEUE_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/noncopyable.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;muduo/base/Mutex.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;muduo/base/Timestamp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;muduo/net/Callbacks.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;muduo/net/Channel.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> muduo &#123;</span><br><span class="line">    <span class="keyword">namespace</span> net &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">class</span> <span class="title class_">EventLoop</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">class</span> <span class="title class_">Timer</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">class</span> <span class="title class_">TimerId</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// A best efforts timer queue.</span></span><br><span class="line"><span class="comment">/// No guarantee that the callback will be on time.</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line">        <span class="keyword">class</span> <span class="title class_">TimerQueue</span> : boost::noncopyable &#123;</span><br><span class="line">        <span class="keyword">public</span>:</span><br><span class="line">            <span class="built_in">TimerQueue</span>(EventLoop *loop);</span><br><span class="line"></span><br><span class="line">            ~<span class="built_in">TimerQueue</span>();</span><br><span class="line"></span><br><span class="line">            <span class="comment">///</span></span><br><span class="line">            <span class="comment">/// Schedules the callback to be run at given time,</span></span><br><span class="line">            <span class="comment">/// repeats if @c interval &gt; 0.0.</span></span><br><span class="line">            <span class="comment">///</span></span><br><span class="line">            <span class="comment">/// Must be thread safe. Usually be called from other threads.</span></span><br><span class="line">            <span class="comment">// 一定是线程安全的，可以跨线程调用。通常情况下被其它线程调用。</span></span><br><span class="line">            <span class="function">TimerId <span class="title">addTimer</span><span class="params">(<span class="type">const</span> TimerCallback &amp;cb,</span></span></span><br><span class="line"><span class="params"><span class="function">                             Timestamp when,</span></span></span><br><span class="line"><span class="params"><span class="function">                             <span class="type">double</span> interval)</span></span>;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="type">void</span> <span class="title">cancel</span><span class="params">(TimerId timerId)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line">            <span class="comment">// <span class="doctag">FIXME:</span> use unique_ptr&lt;Timer&gt; instead of raw pointers.</span></span><br><span class="line">            <span class="comment">// unique_ptr是C++ 11标准的一个独享所有权的智能指针</span></span><br><span class="line">            <span class="comment">// 无法得到指向同一对象的两个unique_ptr指针</span></span><br><span class="line">            <span class="comment">// 但可以进行移动构造与移动赋值操作，即所有权可以移动到另一个对象（而非拷贝构造）</span></span><br><span class="line">            <span class="keyword">typedef</span> std::pair&lt;Timestamp, Timer *&gt; Entry;</span><br><span class="line">            <span class="keyword">typedef</span> std::set &lt;Entry&gt; TimerList;</span><br><span class="line">            <span class="keyword">typedef</span> std::pair&lt;Timer *, <span class="type">int64_t</span>&gt; ActiveTimer;</span><br><span class="line">            <span class="keyword">typedef</span> std::set &lt;ActiveTimer&gt; ActiveTimerSet;</span><br><span class="line">            <span class="comment">//set中存储的是pair类型，那么默认先按照pair的第一个元素排序，如果相同，再按照第二个元素排序。</span></span><br><span class="line">            <span class="comment">//所以这两种set都是存放定时器的列表，但是一个根据定时器的到时时间来存储，</span></span><br><span class="line">            <span class="comment">//一个根据定时器地址来存储，但是存储的定时器都是同一个，目的是为了区分同一到期时间的定时器？？？</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 以下成员函数只可能在其所属的I/O线程中调用，因而不必加锁。</span></span><br><span class="line">            <span class="comment">// 服务器性能杀手之一是锁竞争，所以要尽可能少用锁</span></span><br><span class="line">            <span class="function"><span class="type">void</span> <span class="title">addTimerInLoop</span><span class="params">(Timer *timer)</span></span>;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="type">void</span> <span class="title">cancelInLoop</span><span class="params">(TimerId timerId)</span></span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// called when timerfd alarms</span></span><br><span class="line">            <span class="function"><span class="type">void</span> <span class="title">handleRead</span><span class="params">()</span></span>;<span class="comment">//timerfdChannel_的读函数</span></span><br><span class="line">            <span class="comment">// move out all expired timers</span></span><br><span class="line">            <span class="comment">// 返回超时的定时器列表</span></span><br><span class="line">            std::vector &lt;Entry&gt; <span class="built_in">getExpired</span>(Timestamp now);</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="type">void</span> <span class="title">reset</span><span class="params">(<span class="type">const</span> std::vector &lt;Entry&gt; &amp;expired, Timestamp now)</span></span>;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="type">bool</span> <span class="title">insert</span><span class="params">(Timer *timer)</span></span>;</span><br><span class="line"></span><br><span class="line">            EventLoop *loop_;        <span class="comment">// 所属EventLoop</span></span><br><span class="line">            <span class="type">const</span> <span class="type">int</span> timerfd_;</span><br><span class="line">            <span class="comment">//过一段事件，就筛选一次，看看TimerList中有多少定时器到时间了，就处理一下，但是这样延迟很高，不太理解</span></span><br><span class="line">            Channel timerfdChannel_;<span class="comment">//与timefd绑定</span></span><br><span class="line">            <span class="comment">// Timer list sorted by expiration</span></span><br><span class="line">            TimerList timers_;    <span class="comment">// timers_是按到期时间排序，也是存放未到时间的定时器</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// for cancel()</span></span><br><span class="line">            <span class="comment">// timers_与activeTimers_保存的是相同的数据</span></span><br><span class="line">            <span class="comment">// timers_是按到期时间排序，activeTimers_是按对象地址排序</span></span><br><span class="line">            ActiveTimerSet activeTimers_;<span class="comment">//还未到时间的定时器,这里面存放的定时器是和timers_一样的，只是顺序不同</span></span><br><span class="line">            <span class="type">bool</span> callingExpiredTimers_; <span class="comment">/* atomic */</span><span class="comment">//是否在处理过期定时器的标志</span></span><br><span class="line">            ActiveTimerSet cancelingTimers_;    <span class="comment">// 保存的是被取消的定时器</span></span><br><span class="line">            <span class="comment">// 用这个列表的作用是，当出现一个循环的计时器被取消时，就要通过reset函数中对</span></span><br><span class="line">            <span class="comment">//ActiveTimerSet列表来暂停对这个计时器的重置</span></span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span>  <span class="comment">// MUDUO_NET_TIMERQUEUE_H</span></span></span><br></pre></td></tr></table></figure>

<p>TimerQueue.cc</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> __STDC_LIMIT_MACROS</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;muduo/net/TimerQueue.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;muduo/base/Logging.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;muduo/net/EventLoop.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;muduo/net/Timer.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;muduo/net/TimerId.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/bind.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/timerfd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> muduo &#123;</span><br><span class="line">    <span class="keyword">namespace</span> net &#123;</span><br><span class="line">        <span class="keyword">namespace</span> detail &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 创建定时器</span></span><br><span class="line">            <span class="function"><span class="type">int</span> <span class="title">createTimerfd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="type">int</span> timerfd = ::<span class="built_in">timerfd_create</span>(CLOCK_MONOTONIC,</span><br><span class="line">                                               TFD_NONBLOCK | TFD_CLOEXEC);<span class="comment">//CLOCK_MONOTONIC参数表明计时器的时间是从系统打开开始计时的</span></span><br><span class="line">                <span class="comment">//CLOCK_MONOTONIC表示的是时间类型</span></span><br><span class="line">                <span class="keyword">if</span> (timerfd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    LOG_SYSFATAL &lt;&lt; <span class="string">&quot;Failed in timerfd_create&quot;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> timerfd;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 计算超时时刻与当前时间的时间差</span></span><br><span class="line">            <span class="keyword">struct</span> <span class="title class_">timespec</span> <span class="built_in">howMuchTimeFromNow</span>(Timestamp when) &#123;</span><br><span class="line">                <span class="type">int64_t</span> microseconds = when.<span class="built_in">microSecondsSinceEpoch</span>()</span><br><span class="line">                                       - Timestamp::<span class="built_in">now</span>().<span class="built_in">microSecondsSinceEpoch</span>();</span><br><span class="line">                <span class="keyword">if</span> (microseconds &lt; <span class="number">100</span>) &#123;</span><br><span class="line">                    microseconds = <span class="number">100</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">struct</span> <span class="title class_">timespec</span> ts;</span><br><span class="line">                ts.tv_sec = <span class="built_in">static_cast</span>&lt;<span class="type">time_t</span>&gt;(</span><br><span class="line">                        microseconds / Timestamp::kMicroSecondsPerSecond);</span><br><span class="line">                ts.tv_nsec = <span class="built_in">static_cast</span>&lt;<span class="type">long</span>&gt;(</span><br><span class="line">                        (microseconds % Timestamp::kMicroSecondsPerSecond) * <span class="number">1000</span>);</span><br><span class="line">                <span class="keyword">return</span> ts;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 清除定时器，避免一直触发//处理超时事件。超时后，timerfd变为可读</span></span><br><span class="line">            <span class="function"><span class="type">void</span> <span class="title">readTimerfd</span><span class="params">(<span class="type">int</span> timerfd, Timestamp now)</span> </span>&#123;</span><br><span class="line">                <span class="type">uint64_t</span> howmany;</span><br><span class="line">                <span class="type">ssize_t</span> n = ::<span class="built_in">read</span>(timerfd, &amp;howmany, <span class="keyword">sizeof</span> howmany);</span><br><span class="line">                LOG_TRACE &lt;&lt; <span class="string">&quot;TimerQueue::handleRead() &quot;</span> &lt;&lt; howmany &lt;&lt; <span class="string">&quot; at &quot;</span> &lt;&lt; now.<span class="built_in">toString</span>();</span><br><span class="line">                <span class="keyword">if</span> (n != <span class="keyword">sizeof</span> howmany) &#123;</span><br><span class="line">                    LOG_ERROR &lt;&lt; <span class="string">&quot;TimerQueue::handleRead() reads &quot;</span> &lt;&lt; n &lt;&lt; <span class="string">&quot; bytes instead of 8&quot;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 重置定时器的超时时间（不是周期性的定时器，时间到expiration就结束了）</span></span><br><span class="line">            <span class="comment">// 在这里面itimerspec.it_interval都是设置的0，每次都是计时结束以后手动重新设置，然后再计时的。</span></span><br><span class="line">            <span class="function"><span class="type">void</span> <span class="title">resetTimerfd</span><span class="params">(<span class="type">int</span> timerfd, Timestamp expiration)</span> </span>&#123;</span><br><span class="line">                <span class="comment">// wake up loop by timerfd_settime()</span></span><br><span class="line">                <span class="keyword">struct</span> <span class="title class_">itimerspec</span> newValue;</span><br><span class="line">                <span class="keyword">struct</span> <span class="title class_">itimerspec</span> oldValue;</span><br><span class="line">                <span class="built_in">bzero</span>(&amp;newValue, <span class="keyword">sizeof</span> newValue);</span><br><span class="line">                <span class="built_in">bzero</span>(&amp;oldValue, <span class="keyword">sizeof</span> oldValue);</span><br><span class="line">                newValue.it_value = <span class="built_in">howMuchTimeFromNow</span>(expiration);</span><br><span class="line">                <span class="type">int</span> ret = ::<span class="built_in">timerfd_settime</span>(timerfd, <span class="number">0</span>, &amp;newValue, &amp;oldValue);</span><br><span class="line">                <span class="keyword">if</span> (ret) &#123;</span><br><span class="line">                    LOG_SYSERR &lt;&lt; <span class="string">&quot;timerfd_settime()&quot;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> muduo;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> muduo::net;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> muduo::net::detail;</span><br><span class="line"></span><br><span class="line">TimerQueue::<span class="built_in">TimerQueue</span>(EventLoop *loop)</span><br><span class="line">        : <span class="built_in">loop_</span>(loop),</span><br><span class="line">          <span class="built_in">timerfd_</span>(<span class="built_in">createTimerfd</span>()),</span><br><span class="line">          <span class="built_in">timerfdChannel_</span>(loop, timerfd_),<span class="comment">//timerfd相关的channel</span></span><br><span class="line">          <span class="built_in">timers_</span>(),</span><br><span class="line">          <span class="built_in">callingExpiredTimers_</span>(<span class="literal">false</span>) &#123;</span><br><span class="line">    timerfdChannel_.<span class="built_in">setReadCallback</span>(</span><br><span class="line">            boost::<span class="built_in">bind</span>(&amp;TimerQueue::handleRead, <span class="keyword">this</span>));</span><br><span class="line">    <span class="comment">// we are always reading the timerfd, we disarm it with timerfd_settime.</span></span><br><span class="line">    timerfdChannel_.<span class="built_in">enableReading</span>();<span class="comment">//设置关注读事件，并且加入epoll队列</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">TimerQueue::~<span class="built_in">TimerQueue</span>() &#123;</span><br><span class="line">    ::<span class="built_in">close</span>(timerfd_);</span><br><span class="line">    <span class="comment">// do not remove channel, since we&#x27;re in EventLoop::dtor();</span></span><br><span class="line">    <span class="keyword">for</span> (TimerList::iterator it = timers_.<span class="built_in">begin</span>();</span><br><span class="line">         it != timers_.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">        <span class="keyword">delete</span> it-&gt;second;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">TimerId <span class="title">TimerQueue::addTimer</span><span class="params">(<span class="type">const</span> TimerCallback &amp;cb,</span></span></span><br><span class="line"><span class="params"><span class="function">                             Timestamp when,</span></span></span><br><span class="line"><span class="params"><span class="function">                             <span class="type">double</span> interval)</span><span class="comment">//创建并增加Timer进队列中</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Timer *timer = <span class="keyword">new</span> <span class="built_in">Timer</span>(cb, when, interval);</span><br><span class="line"></span><br><span class="line">    loop_-&gt;<span class="built_in">runInLoop</span>(</span><br><span class="line">            boost::<span class="built_in">bind</span>(&amp;TimerQueue::addTimerInLoop, <span class="keyword">this</span>, timer));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//addTimerInLoop(timer);</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">TimerId</span>(timer, timer-&gt;<span class="built_in">sequence</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TimerQueue::cancel</span><span class="params">(TimerId timerId)</span><span class="comment">//取消</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    loop_-&gt;<span class="built_in">runInLoop</span>(</span><br><span class="line">            boost::<span class="built_in">bind</span>(&amp;TimerQueue::cancelInLoop, <span class="keyword">this</span>, timerId));</span><br><span class="line">    <span class="comment">//cancelInLoop(timerId);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TimerQueue::addTimerInLoop</span><span class="params">(Timer *timer)</span> </span>&#123;</span><br><span class="line">    loop_-&gt;<span class="built_in">assertInLoopThread</span>();</span><br><span class="line">    <span class="comment">// 插入一个定时器，有可能会使得最早到期的定时器发生改变</span></span><br><span class="line">    <span class="type">bool</span> earliestChanged = <span class="built_in">insert</span>(timer);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (earliestChanged) &#123;</span><br><span class="line">        <span class="comment">// 重置timefd定时器的超时时刻(timerfd_settime)</span></span><br><span class="line">        <span class="built_in">resetTimerfd</span>(timerfd_, timer-&gt;<span class="built_in">expiration</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TimerQueue::cancelInLoop</span><span class="params">(TimerId timerId)</span><span class="comment">//取消的回调函数</span></span></span><br><span class="line"><span class="function"><span class="comment">//取消计时器，就是把该计时器从两个队列中删除，</span></span></span><br><span class="line"><span class="function"><span class="comment">//现在有一种特殊情况，就是如果刚好在处理定时器的过程中，并且这个要取消的定时器就是在被处理的，并且是循环定时器，那么如果不加入cancelingTimers_列表</span></span></span><br><span class="line"><span class="function"><span class="comment">//就会出现，在重置时又把这个定时器重启了，但是这个定时器应该是要被取消的</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    loop_-&gt;<span class="built_in">assertInLoopThread</span>();</span><br><span class="line">    <span class="built_in">assert</span>(timers_.<span class="built_in">size</span>() == activeTimers_.<span class="built_in">size</span>());</span><br><span class="line">    <span class="function">ActiveTimer <span class="title">timer</span><span class="params">(timerId.timer_, timerId.sequence_)</span></span>;</span><br><span class="line">    <span class="comment">// 查找该定时器</span></span><br><span class="line">    ActiveTimerSet::iterator it = activeTimers_.<span class="built_in">find</span>(timer);</span><br><span class="line">    <span class="keyword">if</span> (it != activeTimers_.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        <span class="type">size_t</span> n = timers_.<span class="built_in">erase</span>(<span class="built_in">Entry</span>(it-&gt;first-&gt;<span class="built_in">expiration</span>(), it-&gt;first));</span><br><span class="line">        <span class="built_in">assert</span>(n == <span class="number">1</span>);</span><br><span class="line">        (<span class="type">void</span>) n;</span><br><span class="line">        <span class="keyword">delete</span> it-&gt;first; <span class="comment">// <span class="doctag">FIXME:</span> no delete please,如果用了unique_ptr,这里就不需要手动删除了</span></span><br><span class="line">        activeTimers_.<span class="built_in">erase</span>(it);</span><br><span class="line">    &#125;<span class="comment">//用activeTimers_列表来搜索，然后找到先删除timers_，再删除activeTimers_</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (callingExpiredTimers_)</span><br><span class="line">        <span class="comment">//如果在未到时间的定时器中没有找到，并且线程正在处理过期的定时器，那么可能这个定时器正在被处理，就将这些定时器放到cancelingTimers_数组中</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 已经到期，并且正在调用回调函数的定时器，为了在重置时，避免被重置，而是被忽略</span></span><br><span class="line">        cancelingTimers_.<span class="built_in">insert</span>(timer);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">assert</span>(timers_.<span class="built_in">size</span>() == activeTimers_.<span class="built_in">size</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TimerQueue::handleRead</span><span class="params">()</span><span class="comment">//TimerChannel的回调函数，也就是当timefd定时器到时的时候，就会调用这个函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    loop_-&gt;<span class="built_in">assertInLoopThread</span>();</span><br><span class="line">    <span class="function">Timestamp <span class="title">now</span><span class="params">(Timestamp::now())</span></span>;</span><br><span class="line">    <span class="built_in">readTimerfd</span>(timerfd_, now);        <span class="comment">// 清除该事件，避免一直触发</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取该时刻之前所有的定时器列表(即超时定时器列表)</span></span><br><span class="line">    std::vector &lt;Entry&gt; expired = <span class="built_in">getExpired</span>(now);</span><br><span class="line"></span><br><span class="line">    callingExpiredTimers_ = <span class="literal">true</span>;<span class="comment">//处理到期的定时器</span></span><br><span class="line">    cancelingTimers_.<span class="built_in">clear</span>();<span class="comment">//每次处理前，把要取消的定时器列表清空</span></span><br><span class="line">    <span class="comment">// safe to callback outside critical section</span></span><br><span class="line">    <span class="keyword">for</span> (std::vector&lt;Entry&gt;::iterator it = expired.<span class="built_in">begin</span>();</span><br><span class="line">         it != expired.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">        <span class="comment">// 这里回调定时器timer处理函数</span></span><br><span class="line">        it-&gt;second-&gt;<span class="built_in">run</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    callingExpiredTimers_ = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不是一次性定时器，需要重启</span></span><br><span class="line">    <span class="built_in">reset</span>(expired, now);<span class="comment">//如果之前处理定时器回调函数时间较长，那么在这段时间中，已经有定时器到期了，轻则产生延迟，重则</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// rvo</span></span><br><span class="line">std::vector &lt;TimerQueue::Entry&gt; TimerQueue::<span class="built_in">getExpired</span>(Timestamp now)<span class="comment">//得到已经过期的计时器</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">assert</span>(timers_.<span class="built_in">size</span>() == activeTimers_.<span class="built_in">size</span>());</span><br><span class="line">    std::vector &lt;Entry&gt; expired;<span class="comment">//存放已经过期的定时器</span></span><br><span class="line">    <span class="function">Entry <span class="title">sentry</span><span class="params">(now, <span class="keyword">reinterpret_cast</span>&lt;Timer *&gt;(UINTPTR_MAX))</span></span>;<span class="comment">//我理解是找了一个指针可以取到的最大数，为了避免和其他指针冲突，</span></span><br><span class="line">    <span class="comment">//因为这个指针没有什么意义，仅仅是为了构成一个Entry结构体，有意义的是第一个元素now</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回第一个未到期的Timer的迭代器</span></span><br><span class="line">    <span class="comment">// lower_bound的含义是返回第一个值&gt;=sentry的元素的iterator</span></span><br><span class="line">    <span class="comment">// 即*end &gt;= sentry，从而end-&gt;first &gt; now</span></span><br><span class="line">    TimerList::iterator end = timers_.<span class="built_in">lower_bound</span>(sentry);</span><br><span class="line">    <span class="built_in">assert</span>(end == timers_.<span class="built_in">end</span>() || now &lt; end-&gt;first);</span><br><span class="line">    <span class="comment">// 将到期的定时器插入到expired中</span></span><br><span class="line">    std::<span class="built_in">copy</span>(timers_.<span class="built_in">begin</span>(), end, <span class="built_in">back_inserter</span>(expired));<span class="comment">//back_inserter是迭代器的一种操作，效果和expired.push_back()一样</span></span><br><span class="line">    <span class="comment">// 从timers_中移除到期的定时器</span></span><br><span class="line">    timers_.<span class="built_in">erase</span>(timers_.<span class="built_in">begin</span>(), end);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从activeTimers_中移除到期的定时器</span></span><br><span class="line">    <span class="keyword">for</span> (std::vector&lt;Entry&gt;::iterator it = expired.<span class="built_in">begin</span>();</span><br><span class="line">         it != expired.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">        <span class="function">ActiveTimer <span class="title">timer</span><span class="params">(it-&gt;second, it-&gt;second-&gt;sequence())</span></span>;</span><br><span class="line">        <span class="type">size_t</span> n = activeTimers_.<span class="built_in">erase</span>(timer);</span><br><span class="line">        <span class="built_in">assert</span>(n == <span class="number">1</span>);</span><br><span class="line">        (<span class="type">void</span>) n;<span class="comment">//避免编译器出现变量n未使用的警告？？？</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">assert</span>(timers_.<span class="built_in">size</span>() == activeTimers_.<span class="built_in">size</span>());</span><br><span class="line">    <span class="keyword">return</span> expired;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TimerQueue::reset</span><span class="params">(<span class="type">const</span> std::vector &lt;Entry&gt; &amp;expired, Timestamp now)</span><span class="comment">//重启两种定时器，一种是timefd，另外一种是定时器列表中需要重复的定时器</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Timestamp nextExpire;</span><br><span class="line">    <span class="comment">//重启定时器列表中过期的定时器，如果需要重复的话</span></span><br><span class="line">    <span class="keyword">for</span> (std::vector&lt;Entry&gt;::const_iterator it = expired.<span class="built_in">begin</span>();</span><br><span class="line">         it != expired.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">        <span class="function">ActiveTimer <span class="title">timer</span><span class="params">(it-&gt;second, it-&gt;second-&gt;sequence())</span></span>;</span><br><span class="line">        <span class="comment">// 如果是重复的定时器并且是未取消定时器，则重启该定时器</span></span><br><span class="line">        <span class="keyword">if</span> (it-&gt;second-&gt;<span class="built_in">repeat</span>()</span><br><span class="line">            &amp;&amp; cancelingTimers_.<span class="built_in">find</span>(timer) == cancelingTimers_.<span class="built_in">end</span>()) &#123;</span><br><span class="line">            it-&gt;second-&gt;<span class="built_in">restart</span>(now);</span><br><span class="line">            <span class="built_in">insert</span>(it-&gt;second);</span><br><span class="line">        &#125; <span class="keyword">else</span><span class="comment">//不需要重复就删除这个定时器</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 一次性定时器或者已被取消的定时器是不能重置的，因此删除该定时器</span></span><br><span class="line">            <span class="comment">// FIXME move to a free list</span></span><br><span class="line">            <span class="keyword">delete</span> it-&gt;second; <span class="comment">// <span class="doctag">FIXME:</span> no delete please</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//重启timefd，设置的时间就是定时器列表中最快到期的时间</span></span><br><span class="line">    <span class="keyword">if</span> (!timers_.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="comment">// 获取最早到期的定时器超时时间</span></span><br><span class="line">        nextExpire = timers_.<span class="built_in">begin</span>()-&gt;second-&gt;<span class="built_in">expiration</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (nextExpire.<span class="built_in">valid</span>()) &#123;</span><br><span class="line">        <span class="comment">// 重置定时器的超时时刻(timerfd_settime)</span></span><br><span class="line">        <span class="built_in">resetTimerfd</span>(timerfd_, nextExpire);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">TimerQueue::insert</span><span class="params">(Timer *timer)</span><span class="comment">//把定时器插入到timers_和activeTimers_队列中去</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    loop_-&gt;<span class="built_in">assertInLoopThread</span>();</span><br><span class="line">    <span class="built_in">assert</span>(timers_.<span class="built_in">size</span>() == activeTimers_.<span class="built_in">size</span>());</span><br><span class="line">    <span class="comment">// 最早到期时间是否改变</span></span><br><span class="line">    <span class="type">bool</span> earliestChanged = <span class="literal">false</span>;<span class="comment">//这个变量的意义是显示最早到期时间是否改变，通俗点说就是这个插入的定时器的位置在timers_的</span></span><br><span class="line">    <span class="comment">//首位，也就是这个插入的定时器的到期时间是timers_中已经存储的定时器中最早的，那么这个标志位就会置true</span></span><br><span class="line">    Timestamp when = timer-&gt;<span class="built_in">expiration</span>();<span class="comment">//超时时刻</span></span><br><span class="line">    TimerList::iterator it = timers_.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="comment">// 如果timers_为空或者when小于timers_中的最早到期时间</span></span><br><span class="line">    <span class="keyword">if</span> (it == timers_.<span class="built_in">end</span>() || when &lt; it-&gt;first) &#123;</span><br><span class="line">        earliestChanged = <span class="literal">true</span>;<span class="comment">//表示定时器最早，所以置true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//要分别插入到两个set中</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 插入到timers_中</span></span><br><span class="line">        std::pair&lt;TimerList::iterator, <span class="type">bool</span>&gt; result</span><br><span class="line">                = timers_.<span class="built_in">insert</span>(<span class="built_in">Entry</span>(when, timer));</span><br><span class="line">        <span class="built_in">assert</span>(result.second);</span><br><span class="line">        (<span class="type">void</span>) result;</span><br><span class="line">    &#125;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 插入到activeTimers_中</span></span><br><span class="line">        std::pair&lt;ActiveTimerSet::iterator, <span class="type">bool</span>&gt; result</span><br><span class="line">                = activeTimers_.<span class="built_in">insert</span>(<span class="built_in">ActiveTimer</span>(timer, timer-&gt;<span class="built_in">sequence</span>()));</span><br><span class="line">        <span class="built_in">assert</span>(result.second);</span><br><span class="line">        (<span class="type">void</span>) result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">assert</span>(timers_.<span class="built_in">size</span>() == activeTimers_.<span class="built_in">size</span>());</span><br><span class="line">    <span class="keyword">return</span> earliestChanged;<span class="comment">//返回最早到期的时间有没有改变</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="EventLoop"><a href="#EventLoop" class="headerlink" title="EventLoop"></a>EventLoop</h3><p><code>EventLoop</code> 整合了 <code>Channel</code> 和 <code>Poller</code> 提供更方便的接口来使用，主要功能为：处理 <code>Channel</code>、处理定时事件、处理任务事件。主要接口如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">EventLoop</span> : noncopyable</span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">// EventLoop</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">loop</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">quit</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 任务事件</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">wakeup</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">runInLoop</span><span class="params">(Functor cb)</span></span>;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">queueInLoop</span><span class="params">(Functor cb)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 定时器</span></span><br><span class="line">  <span class="function">TimerId <span class="title">runAt</span><span class="params">(Timestamp time, TimerCallback cb)</span></span>;</span><br><span class="line">  <span class="function">TimerId <span class="title">runAfter</span><span class="params">(<span class="type">double</span> delay, TimerCallback cb)</span></span>;</span><br><span class="line">  <span class="function">TimerId <span class="title">runEvery</span><span class="params">(<span class="type">double</span> interval, TimerCallback cb)</span></span>;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">cancel</span><span class="params">(TimerId timerId)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 处理 Channel</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">updateChannel</span><span class="params">(Channel* channel)</span></span>;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">removeChannel</span><span class="params">(Channel* channel)</span></span>;</span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">hasChannel</span><span class="params">(Channel* channel)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>EventLoop</code> 的用法是先注册 <code>Channel</code>，如 <code>listening fd</code>，然后调用 <code>loop()</code> 一直循环处理各种任务，在 <code>loop</code> 中可以注册新的 <code>Channel</code>、定时事件和任务事件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">void EventLoop::loop()</span><br><span class="line">&#123;</span><br><span class="line">  while (!quit_)</span><br><span class="line">  &#123;</span><br><span class="line">    activeChannels_.clear();</span><br><span class="line">    pollReturnTime_ = poller_-&gt;poll(kPollTimeMs, &amp;activeChannels_);</span><br><span class="line">    for (Channel* channel : activeChannels_)</span><br><span class="line">    &#123;</span><br><span class="line">      currentActiveChannel_ = channel;</span><br><span class="line">      currentActiveChannel_-&gt;handleEvent(pollReturnTime_);</span><br><span class="line">    &#125;</span><br><span class="line">    doPendingFunctors();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先来说任务事件，使用场景主要是其他线程想要在 <code>EventLoop</code> 线程做些工作，比如 <code>EventLoop</code> 线程把耗时的任务放到 <code>threadpool</code> 中执行，完成后通知 <code>EventLoop</code> 线程获取结果。 最常见的实现方式是用 <code>pipe(2)</code>：<code>EventLoop</code> 注册读事件，其他线程把结果保存在队列中，然后写 <code>pipe</code>，<code>EventLoop</code> 线程就会唤醒处理。<code>Muduo</code> 也是类似实现，只是用 <code>eventfd(2)</code> 来唤醒。</p>
<h2 id="一个简单的例子"><a href="#一个简单的例子" class="headerlink" title="一个简单的例子"></a>一个简单的例子</h2><p>首先从最简单的 echo server 入手，来介绍 muduo 的基本使用，同时也方便后面概念的理解。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">onMessage</span><span class="params">(<span class="type">const</span> muduo::net::TcpConnectionPtr&amp; conn,</span></span></span><br><span class="line"><span class="params"><span class="function">                           muduo::net::Buffer* buf,</span></span></span><br><span class="line"><span class="params"><span class="function">                           muduo::Timestamp time)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  conn-&gt;<span class="built_in">send</span>(buf);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    muduo::net::EventLoop loop;</span><br><span class="line">    muduo::<span class="function">net::InetAddress <span class="title">listenAddr</span><span class="params">(<span class="number">2007</span>)</span></span>;</span><br><span class="line">    <span class="function">TcpServer <span class="title">server</span><span class="params">(&amp;loop, listenAddr)</span></span>;</span><br><span class="line">    server.<span class="built_in">setMessageCallback</span>(onMessage);</span><br><span class="line">    server.<span class="built_in">start</span>();</span><br><span class="line">    loop.<span class="built_in">loop</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>echo-server 的代码量非常简洁。一个典型的 muduo 的 TcpServer 工作流程如下：</p>
<ol>
<li>建立一个事件循环器 EventLoop(reactor)</li>
<li>建立对应的业务服务器 TcpServer，并指定它的reactor和地址</li>
<li>设置 TcpServer 的 Callback</li>
<li>启动 server</li>
<li>开启事件循环</li>
</ol>
<p>陈硕认为，TCP 网络编程的本质是处理三个半事件，即：</p>
<ol>
<li>连接的建立</li>
<li>连接的断开：包括主动断开和被动断开</li>
<li>消息到达，文件描述符可读。</li>
<li>消息发送完毕。这个算半个事件。</li>
</ol>
<p>我们接下来分析下 muduo 是怎么处理和实现这三个半事件的</p>
<h2 id="连接的建立"><a href="#连接的建立" class="headerlink" title="连接的建立"></a>连接的建立</h2><p>在我们单纯使用 linux 的 API，编写一个简单的 Tcp 服务器时，建立一个新的连接通常需要四步：</p>
<blockquote>
<p>步骤 1. socket() &#x2F;&#x2F; 调用 socket 函数建立监听 socket<br>步骤 2. bind() &#x2F;&#x2F; 绑定地址和端口<br>步骤 3. listen() &#x2F;&#x2F; 开始监听端口<br>步骤 4. accept() &#x2F;&#x2F; 返回新建立连接的 fd</p>
</blockquote>
<p>我们接下来分析下，这四个步骤在 muduo 中都是何时进行的：</p>
<p>首先在 TcpServer 对象构建时，TcpServer 的属性 acceptor 同时也被建立。<br>在 Acceptor 的构造函数中分别调用了 socket 函数和 bind 函数完成了 <strong>步骤 1</strong>和<strong>步骤 2</strong>。<br>即，当 <code>TcpServer server(&amp;loop, listenAddr)</code> 执行结束时，监听 socket 已经建立好，并已绑定到对应地址和端口了。</p>
<p>而当执行 <code>server.start()</code> 时，主要做了两个工作：</p>
<ol>
<li>在监听 socket 上启动 listen 函数，也就是 <strong>步骤 3</strong>；</li>
<li>将监听 socket 的可读事件注册到 EventLoop 中。</li>
</ol>
<p>此时，程序已完成对socket的监听，但还不够，因为此时程序的主角 <code>EventLoop</code> 尚未启动。<br>当调用 <code>loop.loop()</code> 时，程序开始循环监听该 socket 的可读事件。</p>
<p>当新连接请求建立时，可读事件触发，此时该事件对应的 callback 在 EventLoop::loop() 中被调用。<br>该事件的 callback 实际上就是 Acceptor::handleRead() 方法。</p>
<p>在 Acceptor::handleRead() 方法中，做了三件事：</p>
<ol>
<li>调用了 accept 函数，完成了 <strong>步骤 4</strong>，实现了连接的建立。得到一个已连接 socket 的 fd。</li>
<li>创建 TcpConnection 对象。</li>
<li>将已连接 socket 的可读事件注册到 EventLoop 中。</li>
</ol>
<p>这里还有一个需要注意的点，创建的 TcpConnnection 对象是个 shared_ptr，该对象会被保存在 TcpServer 的 connections 中。这样才能保证引用计数大于 0，对象不被释放。</p>
<p>至此，一个新的连接已完全建立好，该连接的socket可读事件也已注册到 EventLoop 中了。</p>
<h2 id="消息的读取"><a href="#消息的读取" class="headerlink" title="消息的读取"></a>消息的读取</h2><p>上节讲到，在新连接建立的时候，会将新连接的 socket 的可读事件注册到 EventLoop 中。<br>假如客户端发送消息，导致已连接 socket 的可读事件触发，该事件对应的 callback 同样也会在 EventLoop::loop() 中被调用。</p>
<p>该事件的 callback 实际上就是 TcpConnection::handleRead 方法。<br>在 TcpConnection::handleRead 方法中，主要做了两件事：</p>
<ol>
<li>从 socket 中读取数据，并将其放入 inputbuffer 中</li>
<li>调用 messageCallback，执行业务逻辑。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ssize_t</span> n = inputBuffer_.<span class="built_in">readFd</span>(channel_-&gt;<span class="built_in">fd</span>(), &amp;savedErrno);</span><br><span class="line"><span class="keyword">if</span> (n&gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">messageCallback_</span>(<span class="built_in">shared_from_this</span>(), &amp;inputBuffer_, receiveTime);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>messageCallback 是在建立新连接时，将 <code>TcpServer::messageCallback</code> 方法 bind 到了 <code>TcpConnection::messageCallback</code> 的方法。</p>
<p><code>TcpServer::messageCallback</code> 就是业务逻辑的主要实现函数。通常情况下，我们可以在里面实现消息的编解码、消息的分发等工作，这里就不再深入探讨了。</p>
<p>在我们上面给出的示例代码中，echo-server 的 messageCallback 非常简单，就是直接将得到的数据，重新 send 回去。在实际的业务处理中，一般都会调用 TcpConnection::send() 方法，给客户端回复消息。</p>
<p>这里需要注意的是，在 messageCallback 中，用户会有可能会把任务抛给自定义的 Worker 线程池处理。<br>但是这个在 Worker 线程池中任务，<strong>切忌直接对 Buffer 的操作</strong>。因为 Buffer 并不是线程安全的。</p>
<p>我们需要记住一个准则:</p>
<blockquote>
<p><strong>所有对 IO 和 buffer 的读写，都应该在 IO 线程中完成。</strong></p>
</blockquote>
<p>一般情况下，先在交给 Worker 线程池之前，应该现在 IO 线程中把 Buffer 进行切分解包等动作。将解包后的消息交由线程池处理，避免多个线程操作同一个资源。</p>
<h2 id="消息的发送"><a href="#消息的发送" class="headerlink" title="消息的发送"></a>消息的发送</h2><p>用户通过调用 TcpConnection::send() 向客户端回复消息。由于 muduo 中使用了 OutputBuffer，因此消息的发送过程比较复杂。</p>
<p>首先需要注意的是线程安全问题, 上文说到对于消息的读写必须都在 EventLoop 的同一个线程 (通常称为 IO 线程) 中进行：<br>因此，TcpConnection::send 必须要保证线程安全性，它是这么做的：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">TcpConnection::send</span><span class="params">(<span class="type">const</span> StringPiece&amp; message)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (state_ == kConnected)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> (loop_-&gt;<span class="built_in">isInLoopThread</span>())</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">sendInLoop</span>(message);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      loop_-&gt;<span class="built_in">runInLoop</span>(</span><br><span class="line">          boost::<span class="built_in">bind</span>(&amp;TcpConnection::sendInLoop,</span><br><span class="line">                      <span class="keyword">this</span>,     <span class="comment">// FIXME</span></span><br><span class="line">                      message.<span class="built_in">as_string</span>()));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>检测 send 的时候，是否在当前 IO 线程，如果是的话，直接进行写相关操作 <code>sendInLoop</code>。<br>如果不在一个线程的话，需要将该任务抛给 IO 线程执行 <code>runInloop</code>, 以保证 write 动作是在 IO 线程中执行的。我们后面会讲解 <code>runInloop</code> 的具体实现。</p>
<p>在 sendInloop 中，做了下面几件事：</p>
<ol>
<li>假如 OutputBuffer 为空，则直接向 socket 写数据</li>
<li>如果向 socket 写数据没有写完，则统计剩余的字节个数，并进行下一步。没有写完可能是因为此时 socket 的 TCP 缓冲区已满了。</li>
<li>如果此时 OutputBuffer 中的旧数据的个数和未写完字节个数之和大于 highWaterMark，则将 highWaterMarkCallback 放入待执行队列中</li>
<li><strong>将对应 socket 的可写事件注册到 EventLoop 中</strong></li>
</ol>
<p>注意：直到发送消息的时候，muduo 才会把 socket 的可写事件注册到了 EventLoop 中。在此之前只注册了可读事件。</p>
<p>连接 socket 的可写事件对应的 callback 是 TcpConnection::handleWrite()<br>当某个 socket 的可写事件触发时，TcpConnection::handleWrite 会做两个工作：</p>
<ol>
<li>尽可能将数据从 OutputBuffer 中向 socket 中 write 数据</li>
<li>如果 OutputBuffer 没有剩余的，则 <strong>将该 socket 的可写事件移除</strong>，并调用 writeCompleteCallback</li>
</ol>
<p><strong>为什么要移除可写事件</strong></p>
<p>因为当 OutputBuffer 中没数据时，我们不需要向 socket 中写入数据。但是此时 socket 一直是处于可写状态的， 这将会导致 TcpConnection::handleWrite() 一直被触发。然而这个触发毫无意义，因为并没有什么可以写的。</p>
<p>所以 muduo 的处理方式是，当 OutputBuffer 还有数据时，socket 可写事件是注册状态。当 OutputBuffer 为空时，则将 socket 的可写事件移除。</p>
<p>此外，highWaterMarkCallback 和 writeCompleteCallback 一般配合使用，起到限流的作用。在《linux 多线程服务器端编程》一书的 8.9.3 一节中有详细讲解。这里就不再赘述了</p>
<h2 id="连接的断开"><a href="#连接的断开" class="headerlink" title="连接的断开"></a>连接的断开</h2><p>我们看下 muduo 对于连接的断开是怎么处理的。<br>连接的断开分为被动断开和主动断开。主动断开和被动断开的处理方式基本一致，因此本文只讲下被动断开的部分。</p>
<p>被动断开即客户端断开了连接，server 端需要感知到这个断开的过程，然后进行的相关的处理。</p>
<p>其中感知远程断开这一步是在 Tcp 连接的可读事件处理函数 <code>handleRead</code> 中进行的：当对 socket 进行 read 操作时，返回值为 0，则说明此时连接已断开。</p>
<p>接下来会做四件事情：</p>
<ol>
<li>将该 TCP 连接对应的事件从 EventLoop 移除</li>
<li>调用用户的 ConnectionCallback</li>
<li>将对应的 TcpConnection 对象从 Server 移除。</li>
<li>close 对应的 fd。此步骤是在析构函数中自动触发的，当 TcpConnection 对象被移除后，引用计数为 0，对象析构时会调用 close。</li>
</ol>
<h2 id="runInLoop-的实现"><a href="#runInLoop-的实现" class="headerlink" title="runInLoop 的实现"></a>runInLoop 的实现</h2><p>在讲解消息的发送过程时候，我们讲到为了保证对 buffer 和 socket 的写动作是在 IO 线程中进行，使用了一个 <code>runInLoop</code> 函数，将该写任务抛给了 IO 线程处理。</p>
<p>我们接下来看下 <code>runInLoop</code> 的实现：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">EventLoop::runInLoop</span><span class="params">(<span class="type">const</span> Functor&amp; cb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">isInLoopThread</span>())</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">cb</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">queueInLoop</span>(cb);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里可以看到，做了一层判断。如果调用时是此 EventLoop 的运行线程，则直接执行此函数。<br>否则调用 <code>queueInLoop</code> 函数。我们看下 <code>queueInLoop</code> 的实现。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">EventLoop::queueInLoop</span><span class="params">(<span class="type">const</span> Functor&amp; cb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  &#123;</span><br><span class="line">  <span class="function">MutexLockGuard <span class="title">lock</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">  pendingFunctors_.<span class="built_in">push_back</span>(cb);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">isInLoopThread</span>() || callingPendingFunctors_)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">wakeup</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里有两个动作：</p>
<ol>
<li>加锁，然后将该函数放到该 EventLoop 的 pendingFunctors_队列中。</li>
<li>判断是否要唤醒 EventLoop，如果是则调用 wakeup() 唤醒该 EventLoop。</li>
</ol>
<p>这里有几个问题：</p>
<ul>
<li>为什么要唤醒 EventLoop？</li>
<li>wakeup 是怎么实现的?</li>
<li>pendingFunctors_是如何被消费的?</li>
</ul>
<h3 id="为什么要唤醒-EventLoop"><a href="#为什么要唤醒-EventLoop" class="headerlink" title="为什么要唤醒 EventLoop"></a>为什么要唤醒 EventLoop</h3><p>我们首先调用了 <code>pendingFunctors_.push_back(cb)</code>, 将该函数放在 pendingFunctors_中。EventLoop 的每一轮循环在最后会调用 doPendingFunctors 依次执行这些函数。</p>
<p>而 EventLoop 的唤醒是通过 epoll_wait 实现的，如果此时该 EventLoop 中迟迟没有事件触发，那么 epoll_wait 一直就会阻塞。 这样会导致，pendingFunctors_中的任务迟迟不能被执行了。</p>
<p>所以必须要唤醒 EventLoop ，从而让pendingFunctors_中的任务尽快被执行。</p>
<h3 id="wakeup-是怎么实现的"><a href="#wakeup-是怎么实现的" class="headerlink" title="wakeup 是怎么实现的"></a>wakeup 是怎么实现的</h3><p>muduo 这里采用了对 eventfd 的读写来实现对 EventLoop 的唤醒。</p>
<p>在 EventLoop 建立之后，就创建一个 eventfd，并将其可读事件注册到 EventLoop 中。</p>
<p><code>wakeup()</code> 的过程本质上是对这个 eventfd 进行写操作，以触发该 eventfd 的可读事件。这样就起到了唤醒 EventLoop 的作用。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">EventLoop::wakeup</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">uint64_t</span> one = <span class="number">1</span>;</span><br><span class="line">  sockets::<span class="built_in">write</span>(wakeupFd_, &amp;one, <span class="keyword">sizeof</span> one);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>很多库为了兼容 macOS，往往使用 pipe 来实现这个功能。muduo 采用了 eventfd，性能更好些，但代价是不能支持 macOS 了。不过 muduo 似乎从一开始的定位就不打算支持？</p>
<h3 id="doPendingFunctors-的实现"><a href="#doPendingFunctors-的实现" class="headerlink" title="doPendingFunctors 的实现"></a>doPendingFunctors 的实现</h3><p>本部分讲下 <code>doPendingFunctors</code> 的实现，muduo 是如何处理这些待处理的函数的，以及中间用了哪些优化操作。<br>代码如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">EventLoop::doPendingFunctors</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  std::vector&lt;Functor&gt; functors;</span><br><span class="line"></span><br><span class="line">  callingPendingFunctors_ = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">  &#123;</span><br><span class="line">  <span class="function">MutexLockGuard <span class="title">lock</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">  functors.<span class="built_in">swap</span>(pendingFunctors_);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; functors.<span class="built_in">size</span>(); ++i)</span><br><span class="line">  &#123;</span><br><span class="line">    functors[i]();</span><br><span class="line">  &#125;</span><br><span class="line">  callingPendingFunctors_ = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从代码可以看到，函数非常简单。大概只有十行代码，但是这十行代码中却有两个非常巧妙的地方。</p>
<ol>
<li><strong>callingPendingFunctors_的作用</strong></li>
</ol>
<p>从代码可以看出，如果 callingPendingFunctors_为 false，则说明此时尚未开始执行 doPendingFunctors 函数。<br>这个有什么作用呢，我们需要结合下 queueInLoop 中，对是否执行 wakeup() 的判断</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if (!isInLoopThread() || callingPendingFunctors_)</span><br><span class="line">&#123;</span><br><span class="line">  wakeup();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里还需要结合下 EventLoop 循环的实现，其中 <code>doPendingFunctors()</code> 是 <strong>每轮循环的最后一步处理</strong>。<br>如果调用 queueInLoop 和 EventLoop 在同一个线程，且 callingPendingFunctors_为 false 时，则说明：<strong>此时尚未执行到 doPendingFunctors()。</strong><br>那么此时即使不用 wakeup，也可以在之后照旧执行 doPendingFunctors() 了。</p>
<p>这么做的好处非常明显，可以减少对 eventfd 的 IO 读写。</p>
<ol>
<li><strong>锁范围的减少</strong><br>在此函数中，有一段特别的代码：</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;Functor&gt; functors;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="function">MutexLockGuard <span class="title">lock</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">  functors.<span class="built_in">swap</span>(pendingFunctors_);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个作用是 pendingFunctors_和 functors 的内容进行交换，实际上就是此时 functors 持有了 pendingFunctors_的内容，而 pendingFunctors_被清空了。</p>
<p>这个好处是什么呢？<br>如果不这么做，直接遍历 pendingFunctors_, 然后处理对应的函数。这样的话，锁会一直等到所有函数处理完才会被释放。在此期间，queueInLoop 将不可用。</p>
<p>而以上的写法，可以极大减小锁范围，整个锁的持有时间就是 swap 那一下的时间。待处理函数执行的时候，其他线程还是可以继续调用 queueInLoop。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/01/22/muduo%E7%BD%91%E7%BB%9C%E6%BA%90%E7%A0%81/" data-id="cld6uiojh000dacsf0ck1haub" data-title="" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-muduo日志" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/01/22/muduo%E6%97%A5%E5%BF%97/" class="article-date">
  <time class="dt-published" datetime="2023-01-22T03:54:01.947Z" itemprop="datePublished">2023-01-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="muduo日志"><a href="#muduo日志" class="headerlink" title="muduo日志"></a>muduo日志</h1><p>日志（logging）有两种：</p>
<ul>
<li>诊断日志（diagnostic log） 即log4j等常用日志库提供的日志功能。</li>
<li>交易日志（transaction log） 即数据库的write-ahead log用于记录状态变更， 通过回放日志可以逐步恢复每一次修改之后的状态。</li>
</ul>
<p>本章的日志是前一个意思， 即文本的、 供人阅读的日志， 通常用于故障诊断和追踪（trace），也可用于性能分析。日志通常是分布式<br>系统中事故调查时的唯一线索， 用来追寻蛛丝马迹， 查出元凶。  </p>
<p>对于关键进程， 日志通常要记录：</p>
<ul>
<li>收到的每条内部消息的id（还可以包括关键字段、 长度、 hash等） ；</li>
<li>收到的每条外部消息的全文；</li>
<li>发出的每条消息的全文， 每条消息都有全局唯一的id；</li>
<li>关键内部状态的变更， 等等。</li>
</ul>
<p>每条日志都有时间戳， 这样就能完整追踪分布式系统中一个事件的来龙去脉。 也只有这样才能查清楚发生故障时究竟发生了什么， 比如业务处理流程卡在了哪一步。</p>
<p>一个日志库大体可分为前端（frontend） 和后端（backend） 两部分。 前端是供应用程序使用的接口（API） ， 并生成日志消息（log<br>message） ； 后端则负责把日志消息写到目的地（destination）。   </p>
<p>在多线程程序中， 前端和后端都与单线程程序无甚区别， 无非是每个线程有自己的前端， 整个程序共用一个后端。 但难点在于将日志数据从多个前端高效地传输到后端。 <strong>这是一个典型的多生产者-单消费者问题</strong>， 对生产者（前端） 而言， 要尽量做到低延迟、 低CPU开销、 无阻塞； 对消费者（后端） 而言， 要做到足够大的吞吐量， 并占用较少资源。</p>
<p>对C++程序而言， 最好整个程序（包括主程序和程序库） 都使用相同的日志库， 程序有一个整体的日志输出， 而不要各个组件有各自的日志输出。 从这个意义上讲， 日志库是个singleton。  </p>
<h2 id="功能需求"><a href="#功能需求" class="headerlink" title="功能需求"></a>功能需求</h2><ul>
<li>日志消息有多种级别（ level） ， 如TRACE、 DEBUG、 INFO、WARN、 ERROR、 FATAL等。</li>
<li>日志消息可能有多个目的地（ appender） ， 如文件、 socket、SMTP等。</li>
<li>日志消息的格式可配置（ layout） ， 例如org.apache.log4j.PatternLayout。</li>
<li>可以设置运行时过滤器（ filter） ， 控制不同组件的日志消息的级别和目的地。</li>
</ul>
<p>在上面这几项中， 我认为除了第一项之外， 其余三项都是非必需的功能。  </p>
<p>日志的输出级别在运行时可调， 这样同一个可执行文件可以分别在QA测试环境的时候输出DEBUG级别的日志， 在生产环境输出INFO级<br>别的日志。调整日志的输出级别不需要重新编译， 也不需要重启进程。</p>
<p>对于分布式系统中的服务进程而言， 日志的目的地（ destination）只有一个： 本地文件。 <strong>往网络写日志消息是不靠谱的</strong>， 因为诊断日志的功能之一正是诊断网络故障。往网络写日志消息的另一个坏处是增加网络带宽消耗。</p>
<p>以本地文件为日志的destination， 那么<strong>日志文件的滚动（ rolling）是必需的</strong>， 这样可以简化日志归档的实现。 rolling的条件通常有两个： 文件大小（ 例如每写满1GB就换下一个文件） 和时间（ 例如每天零点新建一个日志文件， 不论前一个文件有没有写满） 。 muduo日志库的LogFile会自动根据文件大小和时间来主动滚动日志文件。</p>
<p>一个典型的日志文件的文件名如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">logfile_test.2012060-144022.hostname.3605.log</span><br></pre></td></tr></table></figure>

<p>文件名由以下几部分组成：  </p>
<ul>
<li>第1部分logfile_test是进程的名字。 通常是main()函数参数中argv[0]的basename(3)， 这样容易区分究竟是哪个服务程序的日志。 必要时还可以把程序版本加进去。</li>
<li>第2部分是文件的创建时间（GMT时区）。这样很容易通过文件名来选择某一时间范围内的日志， 例如用通配符*.20120603-14*表示2012年6月3日下午2点（GMT）左右的日志文件。</li>
<li>第3部分是机器名称。这样即便把日志文件拷贝到别的机器上也能追溯其来源。</li>
<li>第4部分是进程id。如果一个程序一秒之内反复重启， 那么每次都会生成不同的日志文件。</li>
<li>第5部分是统一的后缀名.log。同样是为了便于周边配套脚本的编写。</li>
</ul>
<p><strong>日志文件压缩与归档（archive）不是日志库应有的功能</strong>， 而应该交给专门的脚本去做， 这样C++和Java的服务程序可以共享这一基础设<br>施，并且更改时也不必动业务程序， 改改周边配套脚本就行了。 </p>
<p><strong>磁盘空间监控也不是日志库的必备功能。</strong> 有人或许曾经遇到日志文件把磁盘占满的情况， 因此希望日志库能限制空间使用，例如只分配10GB磁盘空间， 用满之后就冲掉旧日志， 重复利用空间。 殊不知如果出现程序死循环拼命写日志的异常情况， 那么往往是开头的几条日志最关键， 它往往反映了引发异常（busy-loop） 的原因（例如收到某条非法消息） ， 后面都是无用的垃圾日志。</p>
<p>往文件写日志的一个常见问题是， 万一程序崩溃， 那么最后若干条日志往往就丢失了， 因为日志库不能每条消息都flush硬盘， 更不能每条日志都open&#x2F;close文件，这样性能开销太大。 muduo日志库用两个办法来应对这一点， 其一是定期（默认3秒） 将缓冲区内的日志消息flush到硬盘； 其二是每条内存中的日志消息都带有cookie（或者叫哨兵值&#x2F;sentry） ， 其值为某个函数的地址， 这样通过在core dump文件中查找cookie就能找到尚未来得及写入磁盘的消息。</p>
<p>日志消息的格式是固定的， 不需要运行时配置， 这样可节省每条日志解析格式字符串的开销。 我认为日志的格式在项目的整个生命周期几乎不会改变。因为我们经常会为不同目的编写parse日志的脚本，可能要和一年之前的日志文件的同类数据做对比。如果在此期间日志格式变了， 势必会增加很多无谓的工作量。 如果真的需要调整消息格式， 直接修改代码并重新编译即可。</p>
<p>日志消息格式有几个要点：</p>
<ul>
<li>尽量每条日志占一行。 这样很容易用awk、 sed、 grep等命令行工具来快速联机分析日志， 比方说要查看“2012-06-03 08:02:00”至“2012-06-03 08:02:59”这1分钟内每秒打印日志的条数（直方图），可以运行$ grep -o ‘^20120603 08:02:..’ | sort | uniq -c</li>
<li>时间戳精确到微秒。 每条消息都通过gettimeofday(2)获得当前时间， 这么做不会有什么性能损失。 因为在x86-64 Linux上，gettimeofday(2)不是系统调用， 不会陷入内核。</li>
<li>始终使用GMT时区。 对于跨洲的分布式系统而言，可省去本地时区转换的麻烦（别忘了主要西方国家大多实行夏令时），更易于追查事件的顺序。</li>
<li>打印线程id。便于分析多线程程序的时序，也可以检测死锁。这里的线程id是指调用LOG_INFO &lt;&lt;的线程。</li>
<li>打印日志级别。在线查错的时候先看看有无ERROR日志，通常可加速定位问题。</li>
<li>打印源文件名和行号。修复bug的时候不至于搞错对象。</li>
</ul>
<p>muduo日志消息的默认格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">日期      时间      微秒    线程   级别  正文    源文件名:行号</span><br><span class="line">20120603 08:02:46.125770Z 23261 INFO Hello - test.cc:51</span><br></pre></td></tr></table></figure>

<p>每行日志的前4个字段的宽度是固定的， 以空格分隔， 便于用脚本解析。 另外， 应该避免在日志格式（特别是消息id）中出现正则表达<br>式的元字符（meta character） ， 例如’[‘和’]’等等， 这样在用less(1)查看日志文件的时候查找字符串更加便捷。</p>
<p>运行时的日志过滤器（filter） 或许是有用的， 例如控制不同部件（程序库） 的输出日志级别， 但我认为这应该放到编译期去做， 整个程序有一个整体的输出级别就足够好了。 同时我认为一个程序同时写多个日志文件是非常罕见的需求， 这可以事后留给log archiver来分流， 不必做到日志库中。 不实现filter自然也能减小生成每条日志的运行时开销， 可以提高日志库的性能。</p>
<h2 id="性能需求"><a href="#性能需求" class="headerlink" title="性能需求"></a>性能需求</h2><p>高效性体现在几方面：</p>
<ul>
<li>每秒写几千上万条日志的时候没有明显的性能损失。</li>
<li>能应对一个进程产生大量日志数据的场景， 例如1GB&#x2F;min。</li>
<li>不阻塞正常的执行流程。</li>
<li>在多线程程序中， 不造成争用（contention） 。 这里列举一些具体的性能指标， 考虑往普通7200rpm SATA硬盘写日志文件的情况：磁盘带宽约是110MB&#x2F;s， 日志库应该能瞬时写满这个带宽（不必持续太久） 。</li>
</ul>
<p>以上是“高性能”日志库的最低指标。 如果磁盘带宽更高， 那么日志库的预期性能指标也会相应提高。  </p>
<p>muduo日志库在现在的PC上能写到每秒200万条消息， 带宽足够撑满两个千兆网连接或4个SATA组成的RAID10， 性能是达标的。<br>为了实现这样的性能指标， muduo日志库的实现有几点优化措施值得一提：</p>
<ul>
<li>时间戳字符串中的日期和时间两部分是缓存的， 一秒之内的多条日志只需重新格式化微秒部分。 </li>
<li>日志消息的前4个字段是定长的， 因此可以避免在运行期求字符串长度（不会反复调用strlen） 。 因为编译器认识memcpy()函数， 对于定长的内存复制， 会在编译期把它inline展开为高效的目标代码。</li>
<li>线程id是预先格式化为字符串， 在输出日志消息时只需简单拷贝几个字节。 见CurrentThread::tidString()。</li>
<li>每行日志消息的源文件名部分采用了编译期计算来获得basename， 避免运行期strrchr(3)开销。 见SourceFile class， 这里利用了gcc的内置函数。</li>
</ul>
<h2 id="多线程异步日志"><a href="#多线程异步日志" class="headerlink" title="多线程异步日志"></a>多线程异步日志</h2><p>线程安全的多线程日志的解决思路</p>
<ul>
<li>用一个全局锁保护IO，或者每个线程单独写一个日志文件。性能堪忧，前者造成所有线程抢占一个锁，后者会让业务线程阻塞在写磁盘操作上</li>
<li>每个进程只写一个日志文件，用一个背景线程负责收集日志消息，并写入日志文件，其他业务线程只需往这个日志线程中发送日志消息，称为“异步日志”(本文采用)</li>
</ul>
<p>在多线程服务程序中， 异步日志是必需的， 因为如果在网络IO线程或业务线程中直接往磁盘写数据的话，写操作偶尔可能阻塞长达数秒之久（原因很复杂， 可能是磁盘或磁盘控制器复位）。这可能导致请求方超时， 或者耽误发送心跳消息， 在分布式系统中更可能造成多米诺骨牌效应， 例如误报死锁引发自动failover等。 <strong>因此， 在正常的实时业务处理流程中应该彻底避免磁盘IO</strong>， 这在使用one loop per thread模型的非阻塞服务端程序中尤为重要， 因为线程是复用的， 阻塞线程意味着影响多个客户连接。</p>
<p>我们需要一个“队列”来将日志前端的数据传送到后端（日志线程） ， 但这个“队列”不必是现成的BlockingQueue&lt;std::string&gt;， 因为不<br>用每次产生一条日志消息都通知（notify()） 接收方。</p>
<p><strong>muduo日志库采用的是双缓冲（double buffering） 技术</strong>， 基本思路是准备两块buffer： A和B， 前端负责往buffer A填数据（日志消<br>息） ， 后端负责将buffer B的数据写入文件。 当buffer A写满之后， 交换A和B， 让后端将buffer A的数据写入文件， 而前端则往buffer B填入新的日志消息， 如此往复。   </p>
<p>用两个buffer的好处是在新建日志消息的时候不必等待磁盘文件操作， 也避免每条新日志消息都触发（唤醒） 后端日志线程。 换言之， 前端不是将一条条日志消息分别传送给后端， 而是将多条日志消息拼成一个大的buffer传送给后端， 相当于批处理， 减少了线程唤醒的频度， 降低开销。 另外， 为了及时将日志消息写入文件， 即便buffer A未满， 日志库也会每3秒执行一次上述交换写入操作。  </p>
<h2 id="实现细节"><a href="#实现细节" class="headerlink" title="实现细节"></a>实现细节</h2><p>Muduo日志的代码由 Logging.h&#x2F;cc, LogStream.h&#x2F;cc , LogFile.h&#x2F;cc , AsyncLogging.h&#x2F;cc 这四对组成。把整体分为三个模块来考虑：日志生成、多线程日志传递、日志打印。</p>
<h3 id="日志生成"><a href="#日志生成" class="headerlink" title="日志生成"></a>日志生成</h3><p>这一模块要做的工作就是接收用户的信息，将其与日志格式内的其他信息（日期、时间、线程、行号等）进行拼接组合，形成一条字符串，这个字符串就是最后要输出的日志。</p>
<h4 id="预定义宏"><a href="#预定义宏" class="headerlink" title="预定义宏"></a>预定义宏</h4><p>这部分由 Logging.h&#x2F;cc 以及 LogStream.h&#x2F;cc 组合完成。首先外部代码对日志库所有的访问入口都是通过定义好的宏来：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//define后接if，可以在满足if的条件时才进行宏定义。\是换行符</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOG_TRACE <span class="keyword">if</span> (muduo::Logger::logLevel() &lt;= muduo::Logger::TRACE) \</span></span><br><span class="line"><span class="meta">  muduo::Logger(__FILE__, __LINE__, muduo::Logger::TRACE, __func__).stream()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOG_DEBUG <span class="keyword">if</span> (muduo::Logger::logLevel() &lt;= muduo::Logger::DEBUG) \</span></span><br><span class="line"><span class="meta">  muduo::Logger(__FILE__, __LINE__, muduo::Logger::DEBUG, __func__).stream()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOG_INFO <span class="keyword">if</span> (muduo::Logger::logLevel() &lt;= muduo::Logger::INFO) \</span></span><br><span class="line"><span class="meta">  muduo::Logger(__FILE__, __LINE__).stream()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOG_WARN muduo::Logger(__FILE__, __LINE__, muduo::Logger::WARN).stream()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOG_ERROR muduo::Logger(__FILE__, __LINE__, muduo::Logger::ERROR).stream()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOG_FATAL muduo::Logger(__FILE__, __LINE__, muduo::Logger::FATAL).stream()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOG_SYSERR muduo::Logger(__FILE__, __LINE__, false).stream()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOG_SYSFATAL muduo::Logger(__FILE__, __LINE__, true).stream()</span></span><br></pre></td></tr></table></figure>

<p><strong>__FILE__，__LINE__是预定义宏，目的是获取文件名和行号</strong></p>
<p>标准C语言预处理要求定义某些对象宏，每个预定义宏的名称一两个下划线字符开头和结尾，这些预定义宏不能被取消定义（#undef）或由编程人员重新定义。</p>
<p>__LINE__  ：当前程序行的行号，表示为十进制整型常量<br>__FILE__  ：当前源文件名，表示字符串型常量<br>__DATE__ ：转换的日历日期，表示为Mmm dd yyyy 形式的字符串常量，Mmm是由asctime产生的。<br>__TIME__  ：转换的时间，表示”hh:mm:ss”形式的字符串型常量，是有asctime产生的。（asctime貌似是指的一个函数）<br>__STDC__ ：编辑器为ISO兼容实现时位十进制整型常量<br>__STDC_VERSION__  ：如何实现复合C89整部1，则这个宏的值为19940SL；如果实现符合C99，则这个宏的值为199901L；否则数值是未定义<br>__STDC_EOBTED__ ：(C99)实现为宿主实现时为1,实现为独立实现为0<br>__STDC_IEC_559__ ：(C99)浮点数实现复合IBC 60559标准时定义为1，否者数值是未定义<br>__STDC_IEC_559_COMPLEX__： (C99)复数运算实现复合IBC 60559标准时定义为1，否者数值是未定义<br>__STDC_ISO_10646__ ：(C99)定义为长整型常量，yyyymmL表示wchar_t值复合ISO 10646标准及其指定年月的修订补充，否则数值未定义<br>C++中还定义了 __cplusplus用来定义是否是C++编译器。<br><strong>另外 gcc还支持__func__,和__FUNCTION__</strong>,它指示所在的函数名，但是这个关键字不被windows下的vc6.0支持</p>
<p><strong>gcc还使用 __thread宏作为内置的线程局部存储设施</strong>，存取效率可以和全局变量相比，它只能修饰POD类型。**__thread变量每一个线程有一份独立实体**，各个线程的值互不干扰，可以用来修饰那些带有全局性且值可能变，但是又不值得用全局变量保护的变量。</p>
<p><strong>我们以 LOG_INFO 为例</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LOG_INFO &lt;&lt; &quot;This is a log.&quot;展开后如下</span></span><br><span class="line">muduo::<span class="built_in">Logger</span>(__FILE__, __LINE__).<span class="built_in">stream</span>() &lt;&lt; <span class="string">&quot;This is a log.&quot;</span></span><br></pre></td></tr></table></figure>

<p>将这句话放在日志打印的地方意味着什么呢？</p>
<ol>
<li>创建一个 Logger(<strong>FILE</strong>, <strong>LINE</strong>) 的匿名对象；</li>
<li>调用这个匿名对象的 stream() 成员函数；</li>
<li>调用重载后的 « 操作符，输入日志信息；</li>
<li>析构该匿名对象，析构函数内会调用真正的output日志信息函数。</li>
</ol>
<p>注意，匿名对象的析构发生在该条语句结束后，实际上在实现上，前3步的目的是整合拼接一条完整的日志信息，实际的日志打印动作就发生在第4步析构上。</p>
<blockquote>
<p>匿名对象一般会在语句结束后就析构，但如果用匿名对象初始化另外一个同类型的对象，匿名对象转成有名对象，此时匿名对象生命周期变成有名对象的生命周期，不会立即析构</p>
<p>用匿名对象赋值给另外一个同类型的对象，匿名对象在语句结束后被析构</p>
</blockquote>
<h4 id="相关类的代码"><a href="#相关类的代码" class="headerlink" title="相关类的代码"></a>相关类的代码</h4><h5 id="Logger"><a href="#Logger" class="headerlink" title="Logger"></a>Logger</h5><p>下面给出 Logger 类的整体结构：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Logger</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 定义 LogLevel 枚举类型，注意最后会定义一个NUM_LOG_LEVELS，这是为了方便创建枚举数组</span></span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">LogLevel</span> &#123;</span><br><span class="line">        TRACE,</span><br><span class="line">        ...</span><br><span class="line">        NUM_LOG_LEVELS</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// SourceFile作用是编译期间从 __FILE__ 中获取文件basename，FILE宏是源文件路径，如/home/test.cpp，记录日志嫌长，代码中用strrchr截取最后一个/后面的名称。在编译时计算的原理是GCC的strrchr()对于字符串字面量可以在编译期求值。</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">SourceFile</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="built_in">Logger</span>(...);</span><br><span class="line">    <span class="function">LogStream&amp; <span class="title">stream</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> impl_.stream_;&#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// Impl 类封装了Logger私有的变量和函数，如文件名，行号，日志等级等等。</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Impl</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    Impl impl_;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，整个 Logger 类主要由 3 个部分组成，分别是枚举类型的LogLevel，获取文件basename的SourceFile类，私有的Impl类。</p>
<p>我们从构造函数入手：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Logger::<span class="built_in">Logger</span>(SourceFile file, <span class="type">int</span> line)</span><br><span class="line">  : <span class="built_in">impl_</span>(INFO, <span class="number">0</span>, file, line)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>初始化一个 Logger 其实是初始化它的 Impl 内部对象，Logger对外的构造函数有很多，但内部类的构造函数只有一种，Logger不同的构造函数调用了相同的Impl的构造函数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Logger::Impl::<span class="built_in">Impl</span>(LogLevel level, <span class="type">int</span> savedErrno, <span class="type">const</span> SourceFile&amp; file, <span class="type">int</span> line)</span><br><span class="line">  : <span class="built_in">time_</span>(Timestamp::<span class="built_in">now</span>()),</span><br><span class="line">    <span class="built_in">stream_</span>(),</span><br><span class="line">    <span class="built_in">level_</span>(level),</span><br><span class="line">    <span class="built_in">line_</span>(line),</span><br><span class="line">    <span class="built_in">basename_</span>(file)</span><br><span class="line">&#123;</span><br><span class="line">  formatTime();</span><br><span class="line">  CurrentThread::<span class="built_in">tid</span>();</span><br><span class="line">  stream_ &lt;&lt; <span class="built_in">T</span>(CurrentThread::<span class="built_in">tidString</span>(), CurrentThread::<span class="built_in">tidStringLength</span>()); <span class="comment">// T 类是helper class for known string length at compile time，把字符串和字符串的长度整合</span></span><br><span class="line">  stream_ &lt;&lt; <span class="built_in">T</span>(LogLevelName[level], <span class="number">6</span>);</span><br><span class="line">  <span class="keyword">if</span> (savedErrno != <span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    stream_ &lt;&lt; <span class="built_in">strerror_tl</span>(savedErrno) &lt;&lt; <span class="string">&quot; (errno=&quot;</span> &lt;&lt; savedErrno &lt;&lt; <span class="string">&quot;) &quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在构造过程中，首先通过 formatTime() 获取当前时间，并将时间格式化成年月日分秒微秒的形式，然后传递给 stream对象（输出到stream的缓冲区），接着将线程id和日志等级输出到stream缓冲区。</p>
<blockquote>
<p><strong>TIP:</strong> 对于一个时间信息： 20180426 14:50:34.345346Z，会将每次打印日志的时间中年月日秒的部分缓存在t_time[64] 这个变量里，同时还单独缓存了每次打印日志的时间中秒的部分，打印日志时会判断跟上次打印日志是不是同一秒，如果是同一秒则直接用缓存的信息，而不需要再重新获取时间并格式化。也就是说，同1s内打印的日志，只有微秒部分是需要被格式化的。这是为了提高性能，因为格式化非常耗时。</p>
</blockquote>
<p>构造完成后会将调用Logger的stream()函数返回stream，然后调用stream的&lt;&lt;运算符函数将要记录的日志输出到stream缓冲区，如LOG_INFO &lt;&lt; “This is a log.”中的”This is a log.”</p>
<p>最后看下析构 Logger 这个匿名对象会发生什么事。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Logger::~<span class="built_in">Logger</span>()</span><br><span class="line">&#123;</span><br><span class="line">  impl_.<span class="built_in">finish</span>();</span><br><span class="line">  <span class="function"><span class="type">const</span> LogStream::Buffer&amp; <span class="title">buf</span><span class="params">(stream().buffer())</span></span>;</span><br><span class="line">  <span class="built_in">g_output</span>(buf.<span class="built_in">data</span>(), buf.<span class="built_in">length</span>());  <span class="comment">// 日志输出函数，可设置</span></span><br><span class="line">  <span class="keyword">if</span> (impl_.level_ == FATAL) </span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">g_flush</span>();  <span class="comment">// 日志flush 函数，可设置</span></span><br><span class="line">    <span class="built_in">abort</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>finish函数会把文件名和行号输出到stream缓冲区，接着析构函数会调用 g_output() 将stream缓冲区的日志输出(默认输出到stdout，如果需要输出到日志文件中需要在使用前设置output函数)。</p>
<p>这样就完成了一条日志语句的生成，最后生成的日志格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">日期      时间      微秒    线程   级别  正文    源文件名:行号</span><br><span class="line">20120603 08:02:46.125770Z 23261 INFO Hello - test.cc:51</span><br></pre></td></tr></table></figure>

<h5 id="LogStream"><a href="#LogStream" class="headerlink" title="LogStream"></a>LogStream</h5><p>LogStream是muduo自己实现的流，不用iostream是因为iostream的效率低 </p>
<p>相关类的结构为：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LogStream</span> &#123;</span><br><span class="line">    <span class="keyword">typedef</span> detail::FixedBuffer&lt;detail::kSmallBuffer&gt; Buffer;</span><br><span class="line">    Buffer buffer_;</span><br><span class="line">     </span><br><span class="line">    self&amp; <span class="keyword">operator</span>&lt;&lt;(<span class="type">const</span> string&amp; v);</span><br><span class="line">    self&amp; <span class="keyword">operator</span>&lt;&lt;(...);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span>&lt;<span class="type">int</span> SIZE&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FixedBuffer</span> &#123;</span><br><span class="line">    <span class="type">char</span> data_[SIZE];</span><br><span class="line">    <span class="type">char</span>* cur_;   <span class="comment">// cur_ 指针指向data_数组中有效数据的尾部。</span></span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">append</span><span class="params">(...)</span></span>;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="type">const</span> <span class="type">char</span>* <span class="title">data</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> data_;&#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">length</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(cur_-data_);&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>LogStream</code>在构造过程中，会初始化一个 <code>FixedBuffer</code> 对象，其中又初始化一个<code>char</code>数组（大小为预先定义的 <code>kSmallBuffer : 4k</code>）。 然后通过重载的操作符，将信息写入到这个数组中。其中<code>Buffer</code>对象提供 <code>data()</code> 和 <code>length()</code> 接口供<code>Logger</code>类使用。</p>
<p>可以看到<code>Buffer</code>提供的<code>append()</code>接口入参是<code>const char* buf, size_t len</code>，然后内部通过 <code>memcpy</code> 来复制字符串。</p>
<blockquote>
<p><strong>TIP:</strong> 回顾 Logger，日志信息的固定格式都为定长的，通过 T 传入stream，这样就直接通过memcpy来拷贝，避免了每次通过 strlen 来获取字符串长度，提高了效率</p>
</blockquote>
<h3 id="多线程日志传递"><a href="#多线程日志传递" class="headerlink" title="多线程日志传递"></a>多线程日志传递</h3><h4 id="AsyncLogging"><a href="#AsyncLogging" class="headerlink" title="AsyncLogging"></a>AsyncLogging</h4><p>我们可以很容易的抽象出来一个异步日志库的模式：N个业务线程通过接口将日志信息推送到一个结构内；1 个日志打印线程从这个结构中顺序地打印日志到文件中。这是因为将数据存储到磁盘很耗费时间，所以应该有单独的后台线程来做这件事情，不能阻塞前台线程的运行。</p>
<p>这是一个很典型的多生产者、单消费者场景。这种场景考虑的点无非就三个方向</p>
<ol>
<li>生产者吞吐能力；</li>
<li>生产者消费者如何高效传递数据；</li>
<li>消费者吞吐能力。</li>
</ol>
<p>Muduo这部分的内容在 AsyncLogging.h&#x2F;cc 中。下面给出 AsyncLogging 类的大体结构。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">AsyncLogging</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">AsyncLogging</span>(...);</span><br><span class="line">    ~<span class="built_in">AsyncLogging</span>() &#123; ..<span class="built_in">stop</span>()..&#125;;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">append</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* logline, <span class="type">int</span> len)</span></span>;  <span class="comment">// 供 Logger 注册的接口</span></span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">start</span><span class="params">()</span></span>;  <span class="comment">// 启动线程</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">stop</span><span class="params">()</span></span>;   <span class="comment">// 关闭线程</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">threadFunc</span><span class="params">()</span></span>;  <span class="comment">// 异步线程处理逻辑</span></span><br><span class="line"> </span><br><span class="line">    BufferPtr  currentBuffer_;  <span class="comment">// 当前写入的 buffer</span></span><br><span class="line">    BufferPtr  nextBuffer_;     <span class="comment">// 下一个备用 buffer</span></span><br><span class="line">    BufferVector  buffers_;     <span class="comment">// 写入完毕，待打印的 buffer 集合</span></span><br></pre></td></tr></table></figure>

<p>多线程使用AsyncLogging需要一个共享的AsyncLogging对象(单例或全局变量)，并在使用前设置Logger类的output类函数，将函数设置为调用AsyncLogging的append函数将生成的日志存入AsyncLogging的缓冲区。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">asyncOutput</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* msg, <span class="type">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  g_asyncLog-&gt;<span class="built_in">append</span>(msg, len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">muduo::Logger::<span class="built_in">setOutput</span>(asyncOutput);</span><br></pre></td></tr></table></figure>

<p>AsyncLogging的重点是 append 和 threadFunc 函数，前者负责收集业务线程发来的日志消息存储到buffer中，后者是单独的线程，它负责调控 buffer，并调用Logfile将buffer的日志存入到文件中。</p>
<p>我们称 append 为前台，threadFunc 后台，Muduo logging 的思想为，前台、后台分别 持有 2 个 buffer 和一个 buffervector，buffer暂时缓存写入的日志，buffervector则是存放即将打印的buffer。前台写满一个buffer后，放入它的buffervector，并通知后台，后台来处理buffer的交换和填充。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">AsyncLogging::append</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* logline, <span class="type">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">muduo::MutexLockGuard <span class="title">lock</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (currentBuffer_-&gt;<span class="built_in">avail</span>() &gt; len)&#123;       <span class="comment">// 当前buffer空间够,直接将日志写入</span></span><br><span class="line">        currentBuffer_-&gt;<span class="built_in">append</span>(logline, len); </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        buffers_.<span class="built_in">push_back</span>(currentBuffer_.<span class="built_in">release</span>());       <span class="comment">// buffer空间不够，代表该buffer已满，该打印了，放入vector</span></span><br><span class="line">        <span class="keyword">if</span> (nextBuffer_)&#123;       <span class="comment">// currentBuffer_放入vector后，若nextBuffer_ 不为空，将nextBuffer_转移给currentBuffer_</span></span><br><span class="line">        currentBuffer_ = boost::ptr_container::<span class="built_in">move</span>(nextBuffer_);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;  <span class="comment">// 没有可用 buffer，当短时间之内要输出的日志太多，消费者来不及消费时发生，直接new 一个给currentBuffer_</span></span><br><span class="line">        currentBuffer_.<span class="built_in">reset</span>(<span class="keyword">new</span> Buffer);</span><br><span class="line">        &#125;</span><br><span class="line">        currentBuffer_-&gt;<span class="built_in">append</span>(logline, len);</span><br><span class="line">        cond_.<span class="built_in">notify</span>();   <span class="comment">// 通知后台事件发生，vector不为空，可以取数据打印</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里还少了的逻辑就是何时 next_buffer 会被填充。看 threadFunc() 的代码:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">AsyncLogging::threadFunc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">BufferPtr <span class="title">newBuffer1</span><span class="params">(<span class="keyword">new</span> Buffer)</span></span>;</span><br><span class="line">    <span class="function">BufferPtr <span class="title">newBuffer2</span><span class="params">(<span class="keyword">new</span> Buffer)</span></span>;</span><br><span class="line">    BufferVector buffersToWrite;</span><br><span class="line">	<span class="function">LogFile <span class="title">output</span><span class="params">(basename_, rollSize_, <span class="literal">false</span>)</span></span>;</span><br><span class="line">    <span class="keyword">while</span> (running_) &#123;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function">muduo::MutexLockGuard <span class="title">lock</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">            <span class="keyword">if</span> (buffers_.<span class="built_in">empty</span>())  <span class="comment">// vector为空则等待，需要注意这是if不是while，这是为了每隔一个flush间隔就打印一次</span></span><br><span class="line">            &#123;</span><br><span class="line">                cond_.<span class="built_in">waitForSeconds</span>(flushInterval_);  <span class="comment">// 条件变量，等一个flush间隔或者前台唤醒(buffer满时)</span></span><br><span class="line">            &#125;</span><br><span class="line">            buffers_.<span class="built_in">push_back</span>(std::<span class="built_in">move</span>(currentBuffer_));  <span class="comment">// 把当前在写的 buffer 也放到vector中</span></span><br><span class="line">            currentBuffer_ = std::<span class="built_in">move</span>(newBuffer1);  <span class="comment">// 把 newbuffer1 移交给 currBuffer</span></span><br><span class="line">            buffersToWrite.<span class="built_in">swap</span>(buffers_);   <span class="comment">// 将vector和空的后台vector进行交换，相当于将vector中的数据先进行转移再处理，这是为了减少临界区的时间。若直接用vector打印，那么在取数据的时候，append无法将数据添加到vector中</span></span><br><span class="line">            <span class="keyword">if</span> (!nextBuffer_)&#123;   <span class="comment">// 若nextBuffer为空，移交 newbuffer2 给前台 nextBuffer</span></span><br><span class="line">                nextBuffer_ = std::<span class="built_in">move</span>(newBuffer2);;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (buffersToWrite.<span class="built_in">size</span>() &gt; <span class="number">25</span>) <span class="comment">//堆积的日志过多时直接丢弃，只保留前面两块缓冲区的日志</span></span><br><span class="line">    	&#123;</span><br><span class="line">      		<span class="type">char</span> buf[<span class="number">256</span>];</span><br><span class="line">      		<span class="built_in">snprintf</span>(buf, <span class="keyword">sizeof</span> buf, <span class="string">&quot;Dropped log messages at %s, %zd larger buffers\n&quot;</span>,</span><br><span class="line">               	Timestamp::<span class="built_in">now</span>().<span class="built_in">toFormattedString</span>().<span class="built_in">c_str</span>(),</span><br><span class="line">               	buffersToWrite.<span class="built_in">size</span>()<span class="number">-2</span>);</span><br><span class="line">      		<span class="built_in">fputs</span>(buf, stderr);</span><br><span class="line">      		output.<span class="built_in">append</span>(buf, <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(<span class="built_in">strlen</span>(buf)));</span><br><span class="line">      		buffersToWrite.<span class="built_in">erase</span>(buffersToWrite.<span class="built_in">begin</span>()+<span class="number">2</span>, buffersToWrite.<span class="built_in">end</span>());</span><br><span class="line">    	&#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; buffer : buffersToWrite)</span><br><span class="line">    	&#123;</span><br><span class="line">      		output.<span class="built_in">append</span>(buffer-&gt;<span class="built_in">data</span>(), buffer-&gt;<span class="built_in">length</span>()); <span class="comment">//将vector中的每个buffer调用Logfile输出</span></span><br><span class="line">    	&#125;</span><br><span class="line">        <span class="keyword">if</span> (!newBuffer1)&#123;</span><br><span class="line">      		newBuffer1 = std::<span class="built_in">move</span>(buffersToWrite.<span class="built_in">back</span>()); <span class="comment">//输出完的buffer还给newBuffer1，重复利用buffer，避免重新申请空间</span></span><br><span class="line">      		buffersToWrite.<span class="built_in">pop_back</span>();</span><br><span class="line">      		newBuffer1-&gt;<span class="built_in">reset</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!newBuffer2)&#123;</span><br><span class="line">            newBuffer2 = buffersToWrite.<span class="built_in">pop_back</span>(); <span class="comment">//输出完的buffer还给newBuffer2，重复利用buffer，避免重新申请空间</span></span><br><span class="line">            newBuffer2-&gt;<span class="built_in">reset</span>();</span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到AsyncLogging一共有4个buffer，前台生产者两个，后台消费者两个，前台正常情况下最多能同时写满两个buffer，若日志生产过多消费者速度跟不上时会直接申请空间作为新的buffer。后台两个buffer是作为前台buffer的备用，后台在从前台buffer取数据时会将后台空的buffer给前台使用，而前台的buffer取完数据之后就放在后台作为备用，这样就把4个buffer循环利用起来了。</p>
<p><strong>如果日志堆积过多时会直接丢弃后面的日志</strong>，只保留前面两个缓冲区的日志。</p>
<p><strong>值得一提的是这里大量使用了交换指针的技巧来避免生产者和消费者之间的竞争</strong>，消费者在从buffer取数据时不会直接取出，而是先将buffer的指针跟空的buffer进行交换，再取出数据，这样消费者在取数据的同时还不影响生产者的生产，减少了临界区的竞争。</p>
<h3 id="日志打印"><a href="#日志打印" class="headerlink" title="日志打印"></a>日志打印</h3><p>使用是 fwrite_unlocked()(因为是单独的线程负责打印，不涉及到多线程，所以不需要加锁) 和 fflush() 接口。</p>
<p>打印时会记录打印的数据大小和时间，以便于日志滚动。日志滚动会自动根据文件大小和时间来主动生成新的日志文件。</p>
<h2 id="其他方案"><a href="#其他方案" class="headerlink" title="其他方案"></a>其他方案</h2><p>当然在前端和后端之间高效传递日志消息的办法不止这一种， <strong>比方说使用常规的消息队列</strong>BlockingQueue&lt;std::string&gt;在前后端之间传递日志消息， 其中每个std::string是一条消息。 这种做法每条日志消息都要分配内存， 特别是在前端线程分配的内存要由后端线程释放， 因此对malloc的实现要求较高， 需要针对多线程特别优化。 另外， 如果用这种方案， 那么需要修改LogStream的Buffer， 使之直接将日志写到std::string中， 可节省一次内存拷贝。</p>
<p>muduo现在的异步日志实现用了一个全局锁。 尽管临界区很小， 但是如果线程数目较多， 锁争用（lock contention） 也可能影响性能。 <strong>一种解决办法是像Java的ConcurrentHashMap那样用多个桶子（bucket） ， 前端写日志的时候再按线程id哈希到不同的bucket中</strong>， 以减少锁的争用。这种方案的后端实现较为复杂。为了简化实现， 目前muduo日志库只允许指定日志文件的名字， 不允许指定其路径。 日志库会把日志文件写到当前路径， 因此可以在启动脚本（shell脚本）里改变当前路径， 以达到相同的目的。Linux默认会把core dump写到当前目录， 而且文件名是固定的core。 <strong>为了不让新的core dump文件冲掉旧的， 我们可以通过sysctl设置kernel.core_pattern参数</strong>（也可以修改 ） ， 让每次core dump都产生不同的文件。 例如设为%e.%t.%p.%u.core， 其中各个<br>参数的意义见man 5 core。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>与Log相关的类包括FileUtil、LogFile、AsyncLogging、LogStream、Logging。 其中前4个类每一个类都含有一个append函数，Log的设计也是主要围绕这个<strong>append</strong>函数展开的。</p>
<ul>
<li>FileUtil是最底层的文件类，封装了Log文件的打开、写入并在类析构的时候关闭文件，底层使用了标准IO，该append函数直接向文件写。</li>
<li>LogFile进一步封装了FileUtil，并设置了一个循环次数，每过这么多次就flush一次。</li>
<li>AsyncLogging是核心，它负责启动一个log线程，专门用来将log写入LogFile，应用了“双缓冲技术”，其实有4个以上的缓冲区，但思想是一样的。AsyncLogging负责(定时到或被填满时)将缓冲区中的数据写入LogFile中。</li>
<li>LogStream主要用来格式化输出，重载了&lt;&lt;运算符，同时也有自己的一块缓冲区，这里缓冲区的存在是为了缓存一行，把多个&lt;&lt;的结果连成一块。</li>
<li>Logging是对外接口，Logging类内涵一个LogStream对象，主要是为了每次打log的时候在log之前和之后加上固定的格式化的信息，比如打log的行、文件名等信息。</li>
</ul>
<h2 id="实现中用到的技术"><a href="#实现中用到的技术" class="headerlink" title="实现中用到的技术"></a>实现中用到的技术</h2><p>1.用枚举表示日志级别，有限种类的物品都可以用枚举表示；枚举中最后一个变量设置为NUM_LOG_LEVELS，这是为了方便创建数组，代码中最好不要直接出现数字，可以将数字代替为变量，这样方便后续修改。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">LogLevel</span></span><br><span class="line">&#123;</span><br><span class="line">  TRACE,</span><br><span class="line">  DEBUG,</span><br><span class="line">  INFO,</span><br><span class="line">  WARN,</span><br><span class="line">  ERROR,</span><br><span class="line">  FATAL,</span><br><span class="line">  NUM_LOG_LEVELS,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* LogLevelName[Logger::NUM_LOG_LEVELS] =</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;TRACE &quot;</span>,</span><br><span class="line">  <span class="string">&quot;DEBUG &quot;</span>,</span><br><span class="line">  <span class="string">&quot;INFO  &quot;</span>,</span><br><span class="line">  <span class="string">&quot;WARN  &quot;</span>,</span><br><span class="line">  <span class="string">&quot;ERROR &quot;</span>,</span><br><span class="line">  <span class="string">&quot;FATAL &quot;</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>2.使用宏定义将创建匿名对象并调用函数的过程简化，简化了接口，方便用户使用。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> LOG_TRACE <span class="keyword">if</span> (muduo::Logger::logLevel() &lt;= muduo::Logger::TRACE) \</span></span><br><span class="line"><span class="meta">  muduo::Logger(__FILE__, __LINE__, muduo::Logger::TRACE, __func__).stream()</span></span><br></pre></td></tr></table></figure>

<p>3.使用预定义宏__FILE__，__LINE__等，方便的获取文件名和行号。</p>
<p>4.在编译期计算文件的basename，原理还需研究。</p>
<p>5.使用了内部类，适合什么场景使用还需研究。</p>
<p>6.使用getenv()获取环境变量进行初始化。</p>
<p>7.比较复杂的类型或者需要改名方便看出用途的类型，用typedef或using来简化。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> muduo::detail::FixedBuffer&lt;muduo::detail::kLargeBuffer&gt; Buffer;</span><br><span class="line"><span class="keyword">typedef</span> std::vector&lt;std::unique_ptr&lt;Buffer&gt;&gt; BufferVector;</span><br><span class="line"><span class="keyword">typedef</span> BufferVector::value_type BufferPtr;</span><br></pre></td></tr></table></figure>

<p>8.使用clang的注解进行检查，防止出错，具体参考clang线程安全注解文档。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">muduo::Condition cond_ <span class="title">GUARDED_BY</span><span class="params">(mutex_)</span></span>;</span><br><span class="line"><span class="function">BufferPtr currentBuffer_ <span class="title">GUARDED_BY</span><span class="params">(mutex_)</span></span>;</span><br><span class="line"><span class="function">BufferPtr nextBuffer_ <span class="title">GUARDED_BY</span><span class="params">(mutex_)</span></span>;</span><br><span class="line"><span class="function">BufferVector buffers_ <span class="title">GUARDED_BY</span><span class="params">(mutex_)</span></span>;</span><br></pre></td></tr></table></figure>

<p>9.线程析构前先join。</p>
<p>10.在vector中用unique_ptr保存变量，这样做的好处是保证存储的变量只有一份，而且外界传入时必须使用std::move()，这样会调用移动构造函数提高效率。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;std::unique_ptr&lt;Buffer&gt;&gt; BufferVector;</span><br></pre></td></tr></table></figure>

<p>11.在使用缓冲区前，先调用bzero函数初始化缓冲区为0。</p>
<p>12.使用static_cast和implicit_cast进行类型转换，保证类型转换的安全性。</p>
<p>13.不使用可重入锁，而使用不可重入锁+一个函数分为加锁版和无锁版。</p>
<p>14.使用全局变量和全局函数时，在前面加上::</p>
<p>15.使用main函数的arcv[0]获取文件名</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//argv是参数数组，其中argv[0]存储了文件的全名(包括路径)，argc是数组中变量的个数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">strncpy</span>(name, argv[<span class="number">0</span>], <span class="keyword">sizeof</span> name - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>16.使用和空变量交换的方式来处理生产者和消费者之间的共享变量，这样可以有效减少竞争</p>
<p><strong>实现中涉及的函数</strong></p>
<ul>
<li><p>fflush()，C 库函数 <strong>int fflush(FILE *stream)</strong> 刷新流 stream 的输出缓冲区。</p>
</li>
<li><p>fwrite()，C 库函数 <strong>size_t fwrite(const void *ptr, size_t size, size_t nmemb, FILE *stream)</strong> 把 <strong>ptr</strong> 所指向的数组中的数据写入到给定流 <strong>stream</strong> 中。</p>
</li>
<li><p>sprintf()，C 库函数 <strong>int sprintf(char *str, const char *format, …)</strong> 发送格式化输出到 <strong>str</strong> 所指向的字符串。</p>
</li>
<li><p>getenv()，C 库函数 <strong>char *getenv(const char *name)</strong> 搜索 name 所指向的环境字符串，并返回相关的值给字符串。</p>
</li>
<li><p>strrchr()，C 库函数 <strong>char *strrchr(const char *str, int c)</strong> 在参数 <strong>str</strong> 所指向的字符串中搜索最后一次出现字符 <strong>c</strong>（一个无符号字符）的位置。</p>
</li>
<li><p>vector.reserve()，用于初始化vector的大小；vector.resize()函数用于修改vector的大小，若修改后更小，会删除后面多出的元素。</p>
<p>reserve是容器预留空间，但并不真正创建元素对象，在创建对象之前，不能引用容器内的元素，因此当加入新的元素时，需要用push_back()&#x2F;insert()函数。</p>
<p>resize是改变容器的大小，并且创建对象，因此，调用这个函数之后，就可以引用容器内的对象了，因此当加入新的元素时，用operator[]操作符，或者用迭代器来引用元素对象。</p>
</li>
</ul>
<p><strong>为了实现性能指标，本日志设计中几点优化：</strong></p>
<ul>
<li>时间戳字符串中的日期和时间两部分是缓存的,一秒之内的多条日志只需格式化微妙即可</li>
<li>日志消息的前四段是定长的,可避免运行时字串长度的计算</li>
<li>线程id是预先格式化的字符串</li>
<li>原文件名部分通过编译期计算来获得,避免运行期strrchr()的开销</li>
<li>单独的io线程负责持久化日志数据到磁盘，工作线程只将日志写入缓冲区，这样不会影响工作线程的效率</li>
<li>使用多缓冲设计，有效提高效率</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/01/22/muduo%E6%97%A5%E5%BF%97/" data-id="cld6uioj70008acsf08xjb1ip" data-title="" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-Linux多线程服务端编程：使用muduo C++网络库" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/01/22/Linux%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%9C%8D%E5%8A%A1%E7%AB%AF%E7%BC%96%E7%A8%8B%EF%BC%9A%E4%BD%BF%E7%94%A8muduo%20C++%E7%BD%91%E7%BB%9C%E5%BA%93/" class="article-date">
  <time class="dt-published" datetime="2023-01-22T03:54:01.944Z" itemprop="datePublished">2023-01-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="Linux多线程服务端编程：使用muduo-C-网络库"><a href="#Linux多线程服务端编程：使用muduo-C-网络库" class="headerlink" title="Linux多线程服务端编程：使用muduo C++网络库"></a>Linux多线程服务端编程：使用muduo C++网络库</h1><h2 id="线程安全的对象生命期管理"><a href="#线程安全的对象生命期管理" class="headerlink" title="线程安全的对象生命期管理"></a>线程安全的对象生命期管理</h2><h3 id="class线程安全的三个条件"><a href="#class线程安全的三个条件" class="headerlink" title="class线程安全的三个条件"></a><strong>class线程安全的三个条件</strong></h3><ul>
<li>多个线程访问表现出正确的行为</li>
<li>无论操作系统如何调度，以及线程的执行顺序如何</li>
<li>调用端代码不需要额外的同步与协调动作</li>
</ul>
<p>由此，STL大多数的class都不是线程安全的，需要外部加锁才能同时访问</p>
<h3 id="线程安全的对象构造方法"><a href="#线程安全的对象构造方法" class="headerlink" title="线程安全的对象构造方法"></a><strong>线程安全的对象构造方法</strong></h3><ul>
<li>不要在构造函数中注册任何回调</li>
<li>不要在构造函数把this指针传给跨线程的对象,最后一行也不行</li>
</ul>
<p>原因:构造期间对象还没有完成初始化，this泄漏给了别的对象（自身创建的子对象除外），别的线程有可能访问这个半成品对象。即使构造函数的最后一行也不要泄露 this，因为 Foo 有可能是个基类，基类先于派生类构造，执行完 Foo::Foo() 的最后一行代码还会继续执行派生类的构造函数，这时派生类的对象还处于构造中，仍然不安全。  </p>
<h3 id="线程安全的对象析构方法"><a href="#线程安全的对象析构方法" class="headerlink" title="线程安全的对象析构方法"></a><strong>线程安全的对象析构方法</strong></h3><p>析构函数中不宜使用锁：</p>
<ul>
<li>调用析构函数的时候，正常逻辑来说这个对象已经没有其他线程在使用了，用锁也没有效果；</li>
<li>即使使用了锁，析构函数抢到了锁，其他线程还在等待这个锁，析构函数中锁被析构掉了，其他线程就是未定义行为。</li>
</ul>
<h3 id="使用指针时该如何判断指针是否还存活"><a href="#使用指针时该如何判断指针是否还存活" class="headerlink" title="使用指针时该如何判断指针是否还存活"></a><strong>使用指针时该如何判断指针是否还存活</strong></h3><p>我们无法保证执行一个对象的成员函数时这个对象没有被析构，即使在析构后将对象指针置nullptr也一样。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//线程A</span></span><br><span class="line">~<span class="built_in">P</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">delete</span> xxx;</span><br><span class="line">    <span class="keyword">this</span> = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//线程B</span></span><br><span class="line"><span class="keyword">if</span>(p != <span class="literal">nullptr</span>) <span class="comment">//执行完这一步后去执行线程A</span></span><br><span class="line">&#123;</span><br><span class="line">    p-&gt;<span class="built_in">update</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上完全可以在线程B执行完判空语句进入循环后，转而执行线程A的析构函数，从而导致线程B对空指针操作。</p>
<p>以观察者模式为例，observer对象注册自己到Observable，后者保存有前者的指针，一旦某个事件发生，Observable就通过observer指针调用其成员方法。多线程情况下，Observable无法得知当前调用的observer指针是否还有效，即使使用锁也不行。</p>
<p>解决方法：使用智能指针。使用weak_ptr保存指针，可以清楚的知道指针是否存活：如果weak_ptr可以转化为shared_ptr，证明指针还有效，否则无效。不打算决定对象的生死，就使用weak_ptr管理对象指针；否则使用shared_ptr。</p>
<p>即使能判断指针是否存活，即不会存在使用已经销毁或者正在销毁的指针了！但是不代表没有其他问题：<br>（1）锁争用造成的延时；<br>（2）死锁。</p>
<p>如果同时读写一个class的两个对象，会存在死锁现象，比如swap（a,b)与swap(b,a)在两个线程中同时执行，会发生死锁。swap(a,b)先给a上锁，swap(b,a)先给b上锁，这两个函数并发执行时，可能会出现swap(a,b)拿到a锁swap(b,a)拿到b锁的死锁情况。(哲学家进餐问题)</p>
<p>解决办法：使用相同的顺序加锁，如根据对象地址大小来决定顺序。</p>
<h3 id="如何减少锁争用造成的延迟。"><a href="#如何减少锁争用造成的延迟。" class="headerlink" title="如何减少锁争用造成的延迟。"></a><strong>如何减少锁争用造成的延迟。</strong></h3><p>使用锁会降低程序的效率，使得并行的程序串行化，解决锁争用的方法是：尽量减少临界区的大小；<br>解决方法：local copy的方式，在临界区外创建副本。（<strong>适用于拷贝代价不大的对象</strong>）</p>
<blockquote>
<p>读操作，临界区内拷贝出来，临界区外使用副本读取；</p>
</blockquote>
<blockquote>
<p>写操作，临界区外定义副本，完成要完成的操作，临界区内直接赋值或者swap；</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    shared_ptr&lt;Foo&gt; localPtr;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">MutexLockGuard <span class="title">lock</span><span class="params">(mutex)</span></span>;</span><br><span class="line">        localPtr = globalPtr; <span class="comment">//将全局对象拷贝一份给本地副本</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">do</span>(localPtr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">write</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">shared_ptr&lt;Foo&gt; <span class="title">newPtr</span><span class="params">(<span class="keyword">new</span> Foo)</span></span>; <span class="comment">//在临界区外创建新对象</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">MutexLockGuard <span class="title">lock</span><span class="params">(mutex)</span></span>;</span><br><span class="line">        globalPtr = newPtr; <span class="comment">//将新对象拷给全局对象</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">do</span>(newPtr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意到上面的read()和write()在临界区之外都没有再访问globalPtr，而是用了一个指向同一Foo对象的本地副本。这样可以避免在临界区内创建和析构，减少了临界区大小。 </p>
<h3 id="shared-ptr的使用技巧与坑"><a href="#shared-ptr的使用技巧与坑" class="headerlink" title="shared_ptr的使用技巧与坑"></a>shared_ptr的使用技巧与坑</h3><p>坑：</p>
<p>1.shared_ptr会延长对象的生命周期。</p>
<p> 某些函数实参采用非引用类型shared_ptr类型，调用这个函数的时候就会发生shared_ptr的拷贝操作，使得对象指针的引用计数值变大。如果这个函数返回一个对象，这个对象也中也存在这个shared_ptr的指针，那么shared_ptr对象的声明周期就被延长了。</p>
<p>例子：std::bind函数，基本作用是，为一个函数指针提供默认参数。其实参就会被拷贝一份出来。（模板参数，不论什么类型都会发生拷贝行为）</p>
<p>2.shared_ptr的拷贝代价比指针要大。<br>毕竟还要保存引用计数等变量，修改引用计数等行为。（建议使用引用传递）</p>
<p>3.不能同时使用两个shared_ptr，容易引起误会；<br> 类内（成员函数）使用shared_ptr<this>与类外使用shared_ptr同时使用时，会造成析构两次的问题。<br> 解释：类内部使用share_ptr<this>的需求可以使用：shared_from_this() 代替this;</p>
<p>4.shared_ptr<T>的线程安全性，它的线程安全性级别和std::string是一样的。它的计数操作是原子操作，但是多线程对它的并发读写是不安全的，因为他有两个操作，一个是修改地址一个是修改计数。可以想一下，现在有一个智能指针x指向一片内存，先对它读，比如y&#x3D;x;，读一半（只修改了y的地址，但是计数还是1），此时再进行写操作，比如x&#x3D;z，全部执行完，那么x指向z的内存，x原来指的内存因为计数减一被释放，这时再进行y&#x3D;x读操作的另一半（计数加一），但是内存已经释放了。 </p>
<p>所以多线程读写shared_ptr<T>需要保护临界区。 </p>
<p>使用技巧：</p>
<ol>
<li><p>作为函数参数时，建议使用const reference传递;</p>
</li>
<li><p>在创建shared_ptr对象时，可以手动指定析构函数，这样可以保证可以跨dll来删除。</p>
<p>解释：windows下的进程会有好几个堆，每个dll都会有一个堆，一个堆里申请的需要在这个堆释放，所以存在跨模块释放的问题；shared_ptr通过指定析构函数，使得释放时，可以释放对应堆的对象。</p>
</li>
<li><p>shared_ptr的析构如果可能发生在关键进程，可以用一个专门的线程来处理析构，使用BlockQueue<shared_ptr>来转移对象到析构线程；</p>
</li>
<li><p>ower持有指向child的shared_ptr，child持有指向ower的weak_ptr；<br> 解释：ower可以决定子对象的生死，child只负责使用，不可以控制父对象的生死</p>
</li>
</ol>
<h3 id="对象池中需要注意的点"><a href="#对象池中需要注意的点" class="headerlink" title="对象池中需要注意的点"></a>对象池中需要注意的点</h3><p>场景：对象池A类中包含了很多B类对象。B类对象可以是暂存在A类中的，用于回调；也可能是被A类所使用。</p>
<p><strong>需求：A类中的B类对象如果不使用了及时释放掉，以节省内存。不使用了的概念是没有线程在使用了</strong></p>
<p>第一版：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Item</span> &#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Factory</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  std::map&lt;std::string, shared_ptr&lt;Item&gt;&gt; data_;</span><br><span class="line">  <span class="keyword">mutable</span> std::mutex lock_;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function">shared_ptr&lt;Item&gt;  <span class="title">get</span><span class="params">(<span class="type">const</span> std::string&amp; key)</span></span>;    <span class="comment">//使用shared_ptr作为返回值，因为出去使用的对象认为不能随便释放掉。</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这一版存在的问题是使用shared_ptr保存Item对象，这会导致Item对象的生命周期由Factory控制，有可能一直无法析构，显然与需求不符。</p>
<p>可以使用weak_ptr来解决这个问题。</p>
<p>第二版：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Item</span> &#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Factory</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  std::map&lt;std::string, weak_ptr&lt;Item&gt;&gt; data_;</span><br><span class="line">  <span class="keyword">mutable</span> std::mutex lock_;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function">shared_ptr&lt;Item&gt;  <span class="title">get</span><span class="params">(<span class="type">const</span> std::string&amp; key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  shared_ptr&lt;Item&gt; ret;</span><br><span class="line">  lock_.<span class="built_in">lock</span>();</span><br><span class="line">  ret = data_[key].<span class="built_in">lock</span>(); <span class="comment">//weak提升为shared_ptr</span></span><br><span class="line">  <span class="keyword">if</span>(!ret) &#123;</span><br><span class="line">      ret.<span class="built_in">reset</span>(<span class="keyword">new</span> <span class="built_in">Item</span>());</span><br><span class="line">      data_[key] = ret;</span><br><span class="line">  &#125;</span><br><span class="line">  lock_.<span class="built_in">unlock</span>();</span><br><span class="line">  <span class="keyword">return</span> ret;    </span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>解决了第一版的问题，Item可以正常析构了，但是仍有一个问题存在。Item析构后，不会在Factory的map中将对应的Item erase掉，这会导致即使Item析构了，map的size也不会减少，所以析构后还必须在Factory的map中将对应的Item erase掉。</p>
<p>可以给shared_ptr定制析构函数来实现。</p>
<p>第三版：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Item</span> &#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Factory</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::map&lt;std::string, weak_ptr&lt;Item&gt;&gt; data_;</span><br><span class="line">    <span class="keyword">mutable</span> std::mutex lock_;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">deleteItem</span><span class="params">(Item* item)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(item)</span><br><span class="line">        &#123;</span><br><span class="line">            lock_.<span class="built_in">lock</span>();</span><br><span class="line">            data_.<span class="built_in">erase</span>(item-&gt;<span class="built_in">key</span>());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">delete</span> item;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">shared_ptr&lt;Item&gt;  <span class="title">get</span><span class="params">(<span class="type">const</span> std::string&amp; key)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">      shared_ptr&lt;Item&gt; ret;</span><br><span class="line">      lock_.<span class="built_in">lock</span>();</span><br><span class="line">      ret = data_[key].<span class="built_in">lock</span>(); <span class="comment">//weak提升为shared_ptr</span></span><br><span class="line">      <span class="keyword">if</span>(!ret) &#123;</span><br><span class="line">        ret.<span class="built_in">reset</span>(<span class="keyword">new</span> <span class="built_in">Item</span>(),std::<span class="built_in">bind</span>(&amp;Factory::deleteItem,<span class="keyword">this</span>,_1));</span><br><span class="line">        data_[key] = ret;</span><br><span class="line">      &#125;</span><br><span class="line">      lock_.<span class="built_in">unlock</span>();</span><br><span class="line">      <span class="keyword">return</span> ret;    </span><br><span class="line">    &#125;   </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>如上在Factory中get函数创建Item时用std::bind绑定Item的定制析构函数，在shared_ptr析构时自动调用。但这仍存在问题，Item析构时需要调用Factory的deleteItem方法，但Item析构时Factory可能已经不存在。</p>
<p>解决方法是延长Factory的生命周期，使用shared_ptr保存Factory的this指针，同时Factory必须保存在堆上，栈对象的生命周期是无法控制的(同理栈对象也不能用于多线程，因为生命周期无法控制)</p>
<p>第四版：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Factory</span> : <span class="keyword">public</span> std::enable_shared_from_this&lt;Factory&gt; &#123;    <span class="comment">//必须继承这个类；</span></span><br><span class="line">     <span class="comment">//类内部需要使用shared_ptr&lt;this&gt;的地方，使用shared_from_this()来代替。</span></span><br><span class="line">     <span class="comment">//类内部需要使用weak_ptr&lt;this&gt;的地方，使用std::weak_ptr&lt;Factory&gt;(shared_from_this())就好了（就是使用shared_from_this()来生成了下weak_ptr()）</span></span><br><span class="line">    <span class="comment">//ret.reset(new Item(),std::bind(&amp;Factory::deleteItem,this,_1))变为</span></span><br><span class="line">    <span class="comment">//ret.reset(new Item(),std::bind(&amp;Factory::deleteItem,shared_from_this(),_1))</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>enable_shared_from_this这是一个以其派生类为模板类型实参的基类模板， 继承它之后， 用shared_from_this()就可以表示shared_ptr<this>。</p>
<p>现在仍存在最后一个问题，std::bind中绑定了Factory的shared_ptr<this>，这会导致Factory的生命周期被延长，从而导致Factory无法析构。</p>
<p>解决方法是将shared_ptr<this>改为weak_ptr<this>，这样就不会延长Factory的生命周期了，在Item析构前先通过weak_ptr<this>判断Factory是否存在。</p>
<p>第五版：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Factory</span> : <span class="keyword">public</span> std::enable_shared_from_this&lt;Factory&gt; &#123;    <span class="comment">//必须继承这个类；</span></span><br><span class="line">     <span class="comment">//类内部需要使用shared_ptr&lt;this&gt;的地方，使用shared_from_this()来代替。</span></span><br><span class="line">     <span class="comment">//类内部需要使用weak_ptr&lt;this&gt;的地方，使用std::weak_ptr&lt;Factory&gt;(shared_from_this())就好了（就是使用shared_from_this()来生成了下weak_ptr()）</span></span><br><span class="line">    <span class="comment">//ret.reset(new Item(),std::bind(&amp;Factory::deleteItem,shared_from_this(),_1))变为</span></span><br><span class="line">    <span class="comment">//ret.reset(new Item(),std::bind(&amp;Factory::deleteItem,std::weak_ptr&lt;Factory&gt;(shared_from_this()),_1))</span></span><br><span class="line">    <span class="comment">//在deleteItem增加通过weak_ptr判断Factory是否存在的步骤。</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这种技术称为弱回调</p>
<h3 id="多线程编程建议"><a href="#多线程编程建议" class="headerlink" title="多线程编程建议"></a>多线程编程建议</h3><p>尽量减少使用跨线程的对象 ，用流水线， 生产者消费者， 任务队列这些有规律的机制， 最低限度地共享数据。 这是我所知最好的多线程编程的建议了  </p>
<h2 id="线程同步精要"><a href="#线程同步精要" class="headerlink" title="线程同步精要"></a>线程同步精要</h2><h3 id="线程同步原则"><a href="#线程同步原则" class="headerlink" title="线程同步原则"></a>线程同步原则</h3><p>线程同步的四项原则，按重要性排列：</p>
<ol>
<li>首要原则是尽量最低限度地共享对象，减少需要同步的场合。一个对象能不暴露给别的线程就不要暴露；如果要暴露，优先考虑const对象；实在不行才暴露可修改的对象，并用同步措施来充分保护它。</li>
<li>其次是使用高级的并发编程构件，如任务队列TaskQueue、生产者消费者队列Producer Consumer Queue、倒计时锁存器CountDownLatch等等。</li>
<li>最后不得已必须使用底层同步原语（primitives）时，只用非递归的互斥器和条件变量，慎用读写锁，不要用信号量。</li>
<li>除了使用atomic整数之外，不自己编写lock-free代码，也不要用“内核级”同步原语。不凭空猜测“哪种做法性能会更好”，比如spin lock vs. mutex。</li>
</ol>
<h3 id="mutex的使用建议"><a href="#mutex的使用建议" class="headerlink" title="mutex的使用建议"></a>mutex的使用建议</h3><p>主要原则：</p>
<ul>
<li>用RAII手法封装mutex的创建、销毁、加锁、解锁这四个操作。即保证锁的生效期间等于一个作用域（scope），不会因异常而忘记解锁。</li>
<li>只用非递归的mutex（即不可重入的mutex)。</li>
<li>不手工调用lock()和unlock()函数，一切交给栈上的Guard对象的构造和析构函数负责。Guard对象的生命期正好等于临界区。这样我们保证始终在同一个函数同一个scope里对某个mutex加锁和解锁。避免在foo()里加锁，然后跑到bar()里解锁；也避免在不同的语句分支中分别加锁、解锁。这种做法被称为Scoped Locking。</li>
<li>在每次构造Guard对象的时候，思考一路上（调用栈上）已经持有的锁，防止因加锁顺序不同而导致死锁（deadlock）。由于Guard对象是栈上对象，看函数调用栈就能分析用锁的情况，非常便利。</li>
</ul>
<p>次要原则：</p>
<ul>
<li>不使用跨进程的mutex， 进程间通信只用TCP sockets。</li>
<li>加锁、解锁在同一个线程， 线程a不能去unlock线程b已经锁住的mutex（RAII自动保证）。</li>
<li>别忘了解锁（RAII自动保证）。</li>
<li>不重复解锁（RAII自动保证）。</li>
<li>必要的时候可以考虑用PTHREAD_MUTEX_ERRORCHECK来排<br>错</li>
</ul>
<h4 id="只使用非递归mutex的原因"><a href="#只使用非递归mutex的原因" class="headerlink" title="只使用非递归mutex的原因"></a>只使用非递归mutex的原因</h4><p>mutex分为递归（recursive） 和非递归（non-recursive） 两种， 这是POSIX的叫法， 另外的名字是可重入（reentrant）与非可重入。   </p>
<p>它们的唯一区别在于： 同一个线程可以重复对可递归mutex加锁， 但是不能重复对非递归mutex加锁。<strong>在同一个线程里多次对非递归锁加锁会立刻导致死锁。</strong></p>
<p>选择非递归mutex的原因不是因为性能，非递归mutex性能要更好一点但是好的有限(递归锁需要保存线程id记录持有锁的线程，还要多一个计数器计算当前线程lock了递归锁几次，只有全部都unlock后才能真正释放锁)，而递归锁可以重复加锁比非递归方便的多。</p>
<p><strong>非递归锁的优点恰恰在于在同一个线程里多次对非递归锁加锁会立刻导致死锁，</strong>这能帮助我们思考代码对锁的需求，并且及早（在编码阶段） 发现问题。</p>
<p>递归锁因为方便可能会隐藏代码里的一些问题。典型情况是你以为拿到一个锁就能修改对象了，没想到外层代码已经拿到了锁，正在修改（或读取）同一个对象呢。来看一个具体的例子  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Mutexlock mutex;</span><br><span class="line">std::vector&lt;Foo&gt; foos;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushFoo</span><span class="params">(<span class="type">const</span> FOO&amp; f)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">MutexLockGuard <span class="title">lock</span><span class="params">(mutex)</span></span>;</span><br><span class="line">    foos.<span class="built_in">push_back</span>(f);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">traverse</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">MutexLockGuard <span class="title">lock</span><span class="params">(mutex)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> it = foos.<span class="built_in">begin</span>(); it != foos.<span class="built_in">end</span>(); ++it)</span><br><span class="line">    &#123;</span><br><span class="line">        it-&gt;<span class="built_in">do</span>(); <span class="comment">//对Foo对象进行一些操作</span></span><br><span class="line">        <span class="built_in">pushFoo</span>(*it);</span><br><span class="line">        it-&gt;<span class="built_in">do</span>(); <span class="comment">//扩容后it失效，对it调用do函数导致coredump</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上所示，如果在traverse函数中调用了pushFoo函数，表面看上去没事，但是在pushFoo中调用了vector的push_back函数，如果vector进行扩容并重新分配空间，这会导致vector的迭代器失效，从而导致traverse中的it失效，程序崩溃。所以边遍历vector边修改是不对的，而在使用递归锁的时候可能会让你无法发现这个错误。</p>
<p>所以递归锁可能会导致你原来以为不会发生改变的对象发生改变，你在写程序时很可能无法注意到这一点，从而导致程序在特定情况下出现错误。</p>
<p>而非递归锁虽然会导致死锁，但是死锁很容易debug，把各个线程的调用栈打出来， 只要每个函数不是特别长， 很容易看出来是怎么死的。 或者可以用PTHREAD_MUTEX_ERRORCHECK一下子就能找到错误（前提是MutexLock带debug选项）。  </p>
<p>如果一定要边遍历vector边修改，有两种做法：一是把修改推后， 记住遍历中试图添加或删除哪些元素， 等遍历结束了再依记录修<br>改foos； 二是用copy-on-write。</p>
<p>如果一个函数既可能在已加锁的情况下调用， 又可能在未加锁的情况下调用，也就是有用到递归锁的需求时，那么就将函数拆成两个函数加锁版和不加锁版<br>1．加锁版跟原来的函数同名， 函数加锁，并在内部调用不加锁版。<br>2．不加锁版给函数名加上后缀WithLockHold， 不加锁，把原来的函数体除了加锁部分搬过来。  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushFoo</span><span class="params">(<span class="type">const</span> FOO&amp; f)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">MutexLockGuard <span class="title">lock</span><span class="params">(mutex)</span></span>;</span><br><span class="line">    <span class="built_in">pushFooWithLockHold</span>(f)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushFooWithLockHold</span><span class="params">(<span class="type">const</span> FOO&amp; f)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    foos.<span class="built_in">push_back</span>(f);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上所示，但在使用不可递归锁时可能会导致新的问题，一是在本线程加了锁的情况下误调用了加锁版，导致死锁，可以用debug死锁的办法解决。二是在其他线程加了锁的情况下(不希望对象被修改)，本线程误调用了不加锁版导致对象被修改，从而导致数据损坏。可以通过在不加锁版函数头检测锁有没有被本线程持有来解决。如下所示：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushFooWithLockHold</span><span class="params">(<span class="type">const</span> FOO&amp; f)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(mutex.<span class="built_in">isLockedByThisThread</span>()); <span class="comment">//muduo::MutexLock提供了该函数</span></span><br><span class="line">    foos.<span class="built_in">push_back</span>(f);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="死锁的建议"><a href="#死锁的建议" class="headerlink" title="死锁的建议"></a>死锁的建议</h3><p><strong>死锁常见的两个例子：</strong></p>
<ul>
<li>同一线程发生死锁。<strong>同一个类中有锁的一个函数辗转调用了另一个有锁的函数。</strong></li>
<li>两个线程发生死锁。<strong>两个类中持有锁的两对函数相互调用。</strong></li>
</ul>
<p><strong>死锁的检测与预防</strong></p>
<p>预防：</p>
<ol>
<li>严格控制锁的调用顺序，用锁之前需要想调用栈上都有了哪些锁；</li>
<li>将锁内调用的函数同时定义一个无锁版，锁内调用那个无锁版；</li>
</ol>
<p>检测：死锁之后，打开core文件或者使用gdb命令查看线程调用栈：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">thread apply all bt</span><br></pre></td></tr></table></figure>

<p>看到线程阻塞在一个锁上（__lll_lock_wait）就是发生了死锁。</p>
<h3 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h3><h4 id="使用条件变量的建议"><a href="#使用条件变量的建议" class="headerlink" title="使用条件变量的建议"></a>使用条件变量的建议</h4><p>如果需要等待某个条件成立， 即等待某个bool表达式为真。我们应该使用条件变量（condition variable） 。 条件变量顾名思义是一个或多个线程等待某个布尔表达式为真， 即等待别的线程“唤醒”它。 条件变量的学名叫管程（monitor） 。  </p>
<p>wait()函数可使得当前线程阻塞，直至条件变量唤醒。线程阻塞后，该函数会自动解锁，允许其他线程执行。一旦得到notify唤醒，该函数取消阻塞并获取锁，然后函数返回，一般为了避免虚假唤醒，会用while循环判断条件。</p>
<p>notify()：因为只唤醒等待队列中的第一个线程；不存在锁争用，所以能够立即获得锁。其余的线程不会被唤醒，需要等待再次调用notify_one()或者notify_all()。</p>
<p>notifyAll()：会唤醒所有等待队列中阻塞的线程，存在锁争用，只有一个线程能够获得锁。其余未获取锁的线程接着会继续尝试获得锁(类似于轮询)，而不会再次阻塞。当持有锁的线程释放锁时，这些线程中的一个会获得锁。而其余的会接着尝试获得锁。</p>
<p>条件变量的notify通常代表资源可用（生产者模式）；notifyAll通常代表状态变化。（比如倒计时系统，可以开始做事了的那种）</p>
<blockquote>
<p>虚假唤醒：线程被唤醒后发现条件不满足的情况。一种情况是跟操作系统底层有关，wait有时会在没有唤醒的情况下返回。在不同的平台，原因可能不一样。另一种情况是被条件变量唤醒的线程在本线程内真正执行「加锁并返回」前，另一个线程插了进来，完整地进行了一套「拿锁、改条件、还锁」的操作。假设是在等待消费队列，一个线程A被nodify，但是还没有获得锁时，另一个线程B获得了锁，并消费掉了队列中的数据。B退出或wait后，A获得了锁，而这时条件已不满足。</p>
</blockquote>
<p>对于wait端：</p>
<ul>
<li>必须与mutex一起使用；wait函数和bool表达式的判断需要在mutex的保护下（如果wait不用mutex保护可能导致notify在wait之前发生，从而导致wait永远无法被唤醒）；</li>
<li>把bool表达式的判断和wait()放到while循环中，而不能是if</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line"><span class="keyword">while</span>(queue.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">  cond.<span class="built_in">wait</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//在锁的保护下，从queue中获取变量。</span></span><br></pre></td></tr></table></figure>

<p>对于signal端</p>
<ul>
<li>notify、notifyAll函数不一定在已上锁的情况下调用；</li>
<li>调用notify之前一般要修改bool表达式；（修改bool表达式要有锁保护）</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">queue.<span class="built_in">push_back</span>(x);</span><br><span class="line">cond.<span class="built_in">notify</span>();</span><br></pre></td></tr></table></figure>

<h4 id="使用CountDownLatch"><a href="#使用CountDownLatch" class="headerlink" title="使用CountDownLatch"></a>使用CountDownLatch</h4><p>mutex和条件变量是非常底层的同步原语， 很少直接使用， 一般都是用它来实现高层的同步措施， 如BlockingQueue<T>或CountDownLatch。<strong>在多线程开发时尽量用高层同步设施（线程池、 队列、 倒计时）；</strong></p>
<p>倒计时（CountDownLatch）是一种常用且易用的同步手段。它主要有两种用途：</p>
<ul>
<li>主线程发起多个子线程， 等这些子线程各自都完成一定的任务之后， 主线程才继续执行。 通常用于主线程等待多个子线程完成初始化。</li>
<li>主线程发起多个子线程， 子线程都等待主线程， 主线程完成其他一些任务之后通知所有子线程开始执行。 通常用于多个子线程等待主线程发出“起跑”命令。</li>
</ul>
<p><strong>倒计时的接口和实现</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CountDownLatch</span>:boost::nocopyable</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">CountDownLatch</span><span class="params">(<span class="type">int</span> count)</span></span>; <span class="comment">//倒数几次</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">wait</span><span class="params">()</span></span>; <span class="comment">//等待计数值变为0</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">countDown</span><span class="params">()</span></span>; <span class="comment">//计数减1</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">mutable</span> MutexLock mutex_;</span><br><span class="line">    Condition condition_;</span><br><span class="line">    <span class="type">int</span> count_;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CountDownLatch::wait</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">MutexLockGuard <span class="title">lock</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">    <span class="keyword">while</span>(count_ &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        condition_.<span class="built_in">wait</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CountDownLatch::countDown</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">MutexLockGuard <span class="title">lock</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">    --count_;</span><br><span class="line">    <span class="keyword">if</span>(count == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        condition_.<span class="built_in">notifyAll</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="不要使用读写锁和信号量"><a href="#不要使用读写锁和信号量" class="headerlink" title="不要使用读写锁和信号量"></a>不要使用读写锁和信号量</h3><p><strong>不使用读写锁有以下原因</strong></p>
<ul>
<li>程序员可能会不小心在读锁保护的函数中调用了会修改状态的函数。 这种错误的后果跟无保护并发读写共享数据是一样的。</li>
<li>从性能方面来说， 读写锁不见得比普通mutex更高效。 无论如何读锁加锁的开销不会比mutex小， 因为它要更新当前读者的数目。 如果临界区很小， 锁竞争不激烈， 那么mutex往往会更快。</li>
<li>读锁可能允许提升（upgrade）为写锁， 也可能不允许提升。考虑之前mutex的使用建议中的pushFoo()和traverse()函数， 如果用读写锁来保护foos对象， 那么pushFoo()应该持有写锁， 而traverse()应该持有读锁。 如果允许把读锁提升为写锁， 后果跟使用递归锁一样， 会造成迭代器失效，程序崩溃。 如果不允许提升， 后果跟使用非递归锁一样， 会造成死锁。 我宁愿程序死锁， 留个“全尸”好查验。</li>
<li>通常读锁是可重入的，写锁是不可重入的。 但是为了防止写者饥饿，写锁通常会阻塞后来的读锁， 因此读锁在重入的时候可能死锁。 另外， 在追求低延迟读取的场合也不适用读写锁。</li>
</ul>
<p>遇到并发读写， 如果条件合适， 我通常会用copy on write的办法， 而不用读写锁， 同时避免读者被写者阻塞。 如果确实对并发读写有极高的性能要求， 可以考虑read-copy-update。</p>
<p><strong>不使用信号量的原因</strong></p>
<p>因为条件变量配合互斥器可以完全替代其功能， 而且更不易用错。 信号量的另一个问题在于它有自己的计数值， 而通常我们自己的数据结构也有长度值， 这就造成了同样的信息存了两份， 需要时刻保持一致， 这增加了程序员的负担和出错的可能。   </p>
<h3 id="线程安全的单例模式"><a href="#线程安全的单例模式" class="headerlink" title="线程安全的单例模式"></a>线程安全的单例模式</h3><p>单例模式指在整个系统生命周期里，保证一个类只能产生一个实例，确保该类的<strong>唯一性</strong>。</p>
<p><strong>单例模式分类</strong></p>
<p>单例模式可以分为<strong>懒汉式</strong>和<strong>饿汉式</strong>，两者之间的区别在于<strong>创建实例的时间不同</strong>：</p>
<ul>
<li><strong>懒汉式</strong>：指系统运行中，实例并不存在，只有当需要使用该实例时，才会去创建并使用实例。<strong>（这种方式要考虑线程安全，否则可能会构造多个实例）</strong></li>
<li><strong>饿汉式</strong>：指系统一运行，就初始化创建实例，当需要时，直接调用即可。<strong>（本身就线程安全，没有多线程的问题）</strong></li>
</ul>
<p><strong>单例类特点</strong></p>
<ul>
<li>构造函数和析构函数为<strong>private</strong>类型，目的<strong>禁止</strong>外部构造和析构</li>
<li>拷贝构造和赋值构造函数为<strong>private</strong>类型，目的是<strong>禁止</strong>外部拷贝和赋值，确保实例的唯一性</li>
<li>类里有个获取实例的<strong>静态函数</strong>，可以全局访问</li>
</ul>
<p><strong>用局部静态变量实现单例模式</strong></p>
<p>非局部静态变量是线程安全的，而局部静态变量在C++11后也是线程安全的</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Single</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 获取单实例对象</span></span><br><span class="line">    <span class="function"><span class="type">static</span> Single &amp;<span class="title">GetInstance</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 禁止外部构造</span></span><br><span class="line">    <span class="built_in">Single</span>();</span><br><span class="line">    <span class="comment">// 禁止外部析构</span></span><br><span class="line">    ~<span class="built_in">Single</span>();</span><br><span class="line">    <span class="comment">// 禁止外部拷贝构造</span></span><br><span class="line">    <span class="built_in">Single</span>(<span class="type">const</span> Single &amp;signal);</span><br><span class="line">    <span class="comment">// 禁止外部赋值操作</span></span><br><span class="line">    <span class="type">const</span> Single &amp;<span class="keyword">operator</span>=(<span class="type">const</span> Single &amp;signal);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Single&amp; <span class="title">Single::GetInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 局部静态特性的方式实现单实例</span></span><br><span class="line">    <span class="type">static</span> Single signal;</span><br><span class="line">    <span class="keyword">return</span> signal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>用pthread_once_t实现单例模式</strong>  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果once_control为0，init_routine()就会执行。pthread_once()成功返回之后，once_control会变为2</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_once</span><span class="params">(<span class="type">pthread_once_t</span> *once_control, <span class="type">void</span> (*init_routine) (<span class="type">void</span>))</span>；</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">/* 功能：本函数使用初值为PTHREAD_ONCE_INIT的once_control变量保证init_routine()函数在本进程执行序列中仅执行一次。</span></span></span><br><span class="line"><span class="comment"><span class="function">在多线程编程环境下，尽管pthread_once()调用会出现在多个线程中，init_routine()函数仅执行一次，究竟在哪个线程中执行是不定的，是由内核调度来决定。 */</span></span></span><br></pre></td></tr></table></figure>



<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span> : noncopyable</span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Singleton</span>() = <span class="keyword">delete</span>;</span><br><span class="line">  ~<span class="built_in">Singleton</span>() = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">static</span> T&amp; <span class="title">instance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="built_in">pthread_once</span>(&amp;ponce_, &amp;Singleton::init);</span><br><span class="line">    <span class="built_in">assert</span>(value_ != <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span> *value_;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    value_ = <span class="keyword">new</span> <span class="built_in">T</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="type">static</span> <span class="type">pthread_once_t</span> ponce_;</span><br><span class="line">  <span class="type">static</span> T*             value_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">pthread_once_t</span> Singleton&lt;T&gt;::ponce_ = PTHREAD_ONCE_INIT;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">T* Singleton&lt;T&gt;::value_ = <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure>

<h3 id="不要将sleep-用于线程同步"><a href="#不要将sleep-用于线程同步" class="headerlink" title="不要将sleep()用于线程同步"></a>不要将sleep()用于线程同步</h3><p>sleep()&#x2F;usleep()&#x2F;nanosleep()只能出现在测试代码中，比如写单元测试的时候；或者用于有意延长临界区，加速复现死锁的情况。</p>
<p>在程序的正常执行中， 如果需要等待一段已知的时间， 应该往event loop里注册一个timer， 然后在timer的回调函数里接着干活， 因为线程是个珍贵的共享资源，不能轻易浪费（阻塞也是浪费）。如果等待某个事件发生，那么应该采用条件变量或IO事件回调，不能用sleep来轮询。</p>
<h2 id="多线程服务器的适用场合与常用编程模型"><a href="#多线程服务器的适用场合与常用编程模型" class="headerlink" title="多线程服务器的适用场合与常用编程模型"></a>多线程服务器的适用场合与常用编程模型</h2><h3 id="单线程服务器的常用编程模型"><a href="#单线程服务器的常用编程模型" class="headerlink" title="单线程服务器的常用编程模型"></a>单线程服务器的常用编程模型</h3><p>常用Reactor模型，也就是IO多路复用+非阻塞IO。程序的基本结构是一个事件循环（event loop），以事件驱动（event-driven）和事件回调的方式实现业务逻辑。</p>
<p>业务逻辑就是程序循环阻塞在select&#x2F;poll&#x2F;epoll上， 接收到请求时触发IO回调函数进行处理。</p>
<p>Reactor模型的优点很明显， 编程不难， 效率也不错。不仅可以用于读写socket，连接的建立，甚至DNS解析都可以用非阻塞方式进行， 以提高并发度和吞吐量，对于IO密集的应用是个不错的选择。lighttpd就是这样，它内部的fdevent结构十分精妙，值得学习。  </p>
<p>基于事件驱动的编程模型也有其本质的缺点， 它要求事件回调函数必须是非阻塞的。 对于涉及网络IO的请求响应式协议， 它容易割裂业务逻辑， 使其散布于多个回调函数之中， 相对不容易理解和维护。 现代的语言有一些应对方法（例如coroutine）。</p>
<blockquote>
<p>IO多路复用搭配非阻塞IO的原因1.select&#x2F;poll&#x2F;epoll返回的并不一定可读，有可能因为数据检验错误被系统丢弃或者数据已被其他线程读取，或者等等未知的情况导致不可读，若使用阻塞IO有可能导致线程阻塞无法及时接收后续请求。2.多路复用只会告诉你 fd 对应的 socket 可读了，但不会告诉你有多少的数据可读，如果使用阻塞IO只能读一次，读多次就可能阻塞线程；而使用非阻塞IO则可以循环读一直读到返回不可读为止，效率更高。</p>
</blockquote>
<h3 id="多线程服务器的常用编程模型"><a href="#多线程服务器的常用编程模型" class="headerlink" title="多线程服务器的常用编程模型"></a>多线程服务器的常用编程模型</h3><ul>
<li>每个请求创建一个线程， 使用阻塞式IO操作。 在Java 1.4引入NIO之前， 这是Java网络编程的推荐做法。 可惜伸缩性不佳。</li>
<li>使用线程池， 同样使用阻塞式IO操作。与第1种相比，这是提高性能的措施。</li>
<li>使用non-blocking IO＋IO multiplexing。 即Java NIO的方式。</li>
<li>Leader&#x2F;Follower等高级模式。</li>
</ul>
<p>推荐使用多Reactor多线程+线程池作为C++多线程服务端编程模型。</p>
<p>这个模型也叫one (event) loop per thread+ thread pool。</p>
<ul>
<li>event loop（也叫IO loop） 用作IO multiplexing， 配合non-blocking IO和定时器。</li>
<li>thread pool用来做计算， 具体可以是任务队列或生产者消费者队列。</li>
</ul>
<p>程序里具体用几个loop、 线程池的大小等参数需要根据应用来设定， 基本的原则是“阻抗匹配”， 使得CPU和IO都能高效地运作。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//阻抗匹配原则</span></span><br><span class="line">C = CPU数量</span><br><span class="line">P = CPU繁忙时间 / 总运行时间   <span class="comment">// 0&lt;P&lt;=1</span></span><br><span class="line">T = 所需设置线程数</span><br><span class="line">T = C / P</span><br></pre></td></tr></table></figure>

<h4 id="使用blocking-queue和线程池"><a href="#使用blocking-queue和线程池" class="headerlink" title="使用blocking queue和线程池"></a>使用blocking queue和线程池</h4><p>对于没有IO而光有计算任务的线程， 使用event loop有点浪费， 我会用一种补充方案， 即用blocking queue实现的任务队列<br>（TaskQueue）</p>
<h5 id="blocking-queue实现"><a href="#blocking-queue实现" class="headerlink" title="blocking queue实现"></a>blocking queue实现</h5><h5 id="用blocking-queue实现线程池"><a href="#用blocking-queue实现线程池" class="headerlink" title="用blocking queue实现线程池"></a>用blocking queue实现线程池</h5><h3 id="进程通信只使用tcp的原因"><a href="#进程通信只使用tcp的原因" class="headerlink" title="进程通信只使用tcp的原因"></a>进程通信只使用tcp的原因</h3><p>如果强调本主机共享只读数据，当然是共享内存好，但是如果是进程间的消息传递，使用TCP会有一些列优点。</p>
<ul>
<li>TCP很容易跨主机使用，方便扩展，其他方式无法跨机器；</li>
<li>TCP是双向的，而管道是单向的且需要进程为父子关系，相比TCP很不方便；</li>
<li>TCP资源在进程结束时会被系统自动回收(都是文件描述符)，即使程序意外退出，也不会给系统留下垃圾，不用担心由于进程崩溃而导致资源无法释放的问题（这种情况只能重启操作系统，跨进程锁就有这个风险）；</li>
<li>使用TCP进行通信，进程一方崩溃，操作系统会关闭连接，另一方可以很快的知道（应用层心跳也是需要有的）；</li>
<li>出现问题方便记录与重现：使用wireshark&#x2F;tcpdump抓包就可以。</li>
<li>任何一个进程都能单独重启。 换句话说，TCP连接是可再生的， 连接的任何一方都可以退出再启动， 重建连接之后就能继续工作， 这对开发牢靠的分布式系统意义重大。</li>
</ul>
<h4 id="分布式系统使用tcp长连接的优点"><a href="#分布式系统使用tcp长连接的优点" class="headerlink" title="分布式系统使用tcp长连接的优点"></a>分布式系统使用tcp长连接的优点</h4><p>1.容易定位分布式系统中服务的依赖关系：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -tnpa | grep :port   </span><br></pre></td></tr></table></figure>

<p>在机器上运行上述指令就能立刻列出用到某服务的客户端地址（Foreign列），然后在客户端的机器上用netstat或lsof命令找出是哪个进程发起的连接。</p>
<p>2.可以通过发送队列和接受队列实时了解服务器的故障信息（可以用于监控）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -tn</span><br></pre></td></tr></table></figure>

<p>在正常运行的时候， netstat打印的Recv-Q和Send-Q都应该接近0，或者在0附近摆动。</p>
<p>如果Recv-Q保持不变或持续增加，则通常意味着服务进程的处理速度变慢，可能发生了死锁或阻塞。 </p>
<p>如果Send-Q保持不变或持续增加， 有可能是对方服务器太忙、来不及处理，也有可能是网络中间某个路由器或交换机故障造成丢包， 甚至对方服务器掉线， 这些因素都可能表现为数据发送不出去。 </p>
<p>通过持续监控Recv-Q和Send-Q就能及早预警性能或可用性故障。   </p>
<h3 id="使用多线程还是单线程"><a href="#使用多线程还是单线程" class="headerlink" title="使用多线程还是单线程"></a>使用多线程还是单线程</h3><p>如果要在一台多核机器上提供一种服务或执行一个任务， 可用的模式有<br>1． 运行一个单线程的进程；<br>2． 运行一个多线程的进程；<br>3． 运行多个单线程的进程；<br>4． 运行多个多线程的进程。<br>简单地总结如下：<br>模式1是不可伸缩的（scalable） ， 不能发挥多核机器的计算能力。模式3是目前公认的主流模式。 它有以下两种子模式：</p>
<ul>
<li>3a：简单地把模式1中的进程运行多份</li>
<li>3b：主进程+woker进程， 如果必须绑定到一个TCP port， 比如httpd+fastcgi</li>
</ul>
<p>模式2是被很多人所鄙视的， 认为多线程程序难写， 而且与模式3相比并没有什么优势。模式4更是千夫所指， 它不但没有结合2和3的优点， 反而汇聚了二者的缺点。</p>
<p>本文主要想讨论的是模式2和模式3b的优劣， 即： 什么时候一个服务器程序应该是多线程的。   </p>
<p>从性能上讲， 无论是IO bound还是CPU bound的服务， 多线程都没有什么优势。  </p>
<ul>
<li>对于静态Web服务器， 或者FTP服务器， CPU的负载较轻， 主要瓶颈在磁盘IO和网络IO方面。 这时候往往一个单线程的程序（模式1） 就能撑满IO。 用多线程并不能提高吞吐量， 因为IO硬件容量已经饱和了。同理， 这时增加CPU数目也不能提高吞吐量。</li>
<li>CPU跑满的情况比较少见， 这里我只好虚构一个例子。 假设有一个服务， 它的输入是n个整数， 问能否从中选出m个整数， 使其和为0（这里n＜100, m＞0）。 这是著名的subset sum问题， 是NP-Complete的。 对于这样一个“服务”， 哪怕很小的n值也会让CPU算死。 比如n＝30， 一次的输入不过200字节（32-bit整数） ， CPU的运算时间却能长达几分钟。 对于这种应用， 模式3a是最适合的， 能发挥多核的优势， 程序也简单。</li>
</ul>
<h4 id="适合使用单线程的场合"><a href="#适合使用单线程的场合" class="headerlink" title="适合使用单线程的场合"></a>适合使用单线程的场合</h4><p>有两种场合必须使用单线程：</p>
<ul>
<li>程序可能会fork(2)(如看门狗进程)</li>
<li>限制程序的CPU占用率</li>
</ul>
<blockquote>
<p>看门狗进程：当我们编写服务器代码时，为了让自己的服务器在意外崩溃时能够及时的重启，软件看门狗就显示出它的作用了，该看门狗进程是通过fork一个子进程（业务进程），父进程一旦捕获到了子进程的结束信号就重新再fork一个子进程来实现的。</p>
</blockquote>
<p>单线程程序能限制程序的CPU占用率， 比如在一个8核的服务器上， 一个单线程程序即便占满1个core， 其CPU使用率也只有12.5％。在这种最坏的情况下，系统还是有87.5％的计算资源可供其他服务进程使用。<br>因此对于一些辅助性的程序， 如果它必须和主要服务进程运行在同一台机器的话（比如它要监控其他服务进程的状态），那么做成单线程的能避免过分抢夺系统的计算资源。 比方说如果要把生产服务器上的日志文件压缩后备份到NFS上，那么应该使用普通单线程压缩工具（gzip&#x2F;bzip2）。</p>
<h4 id="单线程的优缺点"><a href="#单线程的优缺点" class="headerlink" title="单线程的优缺点"></a>单线程的优缺点</h4><p><strong>优点</strong></p>
<p>从编程的角度， 单线程程序的优势无须赘言：简单。</p>
<p><strong>缺点</strong></p>
<p>单线程Event loop有一个明显的缺点，它是非抢占的（non-preemptive）。假设事件a的优先级高于事件b， 处理事件a需要1ms， 处理事件b需要10ms。如果事件b稍早于a发生， 那么当事件a到来时， 程序已经离开了poll(2)调用， 并开始处理事件b。 事件a要等上10ms才有机会被处理， 总的响应时间为11ms。 这等于发生了优先级反转。 这个缺点可以用多线程来克服， 这也是多线程的主要优势。  </p>
<h4 id="适合使用多线程的场合"><a href="#适合使用多线程的场合" class="headerlink" title="适合使用多线程的场合"></a>适合使用多线程的场合</h4><p>多线程的适用场景是： 提高响应速度， 让IO和“计算”相互重叠， 降低延迟。 虽然多线程不能提高绝对性能， 但能提高平均响应性<br>能。  </p>
<p>一个程序要做成多线程的， 大致要满足：</p>
<ul>
<li>有多个CPU可用。 单核机器上多线程没有性能优势（但或许能简化并发业务逻辑的实现） 。</li>
<li>线程间有共享数据， 即内存中的全局状态。 如果没有共享数据，用模型3b就行。 虽然我们应该把线程间的共享数据降到最低， 但不代表没有。</li>
<li>共享的数据是可以修改的， 而不是静态的常量表。 如果数据不能修改， 那么可以在进程间用shared memory， 模式3就能胜任。</li>
<li>提供非均质的服务。 即事件的响应有优先级差异， 我们可以用专门的线程来处理优先级高的事件。 防止优先级反转。</li>
<li>latency和throughput同样重要， 不是逻辑简单的IO bound或CPU bound程序。 换言之， 程序要有相当的计算量。</li>
<li>利用异步操作。 比如logging。 无论往磁盘写log file， 还是往log server发送消息都不应该阻塞critical path。</li>
<li>能scale up。 一个好的多线程程序应该能享受增加CPU数目带来的好处， 目前主流是8核， 很快就会用到16核的机器了。</li>
<li>具有可预测的性能。 随着负载增加， 性能缓慢下降， 超过某个临界点之后会急速下降。 线程数目一般不随负载变化。</li>
<li>多线程能有效地划分责任与功能， 让每个线程的逻辑比较简单，任务单一， 便于编码。 而不是把所有逻辑都塞到一个event loop里， 不同类别的事件之间相互影响。</li>
</ul>
<p>举个例子，假设要管理一个Linux服务器机群， 这个机群里有8个计算节点， 1个控制节点。 机器的配置都是一样的， 双路四核CPU， 千兆网互联。 现在需要编写一个简单的机群管理软件（参考LLNL的SLURM20），这个软件由3个程序组成：</p>
<ul>
<li>运行在控制节点上的master， 这个程序监视并控制整个机群的状态。</li>
<li>运行在每个计算节点上的slave， 负责启动和终止job， 并监控本机的资源。</li>
<li>供最终用户使用的client命令行工具， 用于提交job。</li>
</ul>
<p>根据前面的分析， slave是个“看门狗进程”， 它会启动别的job进程， 因此必须是个单线程程序。 另外它不应该占用太多的CPU资源， 这<br>也适合单线程模型。 master应该是个模式2的多线程程序，原因如下：</p>
<ul>
<li>它独占一台8核的机器， 如果用模型1， 等于浪费了87.5％的CPU资源。</li>
<li>整个机群的状态应该能完全放在内存中， 这些状态是共享且可变的。 如果用模式3， 那么进程之间的状态同步会成大问题。 而如果大量使用共享内存， 则等于是掩耳盗铃， 是披着多进程外衣的多线程程序。因为一个进程一旦在临界区内阻塞或crash， 其他进程会全部死锁。</li>
<li>master的主要性能指标不是throughput， 而是latency， 即尽快地响应各种事件。 它几乎不会出现把IO或CPU跑满的情况。</li>
<li>master监控的事件有优先级区别， 一个程序正常运行结束和异常崩溃的处理优先级不同， 计算节点的磁盘满了和机箱温度过高这两种报警条件的优先级也不同。 如果用单线程， 则可能会出现优先级反转。</li>
<li>假设master和每个slave之间用一个TCP连接， 那么master采用2个或4个IO线程来处理8个TCP connections能有效地降低延迟。</li>
<li>master要异步地往本地硬盘写log， 这要求logging library有自己的IO线程。</li>
<li>master有可能要读写数据库， 那么数据库连接这个第三方library可能有自己的线程， 并回调master的代码。</li>
<li>master要服务于多个clients， 用多线程也能降低客户响应时间。 也就是说它可以再用2个IO线程专门处理和clients的通信。</li>
<li>master还可以提供一个monitor接口， 用来广播推送（pushing） 机群的状态， 这样用户不用主动轮询（polling） 。 这个功能如果用单独的线程来做， 会比较容易实现， 不会搞乱其他主要功能。</li>
</ul>
<p>最终master一共开了10个线程：</p>
<ul>
<li>4个用于和slaves通信的IO线程。</li>
<li>1个logging线程。</li>
<li>1个数据库IO线程。</li>
<li>2个和clients通信的IO线程。</li>
<li>1个主线程， 用于做些背景工作， 比如job调度。</li>
<li>1个pushing线程， 用于主动广播机群的状态。</li>
</ul>
<p>虽然线程数目略多于core数目， 但是这些线程很多时候都是空闲的， 可以依赖OS的进程调度来保证可控的延迟。  </p>
<p>综上所述， master用多线程方式编写是自然且高效的  。</p>
<p>一个多线程服务程序中的线程大致可分为3类：</p>
<ul>
<li>IO线程， 这类线程的主循环是IO multiplexing， 阻塞地等在select&#x2F;poll&#x2F;epoll_wait系统调用上。 这类线程也处理定时事件。 当然它的功能不止IO， 有些简单计算也可以放入其中， 比如消息的编码或解码。</li>
<li>计算线程， 这类线程的主循环是blocking queue， 阻塞地等在condition variable上。 这类线程一般位于thread pool中。 这种线程通常不涉及IO， 一般要避免任何阻塞操作。</li>
<li>第三方库所用的线程， 比如logging，又比如database connection。</li>
</ul>
<p>服务器程序一般不会频繁地启动和终止线程。 甚至， 在我写过的程序里， create thread只在程序启动的时候调用， 在服务运行期间是不调用的。</p>
<h4 id="多线程答疑"><a href="#多线程答疑" class="headerlink" title="多线程答疑"></a>多线程答疑</h4><p><strong>多线程能提高并发度吗？</strong><br>如果指的是“并发连接数”， 则不能。32位虚拟地址空间最多支持开300线程左右，这远远低于基于事件的单线程程序所能轻松达到的并<br>发连接数（成千上万）。所谓“基于事件”， 指的是用IO multiplexing event loop的编程模型， 又称Reactor模式， 在前文中已有介<br>绍。<br>那么采用前文中推荐的one loop per thread呢？ 至少不逊于单线程程序。 实际上单个event loop处理1万个并发长连接并不罕见， 一个multiloop的多线程程序应该能轻松支持5万并发链接。<br>小结：thread per connection不适合高并发场合， 其scalability不佳。one loop per thread的并发度足够大， 且与CPU数目成正比  </p>
<p><strong>多线程能提高吞吐量吗？</strong><br>对于计算密集型服务， 不能。<br>假设有一个耗时的计算服务， 用单线程算需要0.8s。 在一台8核的机器上， 我们可以启动8个线程一起对外服务（如果内存够用， 启动8个进程也一样） 。 这样完成单个计算仍然要0.8s， 但是由于这些进程的计算可以同时进行， 理想情况下吞吐量可以从单线程的1.25qps（query per second） 上升到10qps。（实际情况可能要打个八折——如果不是打对折的话。）</p>
<p>假如改用并行算法， 用8个核一起算， 理论上如果完全并行，加速比高达8， 那么计算时间是0.1s， 吞吐量还是10qps， 但是首次请求的响应时间却降低了很多。 实际上根据Amdahl’s law， 即便算法的并行度高达95％， 8核的加速比也只有6， 计算时间为0.133s， 这样会造成吞吐量下降为7.5qps。 不过以此为代价， 换得响应时间的提升， 在有些应用场合也是值得的  </p>
<p><strong>多线程能降低响应时间吗？</strong><br>如果设计合理， 充分利用多核资源的话， 可以。 在突发（burst） 请求时效果尤为明显。  </p>
<p><strong>多线程程序如何让IO和“计算”相互重叠， 降低latency？</strong><br>基本思路是， 把IO操作（通常是写操作） 通过Blocking Queue交给别的线程去做， 自己不必等待。</p>
<p>例1:日志（logging） 在多线程服务器程序中，日志（logging）至关重要， 本例仅考虑写log file的情况， 不考虑log server。<br>在一次请求响应中，可能要写多条日志消息，而如果用同步的方式写文件（fprintf或fwrite），多半会降低性能， 因为：</p>
<ul>
<li>文件操作一般比较慢， 服务线程会等在IO上， 让CPU闲置， 增加响应时间。</li>
<li>就算有buffer， 还是不灵。 多个线程一起写， 为了不至于把buffer写错乱， 往往要加锁。 这会让服务线程互相等待， 降低并发度。 （同时用多个log文件不是办法， 除非你有多个磁盘，且保证log files分散在不同的磁盘上，否则还是要受到磁盘IO瓶颈的制约。）</li>
</ul>
<p>解决办法是单独用一个logging线程， 负责写磁盘文件，通过一个或多个Blocking Queue对外提供接口。 别的线程要写日志的时候， 先把消息（字符串） 准备好， 然后往queue里一塞就行， 基本不用等待。 这样服务线程的计算就和logging线程的磁盘IO相互重叠， 降低了服务线程的响应时间。</p>
<p>尽管logging很重要， 但它不是程序的主要逻辑， 因此对程序的结构影响越小越好， 最好能简单到如同一条printf语句， 且不用担心其他性能开销。 而一个好的多线程异步logging库能帮我们做到这一点。</p>
<p><strong>除了你推荐的Reactor＋thread poll，还有别的多线程编程模型吗？</strong><br>有， Proactor。如果一次请求响应中要和别的进程打多次交道， 那么Proactor模型往往能做到更高的并发度。当然， 代价是代码变得支离破碎， 难以理解。<br>举HTTP proxy为例， 一次HTTP proxy的请求如果没有命中本地cache， 那么它多半会：</p>
<ul>
<li>解析域名（不要小看这一步， 对于一个陌生的域名， 解析可能要花几秒的时间） ；</li>
<li>建立连接；</li>
<li>发送HTTP请求；</li>
<li>等待对方回应；</li>
<li>把结果返回给客户。</li>
</ul>
<p>这5步中跟2个server发生了3次round-trip， 每次都可能花几百毫秒：</p>
<ul>
<li>向DNS问域名， 等待回复；</li>
<li>向对方的HTTP服务器发起连接， 等待TCP三路握手完成；</li>
<li>向对方发送HTTP request， 等待对方response。</li>
</ul>
<p>而实际上HTTP proxy本身的运算量不大，如果用线程池， 池中线程的数目会很庞大， 不利于操作系统的管理调度。这时我们有两个解决思路：</p>
<ol>
<li><p>把“域名已解析”、 “连接已建立”、 “对方已完成响应”做成event， 继续按照Reactor的方式来编程。 这样一来， 每次客户请求就不能用一个函数从头到尾执行完成， 而要分成多个阶段， 并且要管理好请求的状态（“目前到了第几步？ ”） 。</p>
</li>
<li><p>用回调函数， 让系统来把任务串起来。 比如收到用户请求， 如果没有命中本地缓存， 那么需要执行：</p>
<ul>
<li><p>立刻发起异步的DNS解析startDNSResolve()， 告诉系统在解析完之后调用DNSResolved()函数；</p>
</li>
<li><p>在DNSResolved()中， 发起TCP连接请求， 告诉系统在连接建立之后调用connectionEstablished()；</p>
</li>
<li><p>在connectionEstablished()中发送HTTP request， 告诉系统在收到响应之后调用httpResponsed()；</p>
</li>
<li><p>最后，在httpResponsed()里把结果返回给客户。</p>
</li>
</ul>
</li>
</ol>
<p>NET大量采用的BeginInvoke&#x2F;EndInvoke操作也是这个编程模式。 当然， 对于不熟悉这种编程方式的人， 代码会显得很难看。 有关Proactor模式的例子可参看Boost.Asio的文档， 这里不再多说。</p>
<p>Proactor模式依赖操作系统或库来高效地调度这些子任务， 每个子任务都不会阻塞， 因此能用比较少的线程达到很高的IO并发度。</p>
<p>Proactor能提高吞吐， 但不能降低延迟。 另外， 在没有语言直接支持的情况下，Proactor模式让代码非常破碎， 在C++中使用Proactor是很痛苦的。 因此最好在“线程”很廉价的语言中使用这种方式， 这时runtime往往会屏蔽细节， 程序用单线程阻塞IO的方式来处理TCP连接。  </p>
<p><strong>模式2和模式3a该如何取舍？</strong><br>模式2是一个多线程的进程， 模式3a是多个相同的单线程进程。</p>
<p>我认为， 在其他条件相同的情况下， 可以根据工作集（work set）的大小来取舍。 工作集是指服务程序响应一次请求所访问的内存大小。如果工作集较大， 那么就用多线程， 避免CPU cache换入换出， 影响性能； 否则， 就用单线程多进程， 享受单线程编程的便利。 </p>
<p>举例来说，如果程序有一个较大的本地cache， 用于缓存一些基础参考数据（in-memory look-up table），几乎每次请求都会访问cache， 那么多线程更适合一些， 因为可以避免每个进程都自己保留一份cache， 增加内存使用。</p>
<p>memcached这个内存消耗大户用多线程服务端就比在同一台机器上运行多个memcached instance要好。（但是如果你在16GiB内存的机器上运行32-bit memcached， 那么此时多instance是必需的。 ）</p>
<p>求解Sudoku用不了多大内存。 如果单线程编程更方便的话， 可以用单线程多进程来做。再在前面加一个单线程的load balancer，仿<br>lighttpd＋fastcgi的成例。</p>
<p>线程不能减少工作量， 即不能减少CPU时间。 如果解决一个问题需要执行一亿条指令 ，那么用多线程只会让这个数字增加。 但是通过合理调配这一亿条指令在多个核上的执行情况， 我们能让工期提早结束。 这听上去像统筹方法， 其实也确实是统筹方法。  </p>
<h2 id="C-多线程系统编程精要"><a href="#C-多线程系统编程精要" class="headerlink" title="C++多线程系统编程精要"></a>C++多线程系统编程精要</h2><p>学习多线程编程面临的最大的思维方式的转变有两点：</p>
<ul>
<li>当前线程可能随时会被切换出去， 或者说被抢占（preempt）了。</li>
<li>多线程程序中事件的发生顺序不再有全局统一的先后关系</li>
</ul>
<p>当线程被切换回来继续执行下一条语句（指令） 的时候， 全局数据（包括当前进程在操作系统内核中的状态） 可能已经被其他线程修改<br>了。  </p>
<p>在单CPU系统中， 理论上我们可以通过记录CPU上执行的指令的先后顺序来推演多线程的实际交织（interweaving） 运行的情况。 <strong>在多核系统中， 多个线程是并行执行的， 我们甚至没有统一的全局时钟来为每个事件编号。</strong> 在没有适当同步的情况下， 多个CPU上运行的多个线程中的事件发生先后顺序是无法确定的。 在引入适当同步后， 事件之间才有了happens-before关系  </p>
<h3 id="基本线程原语的选用"><a href="#基本线程原语的选用" class="headerlink" title="基本线程原语的选用"></a>基本线程原语的选用</h3><p>用C&#x2F;C++编写跨平台的多线程程序不是普遍的需求， 因此本书只谈现代Linux下的多线程编程。   </p>
<p>POSIX threads的函数有110多个，真正常用的不过十几个，这11个最基本的Pthreads函数是：</p>
<ul>
<li>2个： 线程的创建和等待结束（join）。</li>
<li>4个： mutex的创建、 销毁、 加锁、 解锁。</li>
<li>5个： 条件变量的创建、 销毁、 等待、 通知、 广播。</li>
</ul>
<p><strong>用这三样东西（thread、 mutex、condition） 可以完成任何多线程编程任务。</strong> 当然我们一般也不会直接使用它们（mutex除外） ， 而是使用更高层的封装， 例如ThreadPool和CountDownLatch等。</p>
<p>除此之外， Pthreads还提供了其他一些原语， 有些是可以酌情使用的：</p>
<ul>
<li>pthread_once。其实不如直接用全局变量。</li>
<li>pthread_key。 可以考虑用__thread替换之。 不建议使用：</li>
<li>pthread_rwlock。读写锁通常应慎用</li>
<li>sem_。 避免用信号量（semaphore）。它的功能与条件变量重合， 但容易用错。</li>
<li>pthread_{cancel, kill}。 程序中出现了它们， 则通常意味着设计出了问题</li>
</ul>
<h3 id="C-x2F-C-系统库的线程安全性"><a href="#C-x2F-C-系统库的线程安全性" class="headerlink" title="C&#x2F;C++系统库的线程安全性"></a>C&#x2F;C++系统库的线程安全性</h3><p>线程的出现立刻给系统函数库带来了冲击， 破坏了20年来一贯的编程传统和假定。如：</p>
<ul>
<li>errno不再是一个全局变量， 因为每个线程可能会执行不同的系统库函数。</li>
<li>有些“纯函数”不受影响， 例如memset&#x2F;strcpy&#x2F;snprintf等等。</li>
<li>有些影响全局状态或者有副作用的函数可以通过加锁来实现线程安全， 例如malloc&#x2F;free、 printf、 fread&#x2F;fseek等等。</li>
<li>有些返回或使用静态空间的函数不可能做到线程安全， 因此要提供另外的版本， 例如asctime_r&#x2F;ctime_r&#x2F;gmtime_r、 stderror_r、strtok_r等等。</li>
<li>传统的fork()并发模型不再适用于多线程程序。</li>
</ul>
<p>现在glibc库函数大部分都是线程安全的。 特别是FILE*系列函数是安全的， glibc甚至提供了非线程安全的版本以应对某些特殊场合的性能需求。 <strong>尽管单个函数是线程安全的， 但两个或多个函数放到一起就不再安全了。</strong> 例如fseek()和fread()都是安全的， 但是对某个文件“先seek再read”这两步操作中间有可能会被打断， 其他线程有可能趁机修改了文件的当前位置， 让程序逻辑无法正确执行。在这种情况下， 我们可以用flockfile(FILE*)和funlockfile(FILE*)函数来显式地加锁。 并且由于FILE*的锁是可重入的， 加锁之后再调用fread()不会造成死锁。  </p>
<p>由此可见， 编写线程安全程序的一个难点在于线程安全是不可组合的（composable），一个函数foo()调用了两个线程安全的函数， 而这个foo()函数本身很可能不是线程安全的。 即便现在大多数glibc库函数是线程安全的， 我们也不能像写单线程程序那样编写代码。   </p>
<ul>
<li>不用担心系统调用的线程安全性、因为系统调用对于用户态程序来说是原子的。但是需要注意它的使用对内核状态的改变可能会影响其他线程</li>
<li>C++标准容器库和std::string 不是线程安全的，只有std::allocator是线程安全的。这是为了避免不必要的性能开销  </li>
<li>C++库中的绝大多数泛型算法是线程安全的,因为这些都是无状态纯函数。 只要输入区间是线程安全的， 那么泛型函数就是线程安<br>全的。  </li>
<li>C++的iostream不是线程安全的。因为在一行中连续流式输出等价于多次函数调用，即便ostream::operator&lt;&lt;()做到了线程安全， 也不能保证其他线程不会在两次函数调用之间向stdout输出其他字符。</li>
</ul>
<h3 id="Linux上的线程标识"><a href="#Linux上的线程标识" class="headerlink" title="Linux上的线程标识"></a>Linux上的线程标识</h3><p>POSIX threads库用pthread_t作为当前进程的标识符。pthread_t不一定是一个数值类型（整数或指针） ， 也有可能是一个结构体， 因此Pthreads专门提供了pthread_equal函数用于对比两个线程标识符是否相等。 这就带来一系列问题， 包括：</p>
<ul>
<li>无法打印输出pthread_t， 因为不知道其确切类型。 也就没法在日志中用它表示当前线程的id。</li>
<li>无法比较pthread_t的大小或计算其hash值， 因此无法用作关联容器的key。</li>
<li>无法定义一个非法的pthread_t值， 用来表示绝对不可能存在的线程id， 因此MutexLock class没有办法有效判断当前线程是否已经持有本锁。</li>
<li>pthread_t值只在进程内有意义， 与操作系统的任务调度之间无法建立有效关联。 比方说在&#x2F;proc文件系统中找不到pthread_t对应的task。</li>
</ul>
<p>另外， glibc的Pthreads实现实际上把pthread_t用作一个结构体指针（它的类型是unsigned long） ， 指向一块动态分配的内存， 而且这块内存是反复使用的。 这就造成pthread_t的值很容易重复。 <strong>Pthreads只保证同一进程之内， 同一时刻的各个线程的id不同； 不能保证同一进程先后多个线程具有不同的id， 更不要说一台机器上多个进程之间的id唯一性了</strong>。  </p>
<p>因此， pthread_t并不适合用作程序中对线程的标识符。</p>
<p><strong>在Linux上，建议使用gettid(2)系统调用的返回值作为线程id</strong>， 这么做的好处有：</p>
<ul>
<li>它的类型是pid_t， 其值通常是一个小整数， 便于在日志中输出。</li>
<li>在现代Linux中， 它直接表示内核的任务调度id， 因此在&#x2F;proc文件系统中可以轻易找到对应项： &#x2F;proc&#x2F;tid或&#x2F;prod&#x2F;pid&#x2F;task&#x2F;tid。</li>
<li>在其他系统工具中也容易定位到具体某一个线程， 例如在top(1)中我们可以按线程列出任务， 然后找出CPU使用率最高的线程id， 再根据程序日志判断到底哪一个线程在耗用CPU。</li>
<li>任何时刻都是全局唯一的， 并且由于Linux分配新pid采用递增轮回办法， 短时间内启动的多个线程也会具有不同的线程id。</li>
<li>0是非法值， 因为操作系统第一个进程init的pid是1。</li>
</ul>
<h3 id="线程的创建与销毁的守则"><a href="#线程的创建与销毁的守则" class="headerlink" title="线程的创建与销毁的守则"></a>线程的创建与销毁的守则</h3><p>线程的创建和销毁是编写多线程程序的基本要素</p>
<p><strong>线程的创建原则：</strong></p>
<ul>
<li><p>程序库不应该在未提前告知的情况下创建自己的“背景线程”</p>
</li>
<li><p>尽量用相同的方式创建线程</p>
</li>
<li><p>进入main函数之前不应该启动线程</p>
</li>
<li><p>程序中线程的创建最好在初始化阶段全部完成</p>
</li>
</ul>
<p>原因如下：</p>
<p>线程是稀缺资源，  因此我们在设计一个服务端程序的时候要精心规划线程的数目， 特别是根据机器的CPU数目来设置工作线程的数目， 并为关键任务保留足够的计算资源。 如果程序库在背地里使用了额外的线程来执行任务， 我们这种资源规划就漏算了。 可能会导致高估系统的可用资源，结果处理关键任务不及时， 达不到预设的性能指标。还有一个重要原因是， 一旦程序中有不止一个线程， 就很难安全地fork()了 。 因此“库”不能偷偷创建线程。 如果确实有必要使用背景线程， 至少应该让使用者知道。</p>
<p>理想情况下， 程序里的线程都是用同一个class创建的（muduo::Thread），这样容易在线程的启动和销毁阶段做一些统一的簿<br>记（bookkeeping） 工作。 比如说调用一次muduo::CurrentThread::tid()把当前线程id缓存起来， 以后再取线程id就不会陷入内核了。 也可以统计当前有多少活动线程， 进程一共创建了多少线程， 每个线程的用途分别是什么。但是这不是总能做到的， 有些第三方库（C语言库） 会自己启动线程， 这样的“野生”线程就没有纳入全局的ThreadManager管理之中。muduo::CurrentThread::tid()必须要考虑被这种“野生”线程调用的可能，因此它必须每次都检查缓存的线程id是否有效， 而不能假定在线程启动阶段已经缓存好了id， 直接返回缓存值就行了。 如果库提供异步回调，一定要明确说明会在哪个（哪些） 线程调用用户提供的回调函数， 这样用户可以知道在回调函数中能不能执行耗时的操作， 会不会阻塞其他任务的执行。</p>
<p>在main()函数之前不应该启动线程， 因为这会影响全局对象的安全构造。 C++保证在进入main()之前完成全局对象的构造。同时，各个编译单元之间的对象构造顺序是不确定的， 我们也有一些办法来影响初始化顺序， 保证在初始化某个全局对象时使用到的其他全局对象都是构造完成的。 但无论如何这些全局对象的构造是依次进行的，都在主线程中完成， 无须考虑并发与线程安全。如果其中一个全局对象创建了线程， 那就危险了。 因为这破坏了初始化全局对象的基本假设。万一将来代码改动之后造成该线程访问了未经初始化的全局对象， 那么这种隐晦错误查起来就很费劲了。 或许你想用锁来保证全局对象初始化完成， 但是怎么保证这个全局的锁对象的构造能在线程启动之前完成呢？ 因此，<strong>全局对象不能创建线程</strong>。 如果一个库需要创建线程， 那么应该进入main()函数之后再调用库的初始化函数做。  </p>
<p>不要为了每个计算任务， 每次请求去创建线程。 一般也不会为每个网络连接创建线程， 除非并发连接数与CPU数相近。 一个服务程序的线程数目应该与当前负载无关， 而应该与机器的CPU数目有关， 即load average有比较小（最好不大于CPU数目） 的上限。 这样尽量避免出现thrashing， 不会因为负载急剧增加而导致机器失去正常响应。 这么做的重要原因是， 在机器失去响应期间， 我们无法探查它究竟在做什么， 也没办法立刻终止有问题的进程， 防止损害进一步扩大。 <strong>如果有实时性方面的要求， 线程数目不应该超过CPU数目</strong>， 这样可以基本保证新任务总能及时得到执行， 因为总有CPU是空闲的。 <strong>最好在程序的初始化阶段创建全部工作线程， 在程序运行期间不再创建或销毁线程。</strong> 借助muduo::ThreadPool和muduo::EventLoop， 我们很容易就能把计算任务和IO任务分配到已有的线程， 代价只有新建线程的几分之一。  </p>
<p><strong>线程的销毁方式：</strong></p>
<ul>
<li><p>自然死亡。从线程的主函数返回，线程正常退出</p>
</li>
<li><p>非正常死亡，抛出异常或触发致命信号</p>
</li>
<li><p>自杀。 自己调用pthread_exit()退出</p>
</li>
<li><p>他杀。其他线程调用pthread_cancle()</p>
</li>
</ul>
<p><strong>注意，线程正常退出的方式只有一个，自然死亡，任何从外部强行终止线程的做法和想法都是错误的</strong></p>
<p>因为强行终止线程的话（无论是自杀还是他杀），它没有机会清理资源。 也没有机会释放已经持有的锁，其他线程如果再想对同一个mutex加锁， 那么就会立刻死锁。  </p>
<p>如果确实需要强行终止一个耗时很长的计算任务， 而又不想在计算期间周期性地检查某个全局退出标志， 那么可以考虑把那一部分代码<br>fork()为新的进程， 这样杀一个进程比杀本进程内的线程要安全得多。 当然， fork()的新进程与本进程的通信方式也要慎重选取， 最好用文件描述符（pipe(2)&#x2F;socketpair(2)&#x2F;TCP socket）来收发数据， 而不要用共享内存和跨进程的互斥器等IPC， 因为这样仍然有死锁的可能。  </p>
<p>最后， 我认为<strong>如果能做到前面提到的“程序中线程的创建最好能在初始化阶段全部完成”， 则线程是不必销毁的</strong>， 伴随进程一直运行， 彻<br>底避开了线程安全退出可能面临的各种困难， 包括Thread对象生命期管理、 资源释放等等。  </p>
<h4 id="exit-3-在C-中不是线程安全的"><a href="#exit-3-在C-中不是线程安全的" class="headerlink" title="exit(3)在C++中不是线程安全的"></a>exit(3)在C++中不是线程安全的</h4><p><strong>exit(3)函数在C++中的作用除了终止进程， 还会析构全局对象和已经构造完的函数静态对象</strong>。 这有潜在的死锁可能，还有可能导致其他线程在调用全局对象时对象已被析构，所以多线程要慎用exit()</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">callExit</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GlobalObject</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">doit</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">MutexLockGuard <span class="title">lock</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">        <span class="built_in">callExit</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ~<span class="built_in">GlobalObject</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">MutexLockGuard <span class="title">lock</span><span class="params">(mutex_)</span></span>; <span class="comment">//发生死锁        </span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    MutexLock mutex_;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">GlobalObject g_obj;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    g_obj.<span class="built_in">doit</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>GlobalObject::doit()函数辗转调用了exit()， 从而触发了全局对象g_obj的析构。 GlobalObject的析构函数会试图加锁mutex_， 而此时<br>mutex_已经被GlobalObject::doit()锁住了， 于是造成了死锁。  </p>
<p>这其实不是exit()的过错， 而是全局对象析构的问题。 C++标准没有照顾全局对象在多线程环境下的析构， 据我看似乎也没有更好的办法。<strong>如果确实需要主动结束线程， 则可以考虑用_exit(2)系统调用。</strong> 它不会试图析构全局对象， 但是也不会执行其他任何清理工作， 比如flush标准输出。<br>由此可见， 安全地退出一个多线程的程序并不是一件容易的事情。何况这里还没有涉及如何安全地退出其他正在运行的线程， 这<strong>需要精心设计共享对象的析构顺序， 防止各个线程在退出时访问已失效的对象。在编写长期运行的多线程服务程序的时候， 可以不必追求安全地退出，而是让进程进入拒绝服务状态， 然后就可以直接杀掉了。</strong>  </p>
<h3 id="善用-thread关键字"><a href="#善用-thread关键字" class="headerlink" title="善用__thread关键字"></a>善用__thread关键字</h3><p>__thread是GCC内置的线程局部存储设施（thread local storage）。它的实现非常高效， 比pthread_key_t快很多， _thread变量的存取效率可与全局变量相比 。</p>
<p>_thread变量每一个线程有一份独立实体，各个线程的值互不干扰。可以用来修饰那些带有全局性且值可能变，但是又不值得用全局锁保护的变量。</p>
<p><strong>_thread使用规则： 只能用于修饰POD类型， 不能修饰class类型，因为无法自动调用构造函数和析构函数。</strong> _thread可以用于修饰全局变量、 函数内的静态变量， 但是不能用于修饰函数的局部变量或者class的普通成员变量。 另外， _thread变量的初始化只能用编译期常量。 例如：  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">_thread string <span class="title">obj</span><span class="params">(<span class="string">&quot;hufei&quot;</span>)</span></span>; <span class="comment">//错误，不能调用对象的构造函数</span></span><br><span class="line">_thread string* obj = <span class="keyword">new</span> string; <span class="comment">//错误，初始化必须用编译期常量</span></span><br><span class="line">_thread string* obj = <span class="literal">NULL</span>; <span class="comment">//正确，记住需要手工初始化并销毁对象    </span></span><br></pre></td></tr></table></figure>

<p>使用举例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">__thread <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//创建线程A</span></span><br><span class="line">    <span class="comment">//创建线程B</span></span><br><span class="line">    <span class="comment">//此时A和B线程都有一个实体 count，二者并不相同</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="多线程与IO"><a href="#多线程与IO" class="headerlink" title="多线程与IO"></a>多线程与IO</h3><p>在进行多线程网络编程的时候，能否多个线程同时读写同一个socket文件描述符？ </p>
<p>首先， 操作文件描述符的系统调用本身是线程安全的， 我们不用担心多个线程同时操作文件描述符会造成进程崩溃或内核崩溃。但是， 多个线程同时操作同一个socket文件描述符确实很麻烦， 我认为是得不偿失的。 需要考虑的情况如下：  </p>
<ul>
<li>如果一个线程正在阻塞地read(2)某个socket， 而另一个线程close(2)了此socket。</li>
<li>如果一个线程正在阻塞地accept(2)某个listening socket， 而另一个线程close(2)了此socket。</li>
<li>更糟糕的是， 一个线程正准备read(2)某个socket， 而另一个线程close(2)了此socket； 第三个线程又恰好open(2)了另一个文件描述符， 其fd号码正好与前面的socket相同。 这样程序的逻辑就混乱了。</li>
</ul>
<p>现在假设不考虑关闭文件描述符， 只考虑读和写， 情况也不见得多好。 因为socket读写的特点是不保证完整性， 读100字节有可能只返回20字节， 写操作也是一样的。</p>
<ul>
<li>如果两个线程同时read同一个TCP socket， 两个线程几乎同时各自收到一部分数据， 如何把数据拼成完整的消息？ 如何知道哪部分数据先到达？</li>
<li>如果两个线程同时write同一个TCP socket， 每个线程都只发出去半条消息， 那接收方收到数据如何处理？</li>
<li>如果给每个TCP socket配一把锁， 让同时只能有一个线程读或写此socket， 似乎可以“解决”问题， 但这样还不如直接始终让同一个线程来操作此socket来得简单</li>
</ul>
<p>如此看来， 理论上只有read和write可以分到两个线程去， 因为TCP socket是双向IO。 问题是真的值得把read和write拆开成两个线程吗？  </p>
<p>为了简单起见， 我认为多线程程序应该遵循的原则是： <strong>每个文件描述符只由一个线程操作</strong>， 从而轻松解决消息收发的顺序性问题， 也避免了关闭文件描述符的各种race condition。 一个线程可以操作多个文件描述符， 但一个线程不能操作别的线程拥有的文件描述符。   </p>
<p>epoll也遵循相同的原则。  <strong>我们应该把对同一个epoll fd的操作（添加、 删除、 修改、 等待）都放到同一个线程中执行。</strong></p>
<p> 这条规则有两个例外： 对于磁盘文件， 在必要的时候多个线程可以同时调用pread(2)&#x2F;pwrite(2)来读写同一个文件； 对于UDP， 由于协议本身保证消息的原子性， 在适当的条件下（比如消息之间彼此独立） 可以多个线程同时读写同一个UDP文件描述符。  </p>
<h3 id="用RAII包装文件描述符"><a href="#用RAII包装文件描述符" class="headerlink" title="用RAII包装文件描述符"></a>用RAII包装文件描述符</h3><p>linux的文件描述符是小整数，程序刚启动时候，0是标准输入，1是标准输出，2是标准错误。因此新打开的文件描述符是3，因为POSIX标准要求每次新打开文件（含socket） 的时候必须使用当前最小可用的文件描述符号码。</p>
<p>POSIX这种分配文件描述符的方式稍不注意就会造成串话。   如：</p>
<ul>
<li>第一个线程read某个socket，第二个线程几乎同时close此socket，第三个线程又打开了另一个文件描述符，与之前的相同，则会导致第一个线程会读不到属于他的数据。不仅如此， 还把第三个线程的功能也破坏了， 因为第一个线程把数据读走了  </li>
<li>一个线程从fd＝8收到了比较耗时的请求， 它开始处理这个请求， 并记住要把响应结果发给fd＝8。 但是在处理过程中， fd＝8断开连接， 被关闭了，又有新的连接到来， 碰巧使用了相同的fd＝8。 当线程完成响应的计算， 把结果发给fd＝8时， 接收方已经物是人非， 后果难以预料。</li>
</ul>
<p>如何解决：</p>
<ul>
<li>用全局表存储文件描述符，读写时加锁。效率太低，不推荐</li>
<li>RAII。 用Socket对象包装文件描述符， 所有对此文件描述符的读写操作都通过此对象进行， 在对象的析构函数里关闭文件描述符。 这样一来， 只要Socket对象还活着， 就不会有其他Socket对象跟它有一样的文件描述符， 也就不可能串话。（用shared_ptr来管理TcpConnection的生命期）</li>
</ul>
<h3 id="RAII与fork"><a href="#RAII与fork" class="headerlink" title="RAII与fork()"></a>RAII与fork()</h3><p>如果用RAII管理资源，在程序会fork()的情况下，可能会导致析构了不存在的资源。如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Foo foo;</span><br><span class="line">    fork();</span><br><span class="line">    foo.<span class="built_in">doit</span>();</span><br><span class="line">&#125; <span class="comment">//析构函数会被调用两次，父子进程各一次。</span></span><br></pre></td></tr></table></figure>

<p>这是因为fork()后子进程不会继承对象的所有资源，所以子进程析构时可能会析构不存在的对象。</p>
<p>fork()之后， 子进程继承了父进程的几乎全部状态， 但也有少数例外。 子进程会继承地址空间和文件描述符， <strong>因此用于管理动态内存和文件描述符的RAII class都能正常工作</strong>。 但是子进程不会继承：  </p>
<ul>
<li>父进程的内存锁， mlock(2)、 mlockall(2)。</li>
<li>父进程的文件锁， fcntl(2)。</li>
<li>父进程的某些定时器， setitimer(2)、 alarm(2)、 timer_create(2)等等。</li>
</ul>
<p>比方说用RAII技法封装timer_create()&#x2F;timer_delete()， 在子进程中析构函数调用timer_delete()可能会出错， 因为试图释放一个不存在的资源。 或者更糟糕地把其他对象持有的timer给释放了（如果碰巧新建的timer_t与之重复的话）。因此， 我们在编写服务端程序的时候， “是否允许fork()”是在一开始就应该慎重考虑的问题， 在一个没有为fork()做好准备的程序中使用fork()， 会遇到难以预料的问题。  </p>
<p>当然若fork后的子进程立即调用exec()执行其它程序隔断了父子关系则不会出现上述情形。</p>
<h3 id="多线程与fork"><a href="#多线程与fork" class="headerlink" title="多线程与fork()"></a>多线程与fork()</h3><p>多线程与fork()的协作性很差。 这是POSIX系列操作系统的历史包袱。 因为长期以来程序都是单线程的。</p>
<p>fork()一般不能在多线程程序中调用， 因为Linux的fork()只克隆当前线程的thread of control， 不克隆其他线程。 <strong>fork()之后， 除了当前线程之外， 其他线程都消失了。</strong> 也就是说不能一下子fork()出一个和父进程一样的多线程子进程。 Linux没有forkall()这样的系统调用， forkall()其实也是很难办的（从语意上） ， 因为其他线程可能等在condition variable上， 可能阻塞在系统调用上， 可能等着mutex以跨入临界区， 还可能在密集的计算中， 这些都不好全盘搬到子进程里。</p>
<p>fork()之后子进程中只有一个线程， 其他线程都消失了， 这就造成一个危险的局面。 <strong>其他线程可能正好位于临界区之内， 持有了某个锁，而它突然死亡， 再也没有机会去解锁了。 如果子进程试图再对同一个mutex加锁， 就会立刻死锁。</strong> 在fork()之后， 子进程就相当于处于signal handler之中， 你不能调用线程安全的函数（除非它是可重入的） ， 而只能调用异步信号安全（async-signal-safe） 的函数。 比方说， fork()之后， 子进程不能调用：</p>
<ul>
<li>malloc(3)。 因为malloc()在访问全局状态时几乎肯定会加锁。</li>
<li>任何可能分配或释放内存的函数， 包括new、 map::insert()、snprintf33……</li>
<li>任何Pthreads函数。 你不能用pthread_cond_signal()去通知父进程，只能通过读写pipe(2)来同步34。</li>
<li>printf()系列函数， 因为其他线程可能恰好持有stdout&#x2F;stderr的锁。</li>
<li>除了man 7 signal中明确列出的“signal安全”函数之外的任何函数。</li>
</ul>
<p><strong>总结</strong>：多线程下，fork()只会克隆当前线程，并且还有造成死锁的风险，不要在多线程下使用fork，除非fork后的子进程立即调用exec()执行其它程序</p>
<h3 id="多线程与signal"><a href="#多线程与signal" class="headerlink" title="多线程与signal"></a>多线程与signal</h3><p>Linux&#x2F;Unix的信号（signal） 与多线程可谓是水火不容，signal会打断正在运行的thread of control， 在signal handler中只能调用<br>可重入（reentrant）函数(线程安全不一定可重入)。</p>
<p>还有一点， <strong>如果signal handler中需要修改全局数据， 那么被修改的变量必须是sig_atomic_t类型的。</strong> 否则被打断的函数在恢复执行后很可能不能立刻看到signal handler改动后的数据， 因为编译器有可能假定这个变量不会被他处修改， 从而优化了内存访问。  </p>
<p>在多线程时代， signal的语义更为复杂。 信号分为两类： 发送给某一线程（SIGSEGV） ， 发送给进程中的任一线程（SIGTERM） ， 还要考虑掩码（mask） 对信号的屏蔽等。 <strong>特别是在signal handler中不能调用任何Pthreads函数， 不能通过condition variable来通知其他线程。</strong>在多线程程序中， 使用signal的第一原则是不要使用signal。 包括：</p>
<ul>
<li>不要用signal作为IPC的手段， 包括不要用SIGUSR1等信号来触发服务端的行为。 如果确实需要， 可以用增加监听端口的方式来实现双向的、 可远程访问的进程控制。</li>
<li>也不要使用基于signal实现的定时函数， 包括alarm&#x2F;ualarm&#x2F;setitimer&#x2F;timer_create、 sleep&#x2F;usleep等等。</li>
<li>不主动处理各种异常信号（SIGTERM、 SIGINT等等） ， 只用默认语义： 结束进程。 有一个例外： SIGPIPE， 服务器程序通常的做法是忽略此信号， 否则如果对方断开连接， 而本机继续write的话， 会导致程序意外终止。</li>
<li>在没有别的替代方法的情况下（比方说需要处理SIGCHLD信号），把异步信号转换为同步的文件描述符事件。 传统的做法是在signal handler里往一个特定的pipe(2)写一个字节， 在主程序中从这个pipe读取， 从而纳入统一的IO事件处理框架中去。 现代Linux的做法是采用signalfd(2)把信号直接转换为文件描述符事件， 从而从根本上避免使用signal handler。</li>
</ul>
<blockquote>
<p>SIGPIPE信号:如果客户端关闭了socket（close），而服务端调用了一次write，服务端就会接收到一个RST Segment，如果服务端再次调用write，这个时候就会产生SIGPIPE信号，默认情况下会终止进程</p>
</blockquote>
<h3 id="多线程C-程序编写原则"><a href="#多线程C-程序编写原则" class="headerlink" title="多线程C++程序编写原则"></a>多线程C++程序编写原则</h3><ul>
<li>线程是宝贵的， 一个程序可以使用几个或十几个线程。 一台机器上不应该同时运行几百个、 几千个用户线程， 这会大大增加内核scheduler的负担， 降低整体性能。</li>
<li>线程的创建和销毁是有代价的， 一个程序最好在一开始创建所需的线程， 并一直反复使用。 不要在运行期间反复创建、 销毁线程， 如果必须这么做， 其频度最好能降到1分钟1次（ 或更低）。</li>
<li>每个线程应该有明确的职责， 例如IO线程（ 运行EventLoop::loop()，处理IO事件）、计算线程（位于ThreadPool中，负责计算） 等等。</li>
<li>线程之间的交互应该尽量简单， 理想情况下，线程之间只用消息传递（ 例如BlockingQueue） 方式交互。如果必须用锁，那么最好避免一个线程同时持有两把或更多的锁， 这样可彻底防止死锁。</li>
<li>要预先考虑清楚一个mutable shared对象将会暴露给哪些线程， 每个线程是读还是写， 读写有无可能并发进行。</li>
</ul>
<h2 id="高效的多线程日志"><a href="#高效的多线程日志" class="headerlink" title="高效的多线程日志"></a>高效的多线程日志</h2><p>日志（logging）有两种：</p>
<ul>
<li>诊断日志（diagnostic log） 即log4j等常用日志库提供的日志功能。</li>
<li>交易日志（transaction log） 即数据库的write-ahead log用于记录状态变更， 通过回放日志可以逐步恢复每一次修改之后的状态。</li>
</ul>
<p>本章的日志是前一个意思， 即文本的、 供人阅读的日志， 通常用于故障诊断和追踪（trace），也可用于性能分析。日志通常是分布式<br>系统中事故调查时的唯一线索， 用来追寻蛛丝马迹， 查出元凶。  </p>
<p>对于关键进程， 日志通常要记录：</p>
<ul>
<li>收到的每条内部消息的id（还可以包括关键字段、 长度、 hash等） ；</li>
<li>收到的每条外部消息的全文；</li>
<li>发出的每条消息的全文， 每条消息都有全局唯一的id6；</li>
<li>关键内部状态的变更， 等等。</li>
</ul>
<p>每条日志都有时间戳， 这样就能完整追踪分布式系统中一个事件的来龙去脉。 也只有这样才能查清楚发生故障时究竟发生了什么， 比如业务处理流程卡在了哪一步。</p>
<p>一个日志库大体可分为前端（frontend） 和后端（backend） 两部分。 前端是供应用程序使用的接口（API） ， 并生成日志消息（log<br>message） ； 后端则负责把日志消息写到目的地（destination）。   </p>
<p>在多线程程序中， 前端和后端都与单线程程序无甚区别， 无非是每个线程有自己的前端， 整个程序共用一个后端。 但难点在于将日志数据从多个前端高效地传输到后端。 <strong>这是一个典型的多生产者-单消费者问题</strong>， 对生产者（前端） 而言， 要尽量做到低延迟、 低CPU开销、 无阻塞； 对消费者（后端） 而言， 要做到足够大的吞吐量， 并占用较少资源。</p>
<p>对C++程序而言， 最好整个程序（包括主程序和程序库） 都使用相同的日志库， 程序有一个整体的日志输出， 而不要各个组件有各自的日志输出。 从这个意义上讲， 日志库是个singleton。  </p>
<h3 id="功能需求"><a href="#功能需求" class="headerlink" title="功能需求"></a>功能需求</h3><ul>
<li>日志消息有多种级别（ level） ， 如TRACE、 DEBUG、 INFO、WARN、 ERROR、 FATAL等。</li>
<li>日志消息可能有多个目的地（ appender） ， 如文件、 socket、SMTP等。</li>
<li>日志消息的格式可配置（ layout） ， 例如org.apache.log4j.PatternLayout。</li>
<li>可以设置运行时过滤器（ filter） ， 控制不同组件的日志消息的级别和目的地。</li>
</ul>
<p>在上面这几项中， 我认为除了第一项之外， 其余三项都是非必需的功能。  </p>
<p>日志的输出级别在运行时可调， 这样同一个可执行文件可以分别在QA测试环境的时候输出DEBUG级别的日志， 在生产环境输出INFO级<br>别的日志。调整日志的输出级别不需要重新编译， 也不需要重启进程。</p>
<p>对于分布式系统中的服务进程而言， 日志的目的地（ destination）只有一个： 本地文件。 <strong>往网络写日志消息是不靠谱的</strong>， 因为诊断日志的功能之一正是诊断网络故障。往网络写日志消息的另一个坏处是增加网络带宽消耗。</p>
<p>以本地文件为日志的destination， 那么日志文件的滚动（ rolling）是必需的， 这样可以简化日志归档（ archive）的实现。 rolling的条件通常有两个： 文件大小（ 例如每写满1GB就换下一个文件） 和时间（ 例如每天零点新建一个日志文件， 不论前一个文件有没有写满） 。 muduo日志库的LogFile会自动根据文件大小和时间来主动滚动日志文件。</p>
<p>一个典型的日志文件的文件名如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">logfile_test.2012060-144022.hostname.3605.log</span><br></pre></td></tr></table></figure>

<p>文件名由以下几部分组成：  </p>
<ul>
<li>第1部分logfile_test是进程的名字。 通常是main()函数参数中argv[0]的basename(3)， 这样容易区分究竟是哪个服务程序的日志。 必要时还可以把程序版本加进去。</li>
<li>第2部分是文件的创建时间（GMT时区）。这样很容易通过文件名来选择某一时间范围内的日志， 例如用通配符*.20120603-14*表示2012年6月3日下午2点（GMT）左右的日志文件。</li>
<li>第3部分是机器名称。这样即便把日志文件拷贝到别的机器上也能追溯其来源。</li>
<li>第4部分是进程id。如果一个程序一秒之内反复重启， 那么每次都会生成不同的日志文件。</li>
<li>第5部分是统一的后缀名.log。同样是为了便于周边配套脚本的编写。</li>
</ul>
<p><strong>日志文件压缩与归档（archive）不是日志库应有的功能</strong>， 而应该交给专门的脚本去做， 这样C++和Java的服务程序可以共享这一基础设<br>施，并且更改时也不必动业务程序， 改改周边配套脚本就行了。 </p>
<p><strong>磁盘空间监控也不是日志库的必备功能。</strong> 有人或许曾经遇到日志文件把磁盘占满的情况， 因此希望日志库能限制空间使用，例如只分配10GB磁盘空间， 用满之后就冲掉旧日志， 重复利用空间。 殊不知如果出现程序死循环拼命写日志的异常情况， 那么往往是开头的几条日志最关键， 它往往反映了引发异常（busy-loop） 的原因（例如收到某条非法消息） ， 后面都是无用的垃圾日志。</p>
<p>往文件写日志的一个常见问题是， 万一程序崩溃， 那么最后若干条日志往往就丢失了， 因为日志库不能每条消息都flush硬盘， 更不能每条日志都open&#x2F;close文件，这样性能开销太大。 muduo日志库用两个办法来应对这一点， 其一是定期（默认3秒） 将缓冲区内的日志消息flush到硬盘； 其二是每条内存中的日志消息都带有cookie（或者叫哨兵值&#x2F;sentry） ， 其值为某个函数的地址， 这样通过在core dump文件中查找cookie就能找到尚未来得及写入磁盘的消息。</p>
<p>日志消息的格式是固定的， 不需要运行时配置， 这样可节省每条日志解析格式字符串的开销。 我认为日志的格式在项目的整个生命周期几乎不会改变。   因为我们经常会为不同目的编写parse日志的脚本，可能要和一年之前的日志文件的同类数据做对比。如果在此期间日志格式变了， 势必会增加很多无谓的工作量。 如果真的需要调整消息格式， 直接修改代码并重新编译即可。   </p>
<p>日志消息格式有几个要点：</p>
<ul>
<li>尽量每条日志占一行。 这样很容易用awk、 sed、 grep等命令行工具来快速联机分析日志， 比方说要查看“2012-06-03 08:02:00”至“2012-06-03 08:02:59”这1分钟内每秒打印日志的条数（直方图），可以运行$ grep -o ‘^20120603 08:02:..’ | sort | uniq -c</li>
<li>时间戳精确到微秒。 每条消息都通过gettimeofday(2)获得当前时间， 这么做不会有什么性能损失。 因为在x86-64 Linux上，gettimeofday(2)不是系统调用， 不会陷入内核。</li>
<li>始终使用GMT时区。 对于跨洲的分布式系统而言，可省去本地时区转换的麻烦（别忘了主要西方国家大多实行夏令时），更易于追查事件的顺序。</li>
<li>打印线程id。便于分析多线程程序的时序，也可以检测死锁。这里的线程id是指调用LOG_INFO &lt;&lt;的线程。</li>
<li>打印日志级别。在线查错的时候先看看有无ERROR日志，通常可加速定位问题。</li>
<li>打印源文件名和行号。修复bug的时候不至于搞错对象。</li>
</ul>
<p>每行日志的前4个字段的宽度是固定的， 以空格分隔， 便于用脚本解析。 另外， 应该避免在日志格式（特别是消息id）中出现正则表达<br>式的元字符（meta character） ， 例如’[‘和’]’等等， 这样在用less(1)查看日志文件的时候查找字符串更加便捷。</p>
<p>运行时的日志过滤器（filter） 或许是有用的， 例如控制不同部件（程序库） 的输出日志级别， 但我认为这应该放到编译期去做， 整个程序有一个整体的输出级别就足够好了。 同时我认为一个程序同时写多个日志文件是非常罕见的需求， 这可以事后留给log archiver来分流， 不必做到日志库中。 不实现filter自然也能减小生成每条日志的运行时开销， 可以提高日志库的性能。</p>
<h3 id="性能需求"><a href="#性能需求" class="headerlink" title="性能需求"></a>性能需求</h3><p>高效性体现在几方面：</p>
<ul>
<li>每秒写几千上万条日志的时候没有明显的性能损失。</li>
<li>能应对一个进程产生大量日志数据的场景， 例如1GB&#x2F;min。</li>
<li>不阻塞正常的执行流程。</li>
<li>在多线程程序中， 不造成争用（contention） 。 这里列举一些具体的性能指标， 考虑往普通7200rpm SATA硬盘写日志文件的情况：磁盘带宽约是110MB&#x2F;s， 日志库应该能瞬时写满这个带宽（不必持续太久） 。</li>
</ul>
<p>以上是“高性能”日志库的最低指标。 如果磁盘带宽更高， 那么日志库的预期性能指标也会相应提高。  </p>
<p>muduo日志库在现在的PC上能写到每秒200万条消息， 带宽足够撑满两个千兆网连接或4个SATA组成的RAID10， 性能是达标的。<br>为了实现这样的性能指标， muduo日志库的实现有几点优化措施值得一提：</p>
<ul>
<li>时间戳字符串中的日期和时间两部分是缓存的， 一秒之内的多条日志只需重新格式化微秒部分。 </li>
<li>日志消息的前4个字段是定长的， 因此可以避免在运行期求字符串长度（不会反复调用strlen） 。 因为编译器认识memcpy()函数， 对于定长的内存复制， 会在编译期把它inline展开为高效的目标代码。</li>
<li>线程id是预先格式化为字符串， 在输出日志消息时只需简单拷贝几个字节。 见CurrentThread::tidString()。</li>
<li>每行日志消息的源文件名部分采用了编译期计算来获得basename， 避免运行期strrchr(3)开销。 见SourceFile class， 这里利用了gcc的内置函数。</li>
</ul>
<h3 id="多线程异步日志"><a href="#多线程异步日志" class="headerlink" title="多线程异步日志"></a>多线程异步日志</h3><p>线程安全的多线程日志的解决思路</p>
<ul>
<li>用一个全局锁保护IO，或者每个线程单独写一个日志文件。性能堪忧，前者造成所有线程抢占一个锁，后者会让业务线程阻塞在写磁盘操作上</li>
<li>每个进程只写一个日志文件，用一个背景线程负责收集日志消息，并写入日志文件，其他业务线程只需往这个日志线程中发送日志消息，称为“异步日志”(本文采用)</li>
</ul>
<p>在多线程服务程序中， 异步日志是必需的， 因为如果在网络IO线程或业务线程中直接往磁盘写数据的话，写操作偶尔可能阻塞长达数秒之久（原因很复杂， 可能是磁盘或磁盘控制器复位）。这可能导致请求方超时， 或者耽误发送心跳消息， 在分布式系统中更可能造成多米诺骨牌效应， 例如误报死锁引发自动failover等。 <strong>因此， 在正常的实时业务处理流程中应该彻底避免磁盘IO</strong>， 这在使用one loop per thread模型的非阻塞服务端程序中尤为重要， 因为线程是复用的， 阻塞线程意味着影响多个客户连接。</p>
<p>我们需要一个“队列”来将日志前端的数据传送到后端（日志线程） ， 但这个“队列”不必是现成的BlockingQueue&lt;std::string&gt;， 因为不<br>用每次产生一条日志消息都通知（notify()） 接收方。</p>
<p><strong>muduo日志库采用的是双缓冲（double buffering） 技术</strong>， 基本思路是准备两块buffer： A和B， 前端负责往buffer A填数据（日志消<br>息） ， 后端负责将buffer B的数据写入文件。 当buffer A写满之后， 交换A和B， 让后端将buffer A的数据写入文件， 而前端则往buffer B填入新的日志消息， 如此往复。   </p>
<p>用两个buffer的好处是在新建日志消息的时候不必等待磁盘文件操作， 也避免每条新日志消息都触发（唤醒） 后端日志线程。 换言之， 前端不是将一条条日志消息分别传送给后端， 而是将多条日志消息拼成一个大的buffer传送给后端， 相当于批处理， 减少了线程唤醒的频度， 降低开销。 另外， 为了及时将日志消息写入文件， 即便buffer A未满， 日志库也会每3秒执行一次上述交换写入操作。  </p>
<h2 id="网络编程杂谈"><a href="#网络编程杂谈" class="headerlink" title="网络编程杂谈"></a>网络编程杂谈</h2><h3 id="网络编程本质"><a href="#网络编程本质" class="headerlink" title="网络编程本质"></a>网络编程本质</h3><p>基于事件的非阻塞网络编程是编写高性能并发网络服务程序的主流模式， 头一次使用这种方式编程通常需要转换思维模式。 把原来“主动<br>调用recv(2)来接收数据， 主动调用accept(2)来接受新连接， 主动调用send(2)来发送数据”的思路换成“注册一个收数据的回调， 网络库收到数据会调用我， 直接把数据提供给我， 供我消费。 注册一个接受连接的回调， 网络库接受了新连接会回调我， 直接把新的连接对象传给我， 供我使用。 需要发送数据的时候， 只管往连接中写， 网络库会负责无阻塞地发送。 ”这种编程方式有点像Win32的消息循环， 消息循环中的代码应该避免阻塞， 否则会让整个窗口失去响应， 同理， 事件处理函数也应该避免阻塞， 否则会让网络服务失去响应。</p>
<p>我认为， TCP网络编程最本质的是处理三个半事件：</p>
<ul>
<li><p>连接的建立， 包括服务端接受（accept） 新连接和客户端成功发起（connect） 连接。 TCP连接一旦建立， 客户端和服务端是平等的， 可以各自收发数据。</p>
</li>
<li><p>连接的断开， 包括主动断开（close、 shutdown） 和被动断开（read(2)返回0） 。</p>
</li>
<li><p>消息到达， 文件描述符可读。 这是最为重要的一个事件， 对它的处理方式决定了网络编程的风格（阻塞还是非阻塞， 如何处理分包，应用层的缓冲如何设计， 等等） 。</p>
</li>
<li><p>消息发送完毕， 这算半个。 对于低流量的服务， 可以不必关心这个事件； 另外， 这里的“发送完毕”是指将数据写入操作系统的缓冲</p>
<p>区， 将由TCP协议栈负责数据的发送与重传， 不代表对方已经收到数据</p>
</li>
</ul>
<h3 id="难点"><a href="#难点" class="headerlink" title="难点"></a>难点</h3><ul>
<li>如果要主动关闭连接， 如何保证对方已经收到全部数据？ 如果应用层有缓冲（这在非阻塞网络编程中是必需的， 见下文） ， 那么如何保证先发送完缓冲区中的数据， 然后再断开连接？ 直接调用close(2)恐怕是不行的。</li>
<li>如果主动发起连接， 但是对方主动拒绝， 如何定期（带back-off地） 重试？</li>
<li>非阻塞网络编程该用边沿触发（edge trigger） 还是电平触发（leveltrigger） ？如果是电平触发， 那么什么时候关注EPOLLOUT事件？ 会不会造成busy-loop？ 如果是边沿触发， 如何防止漏读造成的饥饿？epoll(4)一定比poll(2)快吗？</li>
<li>在非阻塞网络编程中， 为什么要使用应用层发送缓冲区？ 假设应用程序需要发送40kB数据， 但是操作系统的TCP发送缓冲区只有25kB剩余空间， 那么剩下的15kB数据怎么办？ 如果等待OS缓冲区可用， 会阻塞当前线程， 因为不知道对方什么时候收到并读取数据。 因此网络库应该把这15kB数据缓存起来， 放到这个TCP链接的应用层发送缓冲区中， 等socket变得可写的时候立刻发送数据， 这样“发送”操作不会阻塞。 如果应用程序随后又要发送50kB数据， 而此时发送缓冲区中尚有未发送的数据（若干kB） ， 那么网络库应该将这50kB数据追加到发送缓冲区的末尾， 而不能立刻尝试write()， 因为这样有可能打乱数据的顺序。</li>
<li>在非阻塞网络编程中， 为什么要使用应用层接收缓冲区？ 假如一次读到的数据不够一个完整的数据包， 那么这些已经读到的数据是不是应该先暂存在某个地方， 等剩余的数据收到之后再一并处理？ 见lighttpd关于\r\n\r\n分包的bug。 假如数据是一个字节一个字节地到达， 间隔10ms， 每个字节触发一次文件描述符可读（readable） 事件， 程序是否还能正常工作？ lighttpd在这个问题上出过安全漏洞。</li>
<li>在非阻塞网络编程中， 如何设计并使用缓冲区？ 一方面我们希望减少系统调用， 一次读的数据越多越划算， 那么似乎应该准备一个大的缓冲区。 另一方面， 我们希望减少内存占用。 如果有10000个并发连接，每个连接一建立就分配各50kB的读写缓冲区(s)的话， 将占用1GB内存，而大多数时候这些缓冲区的使用率很低。 muduo用readv(2)结合栈上空间巧妙地解决了这个问题。</li>
<li>如果使用发送缓冲区， 万一接收方处理缓慢， 数据会不会一直堆积在发送方， 造成内存暴涨？ 如何做应用层的流量控制？</li>
<li>如何设计并实现定时器？ 并使之与网络IO共用一个线程， 以避免锁</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/01/22/Linux%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%9C%8D%E5%8A%A1%E7%AB%AF%E7%BC%96%E7%A8%8B%EF%BC%9A%E4%BD%BF%E7%94%A8muduo%20C++%E7%BD%91%E7%BB%9C%E5%BA%93/" data-id="cld6uioj8000aacsfgqh1cb2t" data-title="" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-linux" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/01/22/linux/" class="article-date">
  <time class="dt-published" datetime="2023-01-22T03:54:01.941Z" itemprop="datePublished">2023-01-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="linux"><a href="#linux" class="headerlink" title="linux"></a>linux</h1><h2 id="linux目录结构"><a href="#linux目录结构" class="headerlink" title="linux目录结构"></a>linux目录结构</h2><p><img src="C:\Users\hufei\AppData\Roaming\Typora\typora-user-images\linux_file.jpg" alt="linux_file"></p>
<p>在 Linux 或 Unix 操作系统中，所有的文件和目录都被组织成以一个根节点开始的倒置的树状结构。</p>
<p>文件系统的最顶层是由根目录开始的，系统使用 <strong>&#x2F;</strong> 来表示根目录。在根目录之下的既可以是目录，也可以是文件，而每一个目录中又可以包含子目录文件。如此反复就可以构成一个庞大的文件系统。</p>
<p>在Linux文件系统中有两个特殊的目录，一个用户所在的工作目录，也叫当前目录，可以使用一个点 <strong>.</strong> 来表示；另一个是当前目录的上一级目录，也叫父目录，可以使用两个点 <strong>..</strong> 来表示。</p>
<ul>
<li>. ：代表当前的目录，也可以使用 .&#x2F; 来表示；</li>
<li>.. ：代表上一层目录，也可以 ..&#x2F; 来代表。</li>
</ul>
<p>如果一个目录或文件名以一个点 . 开始，表示这个目录或文件是一个隐藏目录或文件(如：.bashrc)。即以默认方式查找时，不显示该目录或文件。</p>
<p><strong>系统启动必须：</strong></p>
<ul>
<li><p><strong>&#x2F;boot：</strong>存放的启动Linux时使用的内核文件，包括连接文件以及镜像文件。</p>
</li>
<li><p><strong>&#x2F;etc(<em>Etcetera</em>)：</strong>存放<strong>所有</strong>的系统需要的<strong>配置文件</strong>和<strong>子目录列表，</strong>包括通过系统自动安装的程序的配置文件，如nginx，mysql等配置文件。更改目录下的文件可能会导致系统不能启动</p>
</li>
<li><p>**&#x2F;lib(<em>Library</em>)**：存放基本代码库（比如c++库），其作用类似于Windows里的DLL文件。几乎所有的应用程序都需要用到这些共享库。</p>
</li>
<li><p><strong>&#x2F;sys</strong>： 这是linux2.6内核的一个很大的变化。该目录下安装了2.6内核中新出现的一个文件系统 sysfs 。sysfs文件系统集成了下面3种文件系统的信息：针对进程信息的proc文件系统、针对设备的devfs文件系统以及针对伪终端的devpts文件系统。该文件系统是内核设备树的一个直观反映。当一个内核对象被创建的时候，对应的文件和目录也在内核对象子系统中</p>
</li>
</ul>
<p><strong>指令集合：</strong></p>
<ul>
<li><p><strong>&#x2F;bin(<em>Binaries</em>)：</strong>存放着最常用的程序和指令，如文件操作</p>
</li>
<li><p><strong>&#x2F;sbin(<em>System-only binaries</em>)：</strong>只有系统管理员能使用的程序和指令，如分区、格式化操作。</p>
</li>
</ul>
<p><strong>外部文件管理：</strong></p>
<ul>
<li><p><strong>&#x2F;dev(<em>Device</em>) ：</strong>存放的是Linux的外部设备。<strong>注意：</strong>在Linux中访问设备和访问文件的方式是相同的。</p>
</li>
<li><p><strong>&#x2F;media</strong>：一般是<strong>系统自动挂载</strong>可移除的装置，挂载后装置图标<strong>会</strong>出现在桌面窗口的左边栏。如软碟、光碟、DVD、U盘、移动硬盘</p>
</li>
<li><p><strong>&#x2F;mnt(<em>Mount</em>)<strong>：一般是用于让</strong>用户自己挂载</strong>其他文件系统，挂载后装置图标<strong>不会</strong>出现在桌面窗口的左边栏。我们可以将光驱挂载在&#x2F;mnt&#x2F;上，然后进入该目录就可以查看光驱里的内容了。</p>
</li>
</ul>
<p><strong>临时文件：</strong></p>
<ul>
<li><p><strong>&#x2F;run</strong>：是一个临时文件系统，存储系统启动以来的信息。当系统重启时，这个目录下的文件应该被删掉或清除。如果你的系统上有 &#x2F;var&#x2F;run 目录，应该让它指向 run。</p>
</li>
<li><p><strong>&#x2F;lost+found</strong>：这个目录在大多数情况下都是空的。但是如果你正在工作突然停电，或是没有用正常方式关机，在你重新启动机器的时候，有些文件就会找不到应该存放的地方，对于这些文件，系统将他们放在这个目录下。</p>
</li>
<li><p><strong>&#x2F;tmp(<em>Temporary files</em>)<strong>：</strong>保存在使用完毕后可随时销毁的缓存文件。</strong>（有可能是由系统或程序产生、也有可能是用户主动放入的临时数据、系统会自动清理）</p>
</li>
</ul>
<p><strong>账户：</strong></p>
<ul>
<li><p><strong>&#x2F;root</strong>：系统管理员的home目录。</p>
</li>
<li><p><strong>&#x2F;home</strong>：用户的主目录，以用户的账号命名的。</p>
</li>
<li><p>**&#x2F;usr(<em>unix shared resources</em>)**：通过系统自动安装的软件目录。类似于windows下的program files目录。</p>
</li>
<li><p><strong>&#x2F;usr&#x2F;bin：</strong>系统用户使用的应用程序与指令。</p>
</li>
<li><p><strong>&#x2F;usr&#x2F;sbin：</strong>超级用户使用的比较高级的管理程序和系统守护程序。</p>
</li>
<li><p><strong>&#x2F;usr&#x2F;src：</strong>内核源代码默认的放置目录。</p>
</li>
<li><p><strong>&#x2F;snap</strong>：snap是linux包管理工具，snap目录存放了snap软件包</p>
</li>
</ul>
<p><strong>运行过程中要用：</strong></p>
<ul>
<li><p><strong>&#x2F;var(<em>Variable</em>)<strong>：</strong>软件运行产生的不可自动销毁的缓存文件、日志记录</strong>，如日志、数据库文件、缓存文件。</p>
</li>
<li><p>**&#x2F;proc(<em>Processes</em>)**：&#x2F;proc是一个位于内存中的伪文件系统(in-memory pseudo-file system)。该目录下保存的不是真正的文件和目录，而是一些“运行时”信息，如系统内存、磁盘io、设备挂载信息和硬件配置信息等。proc目录是一个控制中心，用户可以通过更改其中某些文件来改变内核的运行状态。proc目录也是内核提供给我们的查询中心，我们可以通过这些文件查看有关系统硬件及当前正在运行进程的信息。在Linux系统中，许多工具的数据来源正是proc目录中的内容。例如，lsmod命令就是cat &#x2F;proc&#x2F;modules命令的别名，lspci命令是cat &#x2F;proc&#x2F;pci命令的别名。</p>
</li>
</ul>
<p><strong>扩展用的：</strong></p>
<ul>
<li><p>**&#x2F;opt(<em>Optional</em>)**：默认是空的。安装第三方软件，通常是用户自己编译的软件；把软件安装一个文件夹内，包括它的运行文件，所需要的库文件、生成临时文件、产生的内容等所有和该软件相关的都放在该文件夹内，不用时方便删除。</p>
</li>
<li><p><strong>&#x2F;srv(<em>Service</em>)<strong>：</strong>主要用来存储本机或本服务器提供的服务或数据。</strong>（用户主动生产的数据、对外提供服务）。如web、ftp、流媒体等</p>
</li>
</ul>
<h2 id="CLI，console，终端，shell区别"><a href="#CLI，console，终端，shell区别" class="headerlink" title="CLI，console，终端，shell区别"></a>CLI，console，终端，shell区别</h2><ul>
<li><strong>命令行界面</strong> (CLI) &#x3D; 使用文本命令进行交互的用户界面(区别于图形界面GUI)</li>
<li><strong>终端</strong> (Terminal) &#x3D; <strong>TTY(Teletype电传打字机)</strong> &#x3D; 文本输入&#x2F;输出环境</li>
<li><strong>控制台</strong> (Console) &#x3D; 一种特殊的终端</li>
<li><strong>Shell</strong> &#x3D; 命令行解释器，执行用户输入的命令并返回结果</li>
</ul>
<p>1.CLI和GUI相对，是两种不同的用户交互风格。</p>
<p>2.终端</p>
<p>终端是一种用来让用户输入数据至计算机，以及显示其计算结果的机器。在大型机 (Mainframe) 和小型机 (Minicomputer) 的时代里，计算机曾经非常昂贵且巨大，不像现在这样人手一台。这些笨重的计算机通常被安置在单独的房间内，而操作计算机的人们坐在另外的房间里，通过某些设备与计算机进行交互。这种设备就叫做 <strong>终端</strong> (Terminal)，也叫终端机。早期的终端一般是一种叫做 <strong>电传打字机</strong> (Teletype) 的设备。</p>
<p>3.控制台</p>
<p>在历史上，终端是连接到计算机上的一种带输入输出功能的外设。但是有一个终端与众不同，它与计算机主机是一体的，是计算机的一个组成部分。这个特殊的终端就叫做 <strong>控制台</strong> (Console)。顾名思义，控制台是用于管理主机的，只能给系统管理员使用，有着比普通终端更大的权限。一台计算机上一般只有一个控制台，但是可以连接很多个终端。现在 Console 与 Terminal 基本被看作是同义词。</p>
<p>4.终端模拟器</p>
<p>随着计算机的进化，我们已经见不到专门的终端硬件了，取而代之的则是键盘与显示器。</p>
<p>但是没有了终端，我们要怎么与那些传统的、不兼容图形接口的命令行程序（比如说 GNU 工具集里的大部分命令）交互呢？这些程序并不能直接读取我们的键盘输入，也没办法把计算结果显示在我们的显示器上。</p>
<p>这时候我们就需要一个程序来模拟传统终端的行为，即 <strong>终端模拟器</strong> (Terminal Emulator)。</p>
<p>对于那些命令行 (CLI) 程序，终端模拟器会「假装」成一个传统终端设备；一个终端模拟器的标准工作流程是这样的：</p>
<ol>
<li>捕获你的键盘输入；</li>
<li>将输入发送给命令行程序（程序会认为这是从一个真正的终端设备输入的）；</li>
<li>拿到命令行程序的输出结果（STDOUT 以及 STDERR）；</li>
<li>调用图形接口（比如 X11），将输出结果渲染至显示器。</li>
</ol>
<p>在专门的终端硬件已经基本上仅存于计算机博物馆的现代，人们通常图省事儿，直接称呼终端模拟器为「终端」。</p>
<p>5.shell</p>
<p>我们需要一个专门的程序，它接受用户输入的命令，然后帮我们与内核沟通，最后让内核完成我们的任务。这个提供用户界面的程序被叫做 <strong>Shell</strong> (壳层)。</p>
<p> Shell 提供了一个用户操作系统的入口，我们一般是通过 Shell 去调用其他各种各样的应用程序，最后来达成我们的目的。比如说我们想要知道一个文件的内容，我们会在 Shell 中输入命令 <code>cat foo.txt</code>，然后 Shell 会帮我们运行 <code>cat</code> 这个程序，<code>cat</code> 再去调用内核提供的 <code>open</code> 等系统调用来获取文件的内容。虽然并不是 Shell 直接去与内核交互，但广义上可以认为是 Shell 提供了与内核交互的用户界面。</p>
<p>Shell 通常可以分为两种：<strong>命令行 Shell</strong> 与 <strong>图形 Shell</strong>。顾名思义，前者提供一个命令行界面 (CLI)，后者提供一个图形用户界面 (GUI)。Windows 下的 <code>explorer.exe</code> 就是一个典型的图形 Shell（没错，它确实是，因为它接受来自你的指令，并且会帮你与内核交互完成你的指令）。</p>
<p>现在我们知道，终端干的活儿是从用户这里接收输入（键盘、鼠标等输入设备），扔给 Shell，然后把 Shell 返回的结果展示给用户（比如通过显示器）。而 Shell 干的活儿是从终端那里拿到用户输入的命令，解析后交给操作系统内核去执行，并把执行结果返回给终端。</p>
<h2 id="fork，vfork，exec，clone，pthread的区别"><a href="#fork，vfork，exec，clone，pthread的区别" class="headerlink" title="fork，vfork，exec，clone，pthread的区别"></a>fork，vfork，exec，clone，pthread的区别</h2><h3 id="fork"><a href="#fork" class="headerlink" title="fork"></a>fork</h3><p>Linux多进程编程中的可以使用fork函数来创建子进程。fork函数定义在头文件unistd.h中（uni表示unix，std当然是标准库，所以很好记），该函数的声明为<code>pid_t fork(void)</code>其中函数的返回值类型为pid_t，可以理解为一个整型，返回值具体为：</p>
<ul>
<li>在父进程中，fork返回新创建的子进程的进程ID；</li>
<li>在子进程中，fork返回0；</li>
<li>如果创建子进程失败，则返回一个负值</li>
</ul>
<p>fork只简单地将父进程的几乎所有资源全部复制给子进程，然后就相当于父进程的一个副本运行，且无法与父进行共享数据。</p>
<p><strong>子进程与父进程的区别在于：</strong></p>
<ul>
<li>父进程设置的锁，子进程不继承（因为如果是排它锁，被继承的话，矛盾了）</li>
<li>各自的进程ID和父进程ID不同</li>
<li>子进程的未决告警被清除；</li>
<li>子进程的未决信号集设置为空集。</li>
</ul>
<p><strong>linux常用fork和exec配合创建新进程</strong>，之所以这样创建新进程有着历史原因。fork、exec在UNIX里的最初的目的是：shell要执行别的东西，干完活再返回给shell，但当年（应该是1960~1970年代）是没有进程的概念的，exec就是把老的shell给干掉，然后去干活，干完活再返回回来。注意，当年是没有进程的概念的，exec就是直接把shell从内存里拿掉。但这样做有一些坏处，就是每次要重新加载shell，于是fork就出现了，让新任务执行（复制一份），shell不动（具体是交换到磁盘上还是怎么操作不太了解），新任务干完活，shell继续跑。<strong>因为当年没有多任务的概念，fork相当于提供了一个虚假的多任务环境</strong>。</p>
<p>但是这样复制父进程的内存空间开销很大，随着大进程的出现，内存开销开始越来越大，采用了<strong>写时复制技术</strong>来缓解这种大的内存开销。</p>
<p>写时拷贝（copy-on-write， COW）就是等到修改数据时才真正分配内存空间，这是对程序性能的优化，可以延迟甚至是避免内存拷贝，当然目的就是避免不必要的内存拷贝。在 Linux 系统中，调用 fork 系统调用创建子进程时，并不会把父进程所有占用的内存页复制一份，而是与父进程共用相同的内存页，而当子进程或者父进程对内存页进行修改时才会进行复制。（也就是只有进程空间的某页内存的内容要发生变化时，才会将父进程的该页内存复制一份给子进程。）</p>
<p><strong>fork因为开销过大，现在基本已经不再使用，而是使用clone和pthread替代。</strong></p>
<h4 id="fork用法"><a href="#fork用法" class="headerlink" title="fork用法"></a>fork用法</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pid_t</span> fpid; <span class="comment">//创建一个临时变量用于存放fork的返回值</span></span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    fpid = fork();  <span class="comment">//创建子进程，父进程与子进程将分别执行此后的代码</span></span><br><span class="line">    <span class="keyword">if</span> (fpid &lt; <span class="number">0</span>)   <span class="comment">//创建子进程失败时将返回负值</span></span><br><span class="line">      <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Error in fork!&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (fpid == <span class="number">0</span>) &#123;  <span class="comment">//子进程中fork的返回值为0，所以将由子进程执行该分支</span></span><br><span class="line">      <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Child: parent_pid:&quot;</span> &lt;&lt; getppid() &lt;&lt; <span class="string">&quot; pid:&quot;</span> &lt;&lt; getpid() &lt;&lt; <span class="string">&quot; child_pid:&quot;</span> &lt;&lt; fpid &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">      count++;  <span class="comment">//子进程复制来的count值为0，++之后将为1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;  <span class="comment">//父进程中fork的返回值为子进程的pid，所以将由父进程执行该分支</span></span><br><span class="line">      <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Parent: parent_pid:&quot;</span> &lt;&lt; getppid() &lt;&lt; <span class="string">&quot; pid:&quot;</span> &lt;&lt; getpid() &lt;&lt; <span class="string">&quot; child_pid:&quot;</span> &lt;&lt; fpid &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">      count++;  <span class="comment">//父进程中count为0，父子进程中的变量等数据是完全独立的</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;count: &quot;</span> &lt;&lt; count &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;  <span class="comment">//最后输出count的当前值，显示该句父子进程都要执行</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Parent: parent_pid:<span class="number">3084</span> pid:<span class="number">3087</span> child_pid:<span class="number">3088</span></span><br><span class="line">count: <span class="number">1</span></span><br><span class="line">Child:  parent_pid:<span class="number">3087</span> pid:<span class="number">3088</span> child_pid:<span class="number">0</span></span><br><span class="line">count: <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>可以看到父进程的中创建的子进程的pid:3088刚好是子进程当前的pid，两个进程输出的count都是1，也就是只进行了一次累加</p>
<p>父进程使用fork后，父进程和子进程会一起执行接下来的代码，<strong>执行n次fork函数，创建的子进程数为2^n个</strong></p>
<h3 id="vfork"><a href="#vfork" class="headerlink" title="vfork"></a>vfork</h3><p>vfork和fork类似，但vfork的开销更小，不会复制一份父进程的地址空间，而是共享，并且vfork后父进程会阻塞直到子进程结束。具体来说有以下区别：</p>
<p>1.vfork保证子进程先运行，在它调用exec或exit之后父进程才可能被调度运行。如果在调用这两个函数之前子进程依赖于父进程的进一步动作，则会导致死锁。</p>
<p>2.fork要拷贝父进程的进程环境；而vfork则不需要完全拷贝父进程的进程环境，在子进程没有调用exec和exit之前，子进程与父进程共享进程环境，相当于线程的概念，此时父进程阻塞等待。</p>
<h4 id="为什么会有vfork呢"><a href="#为什么会有vfork呢" class="headerlink" title="为什么会有vfork呢?"></a>为什么会有vfork呢?</h4><p>因为以前的fork当它创建一个子进程时，将会创建一个新的地址空间，并且拷贝父进程的资源，然后将会有两种行为：</p>
<p>1.执行从父进程那里拷贝过来的代码段</p>
<p>2.调用一个exec执行一个新的代码段</p>
<p>当进程调用exec函数时，一个新程序替换了当前进程的正文，数据，堆和栈段。这样，前面的拷贝工作就是白费力气了，这种情况下，聪明的人就想出了vfork。vfork并不复制父进程的进程环境，子进程在父进程的地址空间中运行，所以子进程不能进行写操作，并且在儿子“霸占”着老子的房子时候，要委屈老子一下了，让他在外面歇着（阻塞），一旦儿子执行了exec或者exit后，相当于儿子买了自己的房子了，这时候就相当于分家了。</p>
<p>因此，如果创建子进程是为了调用exec执行一个新的程序的时候，就应该使用vfork。<strong>但因为现在有了写时复制的技术，fork的开销不再像之前那样巨大，所以vfork基本已经不再使用。</strong></p>
<h3 id="exec"><a href="#exec" class="headerlink" title="exec"></a>exec</h3><p>exec函数族的作用是根据指定的文件名找到可执行文件，并用它来取代调用进程的内容，换句话说，就是在调用进程内部执行一个可执行文件。这里的可执行文件既可以是二进制文件，也可以是任何Linux下可执行的脚本文件。<br><strong>与一般情况不同，exec函数族的函数执行成功后不会返回</strong>，因为调用进程的实体，包括代码段，数据段和堆栈等都已经被新的内容取代，只留下进程ID等一些表面上的信息仍保持原样，颇有些神似”三十六计”中的”金蝉脱壳”。看上去还是旧的躯壳，却已经注入了新的灵魂。只有调用失败了，它们才会返回一个-1，从原程序的调用点接着往下执行。#include &lt;unistd.h&gt;</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">execl</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path, <span class="type">const</span> <span class="type">char</span> *arg, ..., <span class="literal">NULL</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">execlp</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *file, <span class="type">const</span> <span class="type">char</span> *arg, ..., <span class="literal">NULL</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">execle</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path, <span class="type">const</span> <span class="type">char</span> *arg, ..., <span class="literal">NULL</span> ,<span class="type">char</span> *<span class="type">const</span> envp[])</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">execv</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path, <span class="type">char</span> *<span class="type">const</span> argv[])</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">execvp</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *file, <span class="type">char</span> *<span class="type">const</span> argv[])</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">execve</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path, <span class="type">char</span> *<span class="type">const</span> argv[], <span class="type">char</span> *<span class="type">const</span> envp[])</span>;</span><br></pre></td></tr></table></figure>

<p>exec函数一共有六个，其中execve为内核级系统调用，其他（execl，execle，execlp，execv，execvp）都是调用execve的库函数</p>
<h3 id="clone"><a href="#clone" class="headerlink" title="clone"></a>clone</h3><p>clone是Linux为创建线程设计的（虽然也可以用clone创建进程）。所以可以说clone是fork的升级版本，不仅可以创建进程或者线程，还可以指定创建新的命名空间（namespace）、有选择的继承父进程的内存、甚至可以将创建出来的进程变成父进程的兄弟进程等等。</p>
<p>clone函数功能强大，带了众多参数，它提供了一个非常灵活自由的常见进程的方法。因此由他创建的进程要复杂。clone可以让你有选择性的继承父进程的资源，你可以和父进程共享一个虚存空间，从而使创造的是线程，你也可以不和父进程共享，你甚至可以选择创造出来的进程和父进程不再是父子关系，而是兄弟关系。</p>
<p><strong>clone需要创建自己的栈。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">clone</span><span class="params">(<span class="type">int</span> (*fn)(<span class="type">void</span> *), <span class="type">void</span> *child_stack, <span class="type">int</span> flags, <span class="type">void</span> *arg)</span>;</span><br></pre></td></tr></table></figure>

<p>这里fn是函数指针，这个就是指向程序的指针；child_stack是为子进程分配系统堆栈空间的指针（在Linux下系统堆栈空间是2页面，就是8K的内存，其中在这块内存中，低地址上放入了值，这个值就是进程控制块task_struct的值）,flags就是标志用来描述你需要从父进程继承哪些资源， arg就是传给子进程的参数一般为（0）。下面是flags可以取的值</p>
<p>  CLONE_PARENT   创建的子进程的父进程是调用者的父进程，新进程与创建它的进程成了“兄弟”而不是“父子”</p>
<p>  CLONE_FS           子进程与父进程共享相同的文件系统，包括root、当前目录、umask</p>
<p>  CLONE_FILES      子进程与父进程共享相同的文件描述符（file descriptor）表</p>
<p>  CLONE_NEWNS   在新的namespace启动子进程，namespace描述了进程的文件hierarchy</p>
<p>  CLONE_SIGHAND   子进程与父进程共享相同的信号处理（signal handler）表</p>
<p>  CLONE_PTRACE   若父进程被trace，子进程也被trace</p>
<p>  CLONE_VFORK     父进程被挂起，直至子进程释放虚拟内存资源</p>
<p>  CLONE_VM           子进程与父进程运行于相同的内存空间</p>
<p>  CLONE_PID          子进程在创建时PID与父进程一致</p>
<p>  CLONE_THREAD    Linux 2.4中增加以支持POSIX线程标准，子进程与父进程共享相同的线程群</p>
<h3 id="pthread"><a href="#pthread" class="headerlink" title="pthread"></a>pthread</h3><p>phtread类库，也即是“POSIX线程”，pthreads定义了一套C语言的类型、函数与常量，它以pthread.h头文件和一个线程库实现。pthread底层是用clone创建线程的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">数据类型</span><br><span class="line"><span class="type">pthread_t</span>：<span class="comment">//线程ID(线程标识符,用于声明线程ID)</span></span><br><span class="line"><span class="type">pthread_attr_t</span>：<span class="comment">//线程属性</span></span><br><span class="line"></span><br><span class="line">操纵函数</span><br><span class="line">pthread_create()：<span class="comment">//创建一个线程</span></span><br><span class="line">pthread_exit()：<span class="comment">//终止当前线程</span></span><br><span class="line">pthread_cancel()：<span class="comment">//中断另外一个线程的运行</span></span><br><span class="line">pthread_join()：<span class="comment">//阻塞当前的线程，直到另外一个线程运行结束</span></span><br><span class="line">pthread_attr_init()：<span class="comment">//初始化线程的属性</span></span><br><span class="line">pthread_attr_setdetachstate()：<span class="comment">//设置脱离状态的属性（决定这个线程在终止时是否可以被结合）</span></span><br><span class="line">pthread_attr_getdetachstate()：<span class="comment">//获取脱离状态的属性</span></span><br><span class="line">pthread_attr_destroy()：<span class="comment">//删除线程的属性</span></span><br><span class="line">pthread_kill()：<span class="comment">//向线程发送一个信号</span></span><br><span class="line"></span><br><span class="line">同步函数</span><br><span class="line">用于mutex和条件变量</span><br><span class="line">pthread_mutex_init() <span class="comment">//初始化互斥锁</span></span><br><span class="line">pthread_mutex_destroy() <span class="comment">//删除互斥锁</span></span><br><span class="line">pthread_mutex_lock()：<span class="comment">//占有互斥锁（阻塞操作）</span></span><br><span class="line">pthread_mutex_trylock()：<span class="comment">//试图占有互斥锁（不阻塞操作）。即，当互斥锁空闲时，将占有该锁；否则，立即返回。</span></span><br><span class="line">pthread_mutex_unlock(): <span class="comment">//释放互斥锁</span></span><br><span class="line">pthread_cond_init()：<span class="comment">//初始化条件变量</span></span><br><span class="line">pthread_cond_destroy()：<span class="comment">//销毁条件变量</span></span><br><span class="line">pthread_cond_signal(): <span class="comment">//唤醒第一个调用pthread_cond_wait()而进入睡眠的线程</span></span><br><span class="line">pthread_cond_wait(): <span class="comment">//等待条件变量的特殊条件发生</span></span><br><span class="line">Thread-local storage（或者以Pthreads术语，称作线程特有数据）：</span><br><span class="line">pthread_key_create(): <span class="comment">//分配用于标识进程中线程特定数据的键</span></span><br><span class="line">pthread_setspecific(): <span class="comment">//为指定线程特定数据键设置线程特定绑定</span></span><br><span class="line">pthread_getspecific(): <span class="comment">//获取调用线程的键绑定，并将该绑定存储在 value 指向的位置中</span></span><br><span class="line">pthread_key_delete(): <span class="comment">//销毁现有线程特定数据键</span></span><br><span class="line">pthread_attr_getschedparam();<span class="comment">//获取线程优先级</span></span><br><span class="line">pthread_attr_setschedparam();<span class="comment">//设置线程优先级</span></span><br><span class="line"></span><br><span class="line">工具函数</span><br><span class="line">pthread_equal(): <span class="comment">//对两个线程的线程标识号进行比较 </span></span><br><span class="line">pthread_detach(): 分离线程</span><br><span class="line">pthread_self(): 查询线程自身线程标识号</span><br></pre></td></tr></table></figure>

<p>例子：int pthread_create ( pthread_t *thread , const pthread_attr_t *attr , void *(start)(void) , void *arg );</p>
<p>执行pthread_create，将创建线程，成功则返回0,否则返回-1；<br>参数1返回一个绑定特定函数的线程ID；<br>参数2为线程属性对象指针，用来改变线程的属性；<br>参数3为线程运行的函数指针，被调用的函数必须返回空指针，且只能有一个空指针参数；<br>参数4为传递给被调用函数的参数；</p>
<h2 id="数据流stdin-stdout-stderr"><a href="#数据流stdin-stdout-stderr" class="headerlink" title="数据流stdin,stdout,stderr"></a>数据流stdin,stdout,stderr</h2><p>数据流，就是数据传输的通道。在Linux中，一个程序启动时，将会自动开启三个数据流通道：标准输入流、标准输出流、标准错误流。本文详细介绍标准数据流的概念及其重定向的使用。</p>
<p>对应的文件描述符分别是：</p>
<ul>
<li>stdin：<code>0</code></li>
<li>stdout：<code>1</code></li>
<li>stderr：<code>2</code></li>
</ul>
<p>程序运行的时候从输入流读取数据，作为程序的输入，程序运行过程中输出的信息被传送到输出流，类似的，错误信息被传送到错误流。</p>
<p>标准输入流默认是从键盘输入的信息，除了键盘之外，标准输入流还可以是文件，或者其它程序的输出。</p>
<p>输出流分为标准输出流和标准错误流，默认情况下，它们都会输出到屏幕。标准输出流也可以被重定向到另外一个程序，或者一个文件。</p>
<p>在Linux中，标准输入流默认来自键盘输入，标准输出流和标准错误流默认发送到屏幕。在必要的时候，可以对修改输入流的来源、修改输出流的目的，这就是重定向。</p>
<p>常用的重定向的符号：</p>
<ol>
<li><code>&gt;</code>： 将<strong>标准输出流</strong>重定向到文件（清空文件后写入）。</li>
<li><code>&gt;&gt;</code>：将标准输出流重定向到文件（追加写入）。</li>
<li><code>&lt;</code>：将文件作为命令的标准输入流。</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/01/22/linux/" data-id="cld6uioj60007acsfa8tkfl8c" data-title="" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-IO密集型任务和计算密集型任务" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/01/22/IO%E5%AF%86%E9%9B%86%E5%9E%8B%E4%BB%BB%E5%8A%A1%E5%92%8C%E8%AE%A1%E7%AE%97%E5%AF%86%E9%9B%86%E5%9E%8B%E4%BB%BB%E5%8A%A1/" class="article-date">
  <time class="dt-published" datetime="2023-01-22T03:54:01.938Z" itemprop="datePublished">2023-01-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="IO密集型任务和计算密集型任务"><a href="#IO密集型任务和计算密集型任务" class="headerlink" title="IO密集型任务和计算密集型任务"></a>IO密集型任务和计算密集型任务</h1><p>计算密集型表示该任务需要大量的运算，而没有阻塞，CPU一直全速运行，CPU负载高</p>
<p>IO密集型系统运作时大部分的状况是CPU在等IO (硬盘&#x2F;内存) 的读写操作，因此，CPU负载并不高。</p>
<p>计算密集型任务的特点是要进行大量的计算，消耗CPU资源，全靠CPU的运算能力。这种计算密集型任务虽然也可以用多任务完成，但是任务越多，花在任务切换的时间就越多，CPU执行任务的效率就越低，<strong>所以，要最高效地利用CPU，计算密集型任务同时进行的数量应当等于CPU的核心数，避免线程或进程的切换。</strong></p>
<blockquote>
<p>计算密集型任务由于主要消耗CPU资源，因此，代码运行效率至关重要。Python这样的脚本语言运行效率很低，完全不适合计算密集型任务。对于计算密集型任务，最好用C语言编写。</p>
</blockquote>
<p>IO密集型任务的特点是CPU消耗很少，任务的大部分时间都在等待IO操作完成（因为IO的速度远远低于CPU和内存的速度）。涉及到网络、磁盘IO的任务都是IO密集型任务。当线程进行 I&#x2F;O 操作 CPU 空闲时，启用其他线程继续使用 CPU，以提高 CPU 的使用率。<strong>对于IO密集型任务，线程数越多，CPU效率越高，但也有一个限度。</strong></p>
<p>线程池设置线程数与CPU计算时间和I&#x2F;O操作时间的比例相关，在此可以引出一个配置线程池大小的原则——<strong>阻抗匹配原则</strong>，其经验公式为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">C = CPU数量</span><br><span class="line">P = CPU繁忙时间 / 总运行时间   // 0&lt;P&lt;=1</span><br><span class="line">T = 所需设置线程数</span><br><span class="line">T = C / P</span><br></pre></td></tr></table></figure>

<p>考虑到P的值并不好评估，T的大小可以上下浮动50%。</p>
<p>这个公式原理也比较简单，T个线程，每个线程占用P的时间，正好可以占满C个CPU，也就是C &#x3D; T * P。可以验证一下：</p>
<p>如果P &#x3D; 1.0，C &#x3D; 16，说明这是一个完全的密集计算，此时T &#x3D; 16，也就是有几个CPU设置几个线程，这样能把CPU都利用起来。更多的线程也没用，因为CPU资源已经耗光。</p>
<p>如果P &#x3D; 0.5，C &#x3D; 16，说明每个线程只有50%的时间在使用CPU，此时T &#x3D; 32，也就是32个50%繁忙的线程，能充分把CPU利用起来。</p>
<p>如果P &lt; 0.2，这个公式就不适用了，因为线程不能无限开，会消耗大量资源。T可以取一个固定值，比如 8*C。</p>
<p>综上，CPU繁忙时间占比越高，设置线程数越少，CPU繁忙时间占比越低，设置线程数越多（当然也有限度）。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/01/22/IO%E5%AF%86%E9%9B%86%E5%9E%8B%E4%BB%BB%E5%8A%A1%E5%92%8C%E8%AE%A1%E7%AE%97%E5%AF%86%E9%9B%86%E5%9E%8B%E4%BB%BB%E5%8A%A1/" data-id="cld6uiois0000acsfeeuwc60t" data-title="" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-io多路复用原理" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/01/22/io%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E5%8E%9F%E7%90%86/" class="article-date">
  <time class="dt-published" datetime="2023-01-22T03:54:01.936Z" itemprop="datePublished">2023-01-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="io多路复用原理"><a href="#io多路复用原理" class="headerlink" title="io多路复用原理"></a>io多路复用原理</h1><h2 id="select原理概述"><a href="#select原理概述" class="headerlink" title="select原理概述"></a>select原理概述</h2><p>调用select时，会发生以下事情：</p>
<ol>
<li><p>从用户空间拷贝fd_set到内核空间；</p>
</li>
<li><p>注册回调函数__pollwait；</p>
</li>
<li><p>遍历所有fd，对全部指定设备做一次poll（这里的poll是一个文件操作，它有两个参数，一个是文件fd本身，一个是当设备尚未就绪时调用的回调函数__pollwait，这个函数把设备自己特有的等待队列传给内核，让内核把当前的进程挂载到其中）；</p>
</li>
<li><p>当设备就绪时，设备就会唤醒在自己特有等待队列中的【所有】节点，于是当前进程就获取到了完成的信号。poll文件操作返回的是一组标准的掩码，其中的各个位指示当前的不同的就绪状态（全0为没有任何事件触发），根据mask可对fd_set赋值；</p>
</li>
<li><p>如果所有设备返回的掩码都没有显示任何的事件触发，就去掉回调函数的函数指针，进入有限时的睡眠状态，再恢复和不断做poll，再作有限时的睡眠，直到其中一个设备有事件触发为止。</p>
</li>
<li><p>只要有事件触发，系统调用返回，将fd_set从内核空间拷贝到用户空间，回到用户态，用户就可以对相关的fd作进一步的读或者写操作了。</p>
</li>
</ol>
<h2 id="epoll原理概述"><a href="#epoll原理概述" class="headerlink" title="epoll原理概述"></a>epoll原理概述</h2><p>调用epoll_create时，做了以下事情：</p>
<p>内核帮我们在epoll文件系统里建了个file结点；</p>
<p>在内核cache里建了个红黑树用于存储以后epoll_ctl传来的socket；</p>
<p>建立一个list链表，用于存储准备就绪的事件。</p>
<p>调用epoll_ctl时，做了以下事情：</p>
<p>把socket放到epoll文件系统里file对象对应的红黑树上；</p>
<p>给内核中断处理程序注册一个回调函数，告诉内核，如果这个句柄的中断到了，就把它放到准备就绪list链表里。</p>
<p>调用epoll_wait时，做了以下事情：</p>
<p>观察list链表里有没有数据。有数据就返回，没有数据就sleep，等到timeout时间到后即使链表没数据也返回。而且，通常情况下即使我们要监控百万计的句柄，大多一次也只返回很少量的准备就绪句柄而已，所以，epoll_wait仅需要从内核态copy少量的句柄到用户态而已。</p>
<p>总结如下：</p>
<p>一颗红黑树，一张准备就绪句柄链表，少量的内核cache，解决了大并发下的socket处理问题。</p>
<p>执行epoll_create时，创建了红黑树和就绪链表；</p>
<p>执行epoll_ctl时，如果增加socket句柄，则检查在红黑树中是否存在，存在立即返回，不存在则添加到树干上，然后向内核注册回调函数，用于当中断事件来临时向准备就绪链表中插入数据;</p>
<p>执行epoll_wait时立刻返回准备就绪链表里的数据即可。</p>
<p>两种模式的区别：</p>
<p>LT模式下，只要一个句柄上的事件一次没有处理完，会在以后调用epoll_wait时重复返回这个句柄，而ET模式仅在第一次返回。</p>
<p>两种模式的实现：</p>
<p>如果是ET模式，当一个socket句柄上有事件时，内核会把该句柄插入上面所说的准备就绪list链表，这时我们调用epoll_wait，会把准备就绪的socket拷贝到用户态内存，然后清空准备就绪list链表，最后，epoll_wait检查这些socket，如果是LT模式，并且这些socket上确实有未处理的事件时，又把该句柄放回到刚刚清空的准备就绪链表。所以，LT模式的句柄，只要它上面还有事件，epoll_wait每次都会返回。</p>
<h2 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h2><p>select缺点:</p>
<p>最大并发数限制：使用32个整数的32位，即32*32&#x3D;1024来标识fd，虽然可修改，但是有以下第二点的瓶颈；</p>
<p>效率低：每次都会线性扫描整个fd_set，集合越大速度越慢；</p>
<p>内核&#x2F;用户空间内存拷贝问题。</p>
<p>epoll的提升：</p>
<p>本身没有最大并发连接的限制，仅受系统中进程能打开的最大文件数目限制；</p>
<p>效率提升：只有活跃的socket才会主动的去调用callback函数；</p>
<p>网上很多博客说epoll使用了共享内存,这个是完全错误的 ,可以阅读源码,会发现完全没有使用共享内存的任何api，而是 使用了copy_from_user跟__put_user进行内核跟用户虚拟空间数据交互.</p>
<p>当然，以上的优缺点仅仅是特定场景下的情况：高并发，且任一时间只有少数socket是活跃的。</p>
<p>如果在并发量低，socket都比较活跃的情况下，select就不见得比epoll慢了（就像我们常常说快排比插入排序快，但是在特定情况下这并不成立）。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/01/22/io%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E5%8E%9F%E7%90%86/" data-id="cld6uioj50006acsfar3j99gh" data-title="" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-csapp" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/01/22/csapp/" class="article-date">
  <time class="dt-published" datetime="2023-01-22T03:54:01.933Z" itemprop="datePublished">2023-01-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="csapp"><a href="#csapp" class="headerlink" title="csapp"></a>csapp</h1><h2 id="计算机系统漫游"><a href="#计算机系统漫游" class="headerlink" title="计算机系统漫游"></a>计算机系统漫游</h2><p><img src="https://raw.githubusercontent.com/hufei96/Image/main/image-20220512233937399.png" alt="image-20220512233937399"></p>
<h3 id="计算机技术演变过程"><a href="#计算机技术演变过程" class="headerlink" title="计算机技术演变过程"></a><strong>计算机技术演变过程</strong></h3><p>以hello程序执行为例：</p>
<p>先由C语言的源文件<code>hello.c</code>编译得到了可执行目标文件<code>hello</code></p>
<ol>
<li>shell读入我们输入的字符<code>./hello</code>后，将其逐一读入到CPU的寄存器中，然后再将其存放到主存中。</li>
<li>输入回车后，shell执行一系列指令将hello目标文件中的代码和数据从磁盘复制到主存。</li>
<li>CPU开始执行hello的main程序中的机器指令，它将<code>hello, world\n</code>字符串中的字节从主存复制到CPU寄存器，再从CPU寄存器复制到显示设备。</li>
</ol>
<p>由此可见执行代码时，会花费大量时间将代码和数据进行复制。而<strong>不同设备之间运行速度差距极大</strong>，在等待复制的过程中cpu浪费了大量的时间，为了加快复制速度和提高cpu利用率，引入了存储器体系结构。</p>
<h4 id="1-加快代码和数据的复制速度-存储器体系结构"><a href="#1-加快代码和数据的复制速度-存储器体系结构" class="headerlink" title="1.加快代码和数据的复制速度(存储器体系结构)"></a><strong>1.加快代码和数据的复制速度</strong>(存储器体系结构)</h4><p><img src="https://raw.githubusercontent.com/hufei96/Image/main/image-20220512235134334.png" alt="image-20220512235134334"></p>
<p>根据<strong>局部性原理</strong>可知，程序具有访问局部区域内的数据和代码的趋势，所以在处理器和一个较大较慢的设备之间插入一个更小更快的存储设备，来暂时保存处理器近期可能会需要的数据，使得大部分的内存操作都能在高速缓存内完成，就能极大提高系统速度了。</p>
<p>存储器层次结构的<strong>主要思想</strong>是将上一层的存储器作为下一层存储器的高速缓存。</p>
<h4 id="2-简化对硬件的操作-操作系统"><a href="#2-简化对硬件的操作-操作系统" class="headerlink" title="2.简化对硬件的操作(操作系统)"></a><strong>2.简化对硬件的操作(操作系统)</strong></h4><p><img src="https://raw.githubusercontent.com/hufei96/Image/main/image-20220512235848305.png" alt="image-20220512235848305"></p>
<p>程序并没有直接访问cpu，内存，I&#x2F;O这些硬件设备，真正访问硬件设备的是操作系统。所有程序对硬件的操作都必须通过操作系统来完成。它可以看成是应用程序和硬件之间的一层软件，给程序员提供硬件的抽象。</p>
<p>操作系统定义：给应用程序提供服务的程序。现代操作系统主要是因为<strong>更好的管理和支持多任务执行</strong>的需求而诞生的。</p>
<p>这样设计的目的有两个：</p>
<ol>
<li>防止硬件被失控的应用程序滥用，提高系统安全性</li>
<li>提供统一对硬件操作的接口，简化硬件操作</li>
</ol>
<p>为了实现这些功能操作系统引入了几个抽象的概念，<strong>抽象就是对外提供统一接口而隐藏内部复杂的细节</strong>，操作系统对于程序来说就是硬件的抽象。</p>
<p>操作系统将cpu，内存，I&#x2F;O设备抽象为进程；将内存和磁盘I&#x2F;O抽象为虚拟内存；将I&#x2F;O设备抽象为文件的形式。让程序员能够直接通过这层软件很好地调用硬件，避免了过多的硬件细节。</p>
<h5 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a><strong>进程</strong>和线程</h5><p><strong>为什么引入进程：</strong>为了支持和管理多任务并发执行</p>
<p>一开始操作系统是单道批处理系统，一个作业单独进入内存并独占系统资源，直到运行结束后下一个作业才能进入内存，当作业进行I&#x2F;O操作时，CPU只能处于等待状态，因此，CPU利用率较低。为此需要引入多道程序并发执行。</p>
<p>进程看起来在独占地使用硬件(而实际在和其他进程分时共享资源)，为程序员屏蔽了多道程序并发执行时进程调度和进程切换的细节。这样程序员就无需考虑程序之间切换所需操作的硬件，这些由操作系统的内核进行管理。</p>
<p><strong>为什么引入线程：</strong>为了进一步提高并发度，减少多进程的开销</p>
<p>对于，线程相比进程能减少开销，体现在：</p>
<ul>
<li>线程的<strong>创建</strong>时间比进程快，因为进程在创建的过程中，还需要资源管理信息，比如内存管理信息、文件管理信息，而线程在创建的过程中，不会涉及这些资源管理信息，而是共享它们；</li>
<li>线程的<strong>终止</strong>时间比进程快，因为线程释放的资源相比进程少很多；</li>
<li>同一个进程内的线程<strong>切换</strong>比进程切换快，因为线程具有相同的地址空间（虚拟内存共享），这意味着同一个进程的线程都具有同一个页表，那么在切换的时候不需要切换页表。而对于进程之间的切换，切换的时候要把页表给切换掉，而页表的切换过程开销是比较大的；</li>
<li>由于同一进程的各线程间共享内存和文件资源，那么在线程之间<strong>通信</strong>的时候，就不需要经过内核了，这就使得线程之间的数据交互效率更高了；</li>
</ul>
<p>所以，线程比进程不管是时间效率，还是空间效率都要高。</p>
<p><strong>多线程还是多进程</strong></p>
<p>多进程模式最大的优点就是稳定性高，因为一个进程崩溃了，不会影响其他进程。著名的Apache最早就是采用多进程模式。</p>
<p>多进程模式的缺点是创建进程的代价大，在Unix&#x2F;Linux系统下，用<code>fork</code>调用还行，在Windows下创建进程开销巨大。另外，操作系统能同时运行的进程数也是有限的，在内存和CPU的限制下，如果有几千个进程同时运行，操作系统连调度都会成问题。</p>
<table>
<thead>
<tr>
<th><strong>对比维度</strong></th>
<th><strong>多进程</strong></th>
<th><strong>多线程</strong></th>
<th><strong>总结</strong></th>
</tr>
</thead>
<tbody><tr>
<td>数据共享、同步</td>
<td>数据共享复杂，需要用IPC；数据是分开的，同步简单</td>
<td>因为共享进程数据，数据共享简单，但也是因为这个原因导致同步复杂</td>
<td>各有优势</td>
</tr>
<tr>
<td>内存、CPU</td>
<td>占用内存多，切换复杂，CPU利用率低</td>
<td>占用内存少，切换简单，CPU利用率高</td>
<td>线程占优</td>
</tr>
<tr>
<td>创建销毁、切换</td>
<td>创建销毁、切换复杂，速度慢</td>
<td>创建销毁、切换简单，速度很快</td>
<td>线程占优</td>
</tr>
<tr>
<td>编程、调试</td>
<td>编程简单，调试简单</td>
<td>编程复杂，调试复杂</td>
<td>进程占优</td>
</tr>
<tr>
<td>可靠性</td>
<td>进程间不会互相影响</td>
<td>一个线程挂掉将导致整个进程挂掉</td>
<td>进程占优</td>
</tr>
<tr>
<td>分布式</td>
<td>适应于多核、多机分布式；如果一台机器不够，扩展到多台机器比较简单</td>
<td>适应于多核分布式</td>
<td>进程占优</td>
</tr>
</tbody></table>
<p><strong>需要频繁创建销毁的优先用线程</strong></p>
<p>这种原则最常见的应用就是Web服务器了，来一个连接建立一个线程，断了就销毁线程，要是用进程，创建和销毁的代价是很难承受的</p>
<p><strong>需要进行大量计算的优先使用线程</strong></p>
<p>所谓大量计算，当然就是要耗费很多CPU，切换频繁了，这种情况下线程是最合适的。</p>
<p>这种原则最常见的是图像处理、算法处理。</p>
<p><strong>强相关的处理用线程，弱相关的处理用进程</strong></p>
<p>一般的Server需要完成如下任务：消息收发、消息处理。“消息收发”和“消息处理”就是弱相关的任务，而“消息处理”里面可能又分为“消息解码”、“业务处理”，这两个任务相对来说相关性就要强多了。因此“消息收发”和“消息处理”可以分进程设计，“消息解码”、“业务处理”可以分线程设计。</p>
<p><strong>可能要扩展到多机分布的用进程，多核分布的用线程</strong></p>
<p>原因请看上面对比。</p>
<h5 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a><strong>虚拟内存</strong></h5><p><img src="https://raw.githubusercontent.com/hufei96/Image/main/image-20220513215415380.png" alt="image-20220513215415380"></p>
<p><strong>为什么引入虚拟内存</strong>：解决多程序系统中内存分配和管理问题</p>
<ol>
<li><strong>解决地址空间不隔离问题</strong>：若所有程序都直接访问物理地址，程序所使用的内存空间不是相互隔离的。程序可以很容易改写其他程序的内存数据，以达到破坏的目的，这对于需要安全稳定的计算环境的用户来说是不能容忍的。用户希望他在使用计算机的时候，其中一个任务失败了，至少不会影响其他任务。</li>
<li><strong>解决内存使用效率低问题：</strong>如果没有有效的内存管理机制，通常需要一个程序执行时，监控程序就将整个程序装入内存中然后开始执行。而当内存没有程序所需的连续空间时，就不得不将其他程序换出到磁盘，效率十分低下。</li>
<li><strong>解决程序运行地址不确定问题：</strong>程序每次运行时都要给它在内存中分配一块空闲空间，这个空间位置不确定。这会导致程序编写十分困难，因为程序中访问数据和指令跳转的目标地址很多都是固定的。</li>
</ol>
<p>虚拟内存屏蔽了虚拟地址到物理地址的转换过程，让程序看起来就像是在独占地使用内存。</p>
<h5 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h5><p><strong>为什么引入文件：</strong>简化对I&#x2F;O设备的操作，屏蔽操作的细节</p>
<p>操作系统将所有I&#x2F;O设备看成是文件，而文件是字节序列，这样系统中的所有输入输出可以调用系统函数来读写文件实现，简化了对各种各样的I&#x2F;O设备的操作。</p>
<h4 id="3-提高计算能力"><a href="#3-提高计算能力" class="headerlink" title="3.提高计算能力"></a>3.提高计算能力</h4><h5 id="线程级并发"><a href="#线程级并发" class="headerlink" title="线程级并发"></a>线程级并发</h5><p><strong>单处理器系统</strong></p>
<p>多进程和多线程使得多任务并发处理成为可能，提高了cpu利用率</p>
<p><strong>多处理器系统</strong></p>
<p>多处理器系统主要分成超线程和多核处理器。</p>
<p>多核处理器：将多个CPU集成到一个集成电路中，然后使用一个L3高速缓存来在多个核之间共享数据。</p>
<p>超线程：超线程是在CPU内部仅复制必要的资源(如程序计数器和寄存器文件)，而其他硬件部分只有一部分(如ALU)，让两个线程可同时执行。超线程技术可以让一个核同时运行两个线程，相当于模拟了双核心、双线程运行。</p>
<h5 id="指令级并行"><a href="#指令级并行" class="headerlink" title="指令级并行"></a>指令级并行</h5><p>一个指令的执行过程通常包含：取指令阶段、解码阶段和执行指令阶段。最初的指令执行过程是每个指令完整经过一整个过程后，才运行下一条指令，但是其实每个阶段使用的都是处理器中不同的硬件部分，这就使得我们可以<strong>流水线</strong>式地运行多个指令，这就达到了差不多一个时钟周期运行一条指令的地步。</p>
<h5 id="单指令、多数据并行"><a href="#单指令、多数据并行" class="headerlink" title="单指令、多数据并行"></a>单指令、多数据并行</h5><p>很多现代处理器拥有特殊的硬件，允许一条指令产生多个可以并行执行的操作，这种方式称为单指令、多数据，即<strong>SIMD并行</strong>。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/01/22/csapp/" data-id="cld6uioj30003acsfac3mdx73" data-title="" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-CMake 模块化项目管理" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/01/22/CMake%20%E6%A8%A1%E5%9D%97%E5%8C%96%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/" class="article-date">
  <time class="dt-published" datetime="2023-01-22T03:54:01.930Z" itemprop="datePublished">2023-01-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="CMake-模块化项目管理"><a href="#CMake-模块化项目管理" class="headerlink" title="CMake 模块化项目管理"></a>CMake 模块化项目管理</h1><h2 id="自己项目文件-x2F-目录组织规范"><a href="#自己项目文件-x2F-目录组织规范" class="headerlink" title="自己项目文件&#x2F;目录组织规范"></a>自己项目文件&#x2F;目录组织规范</h2><h3 id="推荐的目录组织方式"><a href="#推荐的目录组织方式" class="headerlink" title="推荐的目录组织方式"></a><strong>推荐的目录组织方式</strong></h3><p><strong>源文件组织格式：</strong></p>
<ul>
<li>头文件存储路径：项目名&#x2F;include&#x2F;项目名&#x2F;模块名.h(需要在模块名前面再加一层项目名文件夹，这是为了让不同项目的头文件不会出现命名冲突)</li>
<li>cpp文件存储路径：项目名&#x2F;src&#x2F;模块名.cpp(直接在src下存储)</li>
</ul>
<img src="https://raw.githubusercontent.com/hufei96/Image/main/project_dirctory.png" alt="image-20221215015212928" style="zoom: 33%;" />

<p><strong>CMakeLists.txt 引入头文件：</strong></p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#不要使用include_directories，那会给所有目标添加目录，污染头文件空间</span></span><br><span class="line"><span class="keyword">target_include_directories</span>(项目名 PUBLIC <span class="keyword">include</span>)</span><br></pre></td></tr></table></figure>

<p> <strong>源码文件中使用模块：</strong></p>
<ul>
<li>包含时加上项目名：#include &lt;项目名&#x2F;模块名.h&gt;</li>
<li>使用时加上命名空间：项目名::函数名();</li>
</ul>
<p><strong>头文件（项目名&#x2F;include&#x2F;项目名&#x2F;模块名.h）中写：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> 项目名 &#123;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> 函数名();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>实现文件（项目名&#x2F;src&#x2F;模块名.cpp）中写：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;项目名/模块名.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> 项目名 &#123;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> 函数名() &#123; 函数实现 &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="划分子项目"><a href="#划分子项目" class="headerlink" title="划分子项目"></a>划分子项目</h3><p>大型的项目，往往会划分为几个子项目。即使你只有一个子项目，也建议你先创建一个子目录，方便以后追加新的子项目。</p>
<p>上图的案例中，我们在根目录下，创建了两个子项目 biology 和 pybmain，他们分别在各自的目录下有自己的 CMakeLists.txt。</p>
<h4 id="根项目和子项目的CMakeLists-txt配置"><a href="#根项目和子项目的CMakeLists-txt配置" class="headerlink" title="根项目和子项目的CMakeLists.txt配置"></a>根项目和子项目的CMakeLists.txt配置</h4><p>根项目的 CMakeLists.txt 负责处理全局有效的设定。而子项目的 CMakeLists.txt 则仅考虑该子项目自身的设定，比如他的头文件目录，要链接的库等等。</p>
<p><strong>根项目的CMakeLists.txt配置</strong></p>
<p>在根项目的 CMakeLists.txt 中，设置了默认的构建模式，设置了统一的 C++ 版本等各种选项。然后通过 project 命令初始化了根项目。(<strong>这些设置应该放在project命令之前</strong>)</p>
<p>随后通过 add_subdirectory 把两个子项目 pybmain 和 biology 添加进来（顺序无关紧要），这会调用 pybmain&#x2F;CMakeLists.txt 和 biology&#x2F;CMakeLists.txt。</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.18</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">NOT</span> CMAKE_BUILD_TYPE)</span><br><span class="line">    <span class="keyword">set</span>(CMAKE_BUILD_TYPE Release)</span><br><span class="line"><span class="keyword">endif</span>()</span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD <span class="number">20</span>)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD_REQUIRED <span class="keyword">ON</span>)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_EXTENSIONS <span class="keyword">OFF</span>)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_MODULE_PATH <span class="string">&quot;$&#123;CMAKE_CURRENT_LIST_DIR&#125;/cmake;$&#123;CMAKE_MODULE_PATH&#125;&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">project</span>(CppCMakeDemo LANGUAGES CXX)</span><br><span class="line"></span><br><span class="line"><span class="keyword">include</span>(MyUsefulFuncs)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_subdirectory</span>(pybmain)</span><br><span class="line"><span class="keyword">add_subdirectory</span>(biology)</span><br></pre></td></tr></table></figure>

<p><strong>子项目的CMakeLists.txt配置</strong></p>
<p>子项目的 CMakeLists.txt 就干净许多，只是创建了 biology 这个静态库对象，并通过 GLOB_RECRUSE 为他批量添加了所有位于 src 和 include 下源码和头文件。</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">file</span>(GLOB_RECURSE srcs CONFIGURE_DEPENDS src/*.cpp <span class="keyword">include</span>/*.h)</span><br><span class="line"><span class="keyword">add_library</span>(biology STATIC <span class="variable">$&#123;srcs&#125;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#使用PUBLIC修饰符，这是为了让链接 biology 的 pybmain 也能够共享 根/biology/include 这个头文件搜索路径</span></span><br><span class="line"><span class="keyword">target_include_directories</span>(biology PUBLIC <span class="keyword">include</span>)</span><br></pre></td></tr></table></figure>

<h4 id="依赖子项目"><a href="#依赖子项目" class="headerlink" title="依赖子项目"></a>依赖子项目</h4><p>依赖另一个子项目，则需要链接他</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">file</span>(GLOB_RECURSE srcs CONFIGURE_DEPENDS src/*.cpp <span class="keyword">include</span>/*.h)</span><br><span class="line"><span class="keyword">add_executable</span>(pybmain <span class="variable">$&#123;srcs&#125;</span>)</span><br><span class="line"><span class="keyword">target_include_directories</span>(pybmain PUBLIC <span class="keyword">include</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">target_link_libraries</span>(pybmain PUBLIC biology)</span><br></pre></td></tr></table></figure>

<p>由于 PUBLIC 属性具有传染性，根&#x2F;biology&#x2F;include 现在也加入 pybmain 的头文件搜索路径了，因此 pybmain 里可以 #include 到 biology 的头文件。</p>
<p>同理如果又有一个 target_link_libraries(zxxpig PUBLIC pybmain) 那么 zxxpig 也有 pybmain 和 biology 的所有头文件搜索路径了。</p>
<h2 id="第三方库-x2F-依赖项配置"><a href="#第三方库-x2F-依赖项配置" class="headerlink" title="第三方库&#x2F;依赖项配置"></a>第三方库&#x2F;依赖项配置</h2><h3 id="怎么链接第三方库"><a href="#怎么链接第三方库" class="headerlink" title="怎么链接第三方库"></a>怎么链接第三方库</h3><p>使用find_package<strong>寻找系统中安装的第三方库</strong>并链接他们(必须先安装)。<strong>在链接前需要先查看库的配置文件</strong>，确定其使用现代CMake还是古代CMake，否则无法知道怎么链接。</p>
<p><strong>大部分第三方库都需要提前安装好，然后再 find_package 找到他</strong>，然后才能链接。也有少数第三方库为了方便，还支持作为子项目加到你的项目中来，这种就不需要 :: 语法。</p>
<p><strong>标准方法：</strong></p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">find_package</span>(spdlog REQUIRED)</span><br><span class="line"></span><br><span class="line"><span class="keyword">target_link_libraries</span>(yourapp PUBLIC spdlog::spdlog)</span><br></pre></td></tr></table></figure>

<p><strong>邪教方法：</strong></p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_subdirectory</span>(spdlog) <span class="comment"># 需要下载好他们的源码放到你的根目录下</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">target_link_libraries</span>(yourapp PUBLIC spdlog)</span><br></pre></td></tr></table></figure>

<h3 id="find-package-命令用法举例"><a href="#find-package-命令用法举例" class="headerlink" title="find_package 命令用法举例"></a><strong>find_package 命令用法举例</strong></h3><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#查找名为 OpenCV 的包，找不到不报错，事后可以通过 $&#123;OpenCV_FOUND&#125; 查询是否找到。</span></span><br><span class="line"><span class="keyword">find_package</span>(OpenCV)</span><br><span class="line"></span><br><span class="line"><span class="comment">#查找名为 OpenCV 的包，找不到不报错，也不打印任何信息。</span></span><br><span class="line"><span class="keyword">find_package</span>(OpenCV QUIET)</span><br><span class="line"></span><br><span class="line"><span class="comment">#查找名为 OpenCV 的包，找不到就报错（并终止 cmake 进程，不再继续往下执行）。</span></span><br><span class="line"><span class="keyword">find_package</span>(OpenCV REQUIRED) <span class="comment">#最常见用法</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#查找名为 OpenCV 的包，找不到就报错，且必须具有 OpenCV::core 和 OpenCV::videoio 这两个组件，没有组件也报错</span></span><br><span class="line"><span class="keyword">find_package</span>(OpenCV REQUIRED COMPONENTS core videoio)</span><br><span class="line"></span><br><span class="line"><span class="comment">#查找名为 OpenCV 的包，找不到就报错，可具有 OpenCV::core 和 OpenCV::videoio 这两个组件，没有这两组件不会报错，通过 $&#123;OpenCV_core_FOUND&#125; 查询是否找到 core 组件。</span></span><br><span class="line"><span class="keyword">find_package</span>(OpenCV REQUIRED OPTIONAL_COMPONENTS core videoio)</span><br></pre></td></tr></table></figure>

<p><strong>指定find_package搜索包配置文件或是包搜索文件</strong></p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#只会寻找 FindTBB.cmake，搜索路径：$&#123;CMAKE_MODULE_PATH&#125;（默认为 /usr/share/cmake/Modules）</span></span><br><span class="line"><span class="keyword">find_package</span>(TBB MODULE REQUIRED)</span><br><span class="line"></span><br><span class="line"><span class="comment">#只会寻找 TBBConfig.cmake，搜索路径：1.$&#123;CMAKE_PREFIX_PATH&#125;/lib/cmake/TBB（默认为 /usr/lib/cmake/TBB）</span></span><br><span class="line"><span class="comment">#2.$&#123;TBB_DIR&#125; 或 $ENV&#123;TBB_DIR&#125;</span></span><br><span class="line"><span class="keyword">find_package</span>(TBB CONFIG REQUIRED)</span><br><span class="line"></span><br><span class="line"><span class="comment">#不指定则两者都会尝试，先尝试 FindTBB.cmake，再尝试 TBBConfig.cmake。</span></span><br><span class="line"><span class="keyword">find_package</span>(TBB REQUIRED)</span><br></pre></td></tr></table></figure>

<p><strong>指定库的版本号</strong></p>
<p>软件行业记录版本迭代普遍采用的是一套所谓的<strong>语义版本号</strong>系统，英文简称 semver。通常他的格式是三个用点分隔开来的十进制数字：&lt;major&gt;.&lt;minor&gt;.&lt;patch&gt;</p>
<p>例如：1.2.0，0.6.8，18.11.0</p>
<ul>
<li>major 称为主版本号，出现功能重大变更，以至于和旧 API 不兼容的时候会增加该号。</li>
<li>minor 称为次版本号，功能有所变更或增加，但依然和旧的 API 兼容时会增加该号。</li>
<li>patch 称为补丁版号，功能没有改变，只是修复了一些 bug 就重新发布时会增加该号。</li>
</ul>
<p>也有的软件不拘一格，索性用发布的日期作为版本号的三个数字，例如 2022.11.2。不论采用哪种编号方案，都是几个用点分开的数字，并且数字越大越新，且优先比较靠前面的数字。因此为了通用，CMake 支持最多四个点分开的版本号：&lt;major&gt;.&lt;minor&gt;.&lt;patch&gt;.&lt;tweak&gt;。并且如果你写 0.6.8 他会自动帮你把多余的 tweak 默认为 0，也就是说 0.6.8 &#x3D;&#x3D; 0.6.8.0，1.2 &#x3D;&#x3D; 1.2.0 &#x3D;&#x3D; 1.2.0.0。</p>
<p>比较版本号时，可以用 if (${XXX_VERSION} <strong>VERSION_LESS</strong> 3.1.0) 判断大小。</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#查找名为 OpenCV 的包，不限版本，事后可以通过 $&#123;OpenCV_VERSION&#125; 查询找到的版本。</span></span><br><span class="line"><span class="keyword">find_package</span>(OpenCV REQUIRED)</span><br><span class="line"></span><br><span class="line"><span class="comment">#查找版本在 2.0.1 以上的 OpenCV 包（version &gt;= 2.0.1）。</span></span><br><span class="line"><span class="keyword">find_package</span>(OpenCV <span class="number">2.0</span>.<span class="number">1</span> REQUIRED)</span><br><span class="line"></span><br><span class="line"><span class="comment">#查找版本刚好为 2.0.1 的 OpenCV 包（version == 2.0.1）。</span></span><br><span class="line"><span class="keyword">find_package</span>(OpenCV <span class="number">2.0</span>.<span class="number">1</span> EXACT REQUIRED)</span><br><span class="line"></span><br><span class="line"><span class="comment">#如果没写全，则没写的部分默认为 0。例如下列三者等价：</span></span><br><span class="line"><span class="keyword">find_package</span>(OpenCV <span class="number">2</span> REQUIRED)</span><br><span class="line"><span class="keyword">find_package</span>(OpenCV <span class="number">2.0</span> REQUIRED)</span><br><span class="line"><span class="keyword">find_package</span>(OpenCV <span class="number">2.0</span>.<span class="number">0</span> REQUIRED)</span><br></pre></td></tr></table></figure>

<h3 id="find-package实际在寻找什么"><a href="#find-package实际在寻找什么" class="headerlink" title="find_package实际在寻找什么"></a>find_package实际在寻找什么</h3><p>find_package实际是在寻找库的CMake配置文件，形式如 <strong>包名</strong> <strong>+</strong> <strong>Config.cmake</strong> ，这些文件可称为<strong>包配置文件</strong>。</p>
<p>所以find_package(OpenCV) 实际上是在找一个名为 <strong>OpenCVConfig.cmake</strong> 的文件。(出于历史兼容性考虑，除了 OpenCVConfig.cmake 以外 <strong>OpenCV-config.cmake</strong> 这个文件名也会被 CMake 识别到)；同理，find_package(Qt5) 则是会去找名为 <strong>Qt5Config.cmake</strong> 的文件。</p>
<p>这些配置文件在你安装库时，会随着 libxx.so 等实际的库文件一起装到你的系统中去。以 Arch Linux 系统中安装Qt5为例：</p>
<p>包配置文件位于 &#x2F;usr&#x2F;lib&#x2F;cmake&#x2F;Qt5&#x2F;Qt5Config.cmake。</p>
<p>实际的动态库文件位于 &#x2F;usr&#x2F;lib&#x2F;libQt5Core.so。</p>
<p>这个配置文件里包含了包的具体信息，包括动态库文件的位置，头文件的目录，链接时需要开启的编译选项等等。而且某些库都具有多个子动态库，例如 Qt 就有 libQt5Core.so、libQt5Widgets.so、libQt5Network.so。因此 CMake 要求所有第三方库作者统一包装成一个 Qt5Config.cmake 文件包含所有相关信息（类似于 nodejs 的 package.json），比你单独的一个个去找动态库文件要灵活的多。</p>
<p>包配置文件由第三方库的作者（Qt的开发团队）提供，在这个库安装时（Qt的安装程序或apt install等）会自动放到 &#x2F;usr&#x2F;lib&#x2F;cmake&#x2F;XXX&#x2F;XXXConfig.cmake 这个路径（其中XXX是包名），供 CMake 用户找到并了解该包的具体信息。</p>
<p>&#x2F;usr&#x2F;lib&#x2F;cmake 这个位置是 CMake 和第三方库作者<strong>约定俗成</strong>的，由第三方库的安装程序负责把包配置文件放到这里。如果第三方库的作者比较懒，没提供 CMake 支持（由安装程序提供XXXConfig.cmake），那么得用另外的一套方法（FindXXX.cmake）。</p>
<h3 id="find-package的搜索路径"><a href="#find-package的搜索路径" class="headerlink" title="find_package的搜索路径"></a>find_package的搜索路径</h3><p><strong>Windows</strong> <strong>系统下的搜索路径</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;prefix&gt;/</span><br><span class="line">&lt;prefix&gt;/cmake/</span><br><span class="line">&lt;prefix&gt;/&lt;name&gt;*/</span><br><span class="line">&lt;prefix&gt;/&lt;name&gt;*/cmake/</span><br><span class="line">&lt;prefix&gt;/&lt;name&gt;*/(lib/&lt;arch&gt;|lib*|share)/cmake/&lt;name&gt;*/</span><br><span class="line">&lt;prefix&gt;/&lt;name&gt;*/(lib/&lt;arch&gt;|lib*|share)/&lt;name&gt;*/</span><br><span class="line">&lt;prefix&gt;/&lt;name&gt;*/(lib/&lt;arch&gt;|lib*|share)/&lt;name&gt;*/cmake/</span><br><span class="line"></span><br><span class="line"><span class="comment">//其中 &lt;prefix&gt; 是变量 $&#123;CMAKE_PREFIX_PATH&#125;，Windows 平台默认为 C:/Program Files。</span></span><br><span class="line"><span class="comment">//&lt;name&gt; 是你在 find_package(&lt;name&gt; REQUIRED) 命令中指定的包名。</span></span><br><span class="line"><span class="comment">//&lt;arch&gt; 是系统的架构名。</span></span><br></pre></td></tr></table></figure>

<p><strong>Unix</strong> <strong>类系统下的搜索路径</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;prefix&gt;/(lib/&lt;arch&gt;|lib*|share)/cmake/&lt;name&gt;*/</span><br><span class="line">&lt;prefix&gt;/(lib/&lt;arch&gt;|lib*|share)/&lt;name&gt;*/</span><br><span class="line">&lt;prefix&gt;/(lib/&lt;arch&gt;|lib*|share)/&lt;name&gt;*/cmake/</span><br><span class="line">&lt;prefix&gt;/&lt;name&gt;*/(lib/&lt;arch&gt;|lib*|share)/cmake/&lt;name&gt;*/</span><br><span class="line">&lt;prefix&gt;/&lt;name&gt;*/(lib/&lt;arch&gt;|lib*|share)/&lt;name&gt;*/</span><br><span class="line">&lt;prefix&gt;/&lt;name&gt;*/(lib/&lt;arch&gt;|lib*|share)/&lt;name&gt;*/cmake/</span><br><span class="line"></span><br><span class="line"><span class="comment">//其中 &lt;prefix&gt; 是变量 $&#123;CMAKE_PREFIX_PATH&#125;，Unix 平台默认为 /usr。</span></span><br><span class="line"><span class="comment">//&lt;name&gt; 是你在 find_package(&lt;name&gt; REQUIRED) 命令中指定的包名。</span></span><br><span class="line"><span class="comment">//&lt;arch&gt; 是系统的架构，例如 x86_64-linux-gnu 或 i386-linux-gnu。(用于伺候 Ubuntu 喜欢把库文件套娃在 /usr/lib/x86_64-linux-gnu 目录下)</span></span><br></pre></td></tr></table></figure>

<p><strong>举例说明</strong> <strong>find_package</strong> <strong>搜索路径</strong></p>
<p>以Qt5为例：</p>
<p>在64 位的 Linux 系统，find_package(Qt5 REQUIRED) 会依次搜索：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">/usr/lib/cmake/Qt5/Qt5Config.cmake</span><br><span class="line">/usr/lib/x86_64-linux-gnu/cmake/Qt5/Qt5Config.cmake</span><br><span class="line">/usr/share/cmake/Qt5/Qt5Config.cmake</span><br><span class="line">/usr/lib/Qt5/Qt5Config.cmake</span><br><span class="line">/usr/lib/x86_64-linux-gnu/Qt5/Qt5Config.cmake</span><br><span class="line">/usr/share/Qt5/Qt5Config.cmake</span><br><span class="line">/usr/Qt5/lib/cmake/Qt5/Qt5Config.cmake</span><br><span class="line">/usr/Qt5/lib/x86_64-linux-gnu/cmake/Qt5/Qt5Config.cmake</span><br><span class="line">/usr/Qt5/share/cmake/Qt5/Qt5Config.cmake</span><br><span class="line">/usr/Qt5/lib/Qt5/Qt5Config.cmake</span><br><span class="line">/usr/Qt5/lib/x86_64-linux-gnu/Qt5/Qt5Config.cmake</span><br><span class="line">/usr/Qt5/share/Qt5/Qt5Config.cmake</span><br></pre></td></tr></table></figure>

<p>64 位的 Windows 系统，find_package(Qt5 REQUIRED) 会依次搜索：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">C:/Program Files/Qt5Config.cmake</span><br><span class="line">C:/Program Files/cmake/Qt5Config.cmake</span><br><span class="line">C:/Program Files/Qt5/Qt5Config.cmake</span><br><span class="line">C:/Program Files/Qt5/cmake/Qt5Config.cmake</span><br><span class="line">C:/Program Files/Qt5/lib/cmake/Qt5/Qt5Config.cmake</span><br><span class="line">C:/Program Files/Qt5/lib/x86_64-windows-gnu/cmake/Qt5/Qt5Config.cmake</span><br><span class="line">C:/Program Files/Qt5/share/cmake/Qt5/Qt5Config.cmake</span><br><span class="line">C:/Program Files/Qt5/lib/Qt5/Qt5Config.cmake</span><br><span class="line">C:/Program Files/Qt5/lib/x86_64-windows-gnu/Qt5/Qt5Config.cmake</span><br><span class="line">C:/Program Files/Qt5/share/Qt5/Qt5Config.cmake</span><br></pre></td></tr></table></figure>

<p>还有一点，&lt;name&gt; <strong>可以有额外后缀，且不分大小写</strong>（无论 Linux 还是 Windows），例如下面路径同样都是可以被 find_package(Qt5 REQUIRED) 搜索到的。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">C:/Program Files/Qt5/cmake/Qt5Config.cmake</span><br><span class="line">C:/Program Files/Qt5.12.1/cmake/Qt5Config.cmake</span><br><span class="line">C:/Program Files/qt5dnmd/cmake/Qt5Config.cmake</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">Linux同理，同样都是可以被 find_package(OpenCV REQUIRED) 搜索到的。</span></span><br><span class="line">/usr/lib/cmake/OpenCV/OpenCVConfig.cmake</span><br><span class="line">/usr/lib/cmake/opencv4/OpenCVConfig.cmake</span><br></pre></td></tr></table></figure>

<h3 id="寻找安装在非标准路径的库"><a href="#寻找安装在非标准路径的库" class="headerlink" title="寻找安装在非标准路径的库"></a>寻找安装在非标准路径的库</h3><p>以 Qt5 为例，如果你安装在下列标准路径，find_package 能够自动找到。</p>
<p>Windows：C:&#x2F;Program Files&#x2F;Qt5.12.1&#x2F;lib&#x2F;cmake&#x2F;Qt5&#x2F;Qt5Config.cmake。</p>
<p>Linux：&#x2F;usr&#x2F;lib&#x2F;cmake&#x2F;Qt5&#x2F;Qt5Config.cmake。</p>
<p>但是假如我的库不是装在这些标准路径，而是我<strong>自定义的路径</strong>，怎么办？而且即使你不自定义安装路径，Windows 版的 Qt 默认安装就会安装到：C:&#x2F;Qt5.12.1&#x2F;msvc2017_64&#x2F;lib&#x2F;cmake&#x2F;Qt5&#x2F;Qt5Config.cmake。</p>
<p>何况我们同学有的还喜欢装到 D 盘去，<strong>Windows 是非标准路径的重灾区</strong>，他就没有一个统一的 &#x2F;usr&#x2F;lib 目录。然而你一旦把库安装到非标准路径，find_package 是找不到的。</p>
<p><strong>这时你需要手动指定一个变量告诉他在哪儿</strong>，可以是普通变量 **${Qt5_DIR}**，也可以是环境变量 **$ENV{Qt5_DIR}**，两个中只要设置了任何一个 find_package 都可以识别到。</p>
<p><strong>设置变量的方法</strong></p>
<p>以Qt5为例</p>
<p><strong>Windows下设置变量</strong></p>
<p>例如我把 Qt5 安装到了 D:&#x2F;Qt5.12.1。首先找到他里面的 Qt5Config.cmake 文件所在位置（可以用文件管理器的“搜索”功能）。</p>
<p>假如你找到该文件的位置是 D:&#x2F;Qt5.12.1&#x2F;msvc2017&#x2F;lib&#x2F;cmake&#x2F;Qt5&#x2F;Qt5Config.cmake，那么请你设置变量 Qt5_DIR 为 D:&#x2F;Qt5.12.1&#x2F;msvc2017&#x2F;lib&#x2F;cmake&#x2F;Qt5。有三种设置方法：</p>
<ul>
<li>单次有效。在 configure 阶段，可以从命令行设置（注意路径要加引号）：</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmake -B build -DQt5_DIR=&quot;D:/Qt5.12.1/msvc2017/lib/cmake/Qt5&quot;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>全局启用。右键“我的电脑”-&gt;“管理”-&gt;“高级”添加一个环境变量 Qt5_DIR 值为 D:&#x2F;Qt5.12.1&#x2F;msvc2017&#x2F;lib&#x2F;cmake&#x2F;Qt5，然后重启 Visual Studio。这样以后你每次构建任何项目，find_package 都能自动找到这个路径的 Qt5 包了。</p>
</li>
<li><p>单项目有效。直接在你自己项目的 CMakeLists.txt 最开头写一行（注意路径要加引号，且一定要加在最前面）</p>
</li>
</ul>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span>(Qt5_DIR <span class="string">&quot;D:/Qt5.12.1/msvc2017/lib/cmake/Qt5&quot;</span>) </span><br></pre></td></tr></table></figure>

<p><strong>Linux下设置变量</strong></p>
<p>例如我把 Qt5 安装到了 &#x2F;opt&#x2F;Qt5.12.1。首先找到他里面的 Qt5Config.cmake 文件所在位置（可以用文件管理器的“搜索”功能）。</p>
<p>假如你找到该文件的位置是 &#x2F;opt&#x2F;Qt5.12.1&#x2F;lib&#x2F;cmake&#x2F;Qt5&#x2F;Qt5Config.cmake，那么请你设置变量 Qt5_DIR 为 &#x2F;opt&#x2F;Qt5.12.1&#x2F;lib&#x2F;cmake&#x2F;Qt5。有三种设置方法：</p>
<ul>
<li>单次有效。在 configure 阶段，可以从命令行设置（注意路径要加引号）：</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmake -B build -DQt5_DIR=&quot;/opt/Qt5.12.1/lib/cmake/Qt5&quot;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>全局启用。修改你的 ~&#x2F;.bashrc 文件添加环境变量：export Qt5_DIR&#x3D;”&#x2F;opt&#x2F;Qt5.12.1&#x2F;lib&#x2F;cmake&#x2F;Qt5”，然后重启终端。这样以后你每次构建任何项目，find_package 都能自动找到这个路径的 Qt5 包了。</p>
</li>
<li><p>单项目有效。直接在你自己项目的 CMakeLists.txt 最开头写一行（注意路径要加引号，且一定要加在最前面）</p>
</li>
</ul>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span>(Qt5_DIR <span class="string">&quot;/opt/Qt5.12.1/lib/cmake/Qt5&quot;</span>)    </span><br></pre></td></tr></table></figure>

<p><strong>三种方案利弊分析</strong></p>
<ul>
<li><p>单次有效（通过命令行）最安全，<strong>推荐</strong>。</p>
</li>
<li><p>全局有效（添加环境变量）可能影响以后其他项目。比如你 A 项目依赖 Qt5.12.1，你设置了环境变量 Qt5_DIR&#x3D;&#x2F;opt&#x2F;Qt5.12.1，后来又搞了个 B 项目依赖 Qt5.10.3，但是你忘了你设置过全局的环境变量指向 5.12.1 了，导致版本冲突。</p>
</li>
<li><p>单项目有效（写死在 CMakeLists.txt）虽然方便了你，但是你的 CMakeLists.txt 拿到别人电脑上（例如你通过 GitHub 开源的），可能你 set(Qt5_DIR D:&#x2F;Qt5)，而人家却需要 set(Qt5_DIR E:&#x2F;Qt5) 呢？就冲突了。</p>
</li>
</ul>
<p>因此最推荐单次有效。虽然麻烦，但因为CMake可以缓存变量，实际上只要你不删 build，不需要每次都 -DQt5_DIR 一下。</p>
<h3 id="学习Qt5的目录组织格式"><a href="#学习Qt5的目录组织格式" class="headerlink" title="学习Qt5的目录组织格式"></a>学习Qt5的目录组织格式</h3><p><strong>Qt5在Windows下的格式</strong></p>
<p>例如你安装 Qt 时设置安装路径为 D:&#x2F;Qt5.12.1。</p>
<p>则你会看到他下面有几个子目录：</p>
<ul>
<li>D:&#x2F;Qt5.12.1&#x2F;msvc2017_64（由VS2017编译64位版本）</li>
<li>D:&#x2F;Qt5.12.1&#x2F;mingw_64（由MinGW编译64位版本）</li>
</ul>
<p>这几个目录里又分别包含：</p>
<ul>
<li>D:&#x2F;Qt5.12.1&#x2F;msvc2017_64&#x2F;include&#x2F;qt&#x2F;QtCore&#x2F;<strong>qstring.h</strong>（实际的头文件，属于 Qt5::Core）</li>
<li>D:&#x2F;Qt5.12.1&#x2F;msvc2017_64&#x2F;bin&#x2F;<strong>Qt5Core.dll</strong>（实际的动态库文件，对应 Qt5::Core）</li>
<li>D:&#x2F;Qt5.12.1&#x2F;msvc2017_64&#x2F;lib&#x2F;<strong>Qt5Core.lib</strong>（实际的静态库文件，对应 Qt5::Core）</li>
<li>D:&#x2F;Qt5.12.1&#x2F;msvc2017_64&#x2F;lib&#x2F;cmake&#x2F;Qt5&#x2F;<strong>Qt5Config.cmake</strong>（包配置文件）</li>
</ul>
<p>可以看到尽管是 Windows 版的 Qt，他内部仍然是在模仿 Linux 下 &#x2F;usr 的目录组织格式。</p>
<p>注意这里的 Qt5Core.dll 位于 bin 目录，而不是 lib 目录，这是为什么呢？因为 <strong>Windows 要求 exe 和 dll 位于同一目录，否则 exe 在运行时就会找不到 dll</strong>。为了符合 Linux 分离 bin 和 lib 的组织格式，又要伺候 Windows 的沙雕同目录规则，我们通常把 dll 动态库文件视为“可执行文件”和 exe 一起放到 bin 目录，而静态库则没有运行时必须同目录的限制，所以可以照常放到 lib 目录。</p>
<p><strong>Qt5在Linux下的格式</strong></p>
<p>Linux 用户从源码安装 Qt 这种库时，会有一个 –prefix 选项，指定安装的根路径。</p>
<p>默认的 –prefix 是 &#x2F;usr，这个路径由全部软件共享，Qt 会把他的文件安装到以下目录：</p>
<ul>
<li>&#x2F;usr&#x2F;include&#x2F;qt&#x2F;QtCore&#x2F;<strong>qstring.h</strong>（实际的头文件，对应 Qt5::Core）</li>
<li>&#x2F;usr&#x2F;lib&#x2F;lib<strong>Qt5Core.so</strong>（实际的动态库文件，对应 Qt5::Core）</li>
<li>&#x2F;usr&#x2F;lib&#x2F;lib<strong>Qt5Core.a</strong>（实际的静态库文件，对应 Qt5::Core）</li>
<li>&#x2F;usr&#x2F;lib&#x2F;cmake&#x2F;Qt5&#x2F;<strong>Qt5Config.cmake</strong>（包配置文件，用于 find_package）</li>
</ul>
<p>假如你指定 –prefix&#x3D;&#x2F;opt&#x2F;myqtroot，这个路径通常是用户自己手动装的软件，那么就会变成：</p>
<ul>
<li>&#x2F;opt&#x2F;myqtroot&#x2F;lib&#x2F;cmake&#x2F;Qt5&#x2F;<strong>Qt5Config.cmake</strong></li>
</ul>
<p>伺候这种非常规安装，就需要设置变量 -DQt5_DIR&#x3D;&#x2F;opt&#x2F;myqtroot&#x2F;lib&#x2F;cmake&#x2F;Qt5 了。</p>
<h3 id="安装库的通用方法"><a href="#安装库的通用方法" class="headerlink" title="安装库的通用方法"></a>安装库的通用方法</h3><p><strong>Makefile 构建系统：</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">./configure --prefix=/usr --with-some-options  # 生成 Makefile（这个 configure 脚本由 Autoconf 生成）</span><br><span class="line"></span><br><span class="line">make -j 8        # 8 核心编译，生成 libtest.so</span><br><span class="line"></span><br><span class="line">sudo make install  # 安装，拷贝到 /usr/lib/libtest.so</span><br></pre></td></tr></table></figure>

<p><strong>CMake 构建系统：</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cmake -B build -DCMAKE_INSTALL_PREFIX=/usr -DWITH_SOME_OPTIONS=ON # 生成 Makefile</span><br><span class="line"></span><br><span class="line">cmake --build build --parallel 8         # 8 核心编译，生成 libtest.so</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">注：如果 -DCMAKE_INSTALL_PREFIX=/usr/local 则会拷贝到 /usr/local/lib/libtest.so</span></span><br><span class="line">sudo cmake --build build --target install  # 安装，拷贝到 /usr/lib/libtest.so</span><br></pre></td></tr></table></figure>

<h3 id="第三方库没有提供Config文件的解决方法"><a href="#第三方库没有提供Config文件的解决方法" class="headerlink" title="第三方库没有提供Config文件的解决方法"></a>第三方库没有提供Config文件的解决方法</h3><p>绝大多数常用 C++ 库都提供了 CMake 支持（即使他们本身不一定是用 CMake 构建的），这些 <strong>Config</strong> <strong>文件</strong>都是由<strong>第三方库负责</strong>安装到 &#x2F;usr&#x2F;lib&#x2F;cmake。</p>
<p>但是，也有少数不听话的库，官方不提供 CMake 支持，即安装时不自带 Config 文件。恼人的是，这些不听话的库有些竟然是非常热门的库！例如 Python，CUDA，Jemalloc。</p>
<p>为了不影响 CMake 用户体验，CMake 发明了 <strong>Find</strong> <strong>文件</strong>（FindXXX.cmake），你不支持我是吧？我支持你！Find 文件会在 <strong>CMake</strong> <strong>安装时负责</strong>安装到 &#x2F;usr&#x2F;share&#x2F;cmake&#x2F;Modules。</p>
<p>包搜索文件可以在不知道包具体位置信息的情况下搜索他们（在 &#x2F;usr&#x2F;lib 等默认路径搜索）。这些都是 CMake 自带的包搜索文件：</p>
<ul>
<li>&#x2F;usr&#x2F;share&#x2F;cmake&#x2F;Modules&#x2F;FindCUDAToolkit.cmake</li>
<li>&#x2F;usr&#x2F;share&#x2F;cmake&#x2F;Modules&#x2F;FindPython.cmake</li>
</ul>
<p><strong>下载和使用包搜索文件</strong></p>
<p>那么如果有个不太热门的第三方库没提供包配置文件，CMake 也没提供包搜索文件，我们该如何找到他？这就<strong>需要自己提供包搜索文件</strong>了！别担心，你不用自己写，GitHub 上有很多志士仁人已经写过了对应的包搜索文件，你搜一下 FindXXX.cmake 就能找到了。</p>
<p>虽然 <strong>Config</strong> <strong>文件</strong>通常风格比较统一，都是 XXX::xxx 这种格式。但是不同的 <strong>Find</strong> <strong>文件</strong>，特别是这种网上志士仁人自己编写的文件，风格可能千差万别，很多都还是古代 CMake 的用法，例如 ${XXX_LIBRARIES}。关于具体使用的细节可以打开 FindXXX.cmake 文件查看，他里面前半部分是注释，会讲解如何使用。</p>
<p>现在你下载这个文件，<strong>放到项目根目录相对路径 cmake&#x2F;FindXXX.cmake。然后在你的 CMakeLists.txt 里最上面写一行：</strong></p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span>(CMAKE_MODULE_PATH <span class="string">&quot;$&#123;CMAKE_CURRENT_LIST_DIR&#125;/cmake;$&#123;CMAKE_MODULE_PATH&#125;&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>这样你之后的 find_package(XXX) 就会用你下载的这个 FindXXX.cmake 去找包了。</p>
<h3 id="链接现代古代CMake库的不同"><a href="#链接现代古代CMake库的不同" class="headerlink" title="链接现代古代CMake库的不同"></a>链接现代古代CMake库的不同</h3><p>大多现代的 Find&#x2F;Config 文件，都同时兼容现代和古代的用法。特别古老的 Find 文件，则只能用古代的用法。</p>
<p><strong>现代和古代的区别</strong></p>
<p>不管是 Find 类还是 Config 类，<strong>一定要打开相应的 cmake 文件看看注释</strong>，才能确定他是古代风格还是现代风格。</p>
<p>古代 CMake 的命名规范高度不统一，有的是 ${XXX_LIBRARIES}，有的又是 ${XXX_LIBRARY} 非常沙雕，需要看相应 cmake 文件的注释，才能确定具体是怎么命名的。</p>
<p>现代 CMake 就好多了，统一用 <strong>包名::组件名</strong> 的格式。但是具体的组件名，还是要查看 cmake 文件中的注释才能确定。例如 CURL::libcurl OpenCV::core Qt5::core TBB::tbb 等。</p>
<p><strong>链接现代和古代的区别</strong></p>
<p><strong>古代</strong>（仅用于伺候很老的库）：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">find_package</span>(XXX)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">NOT</span> XXX_FOUND)</span><br><span class="line"></span><br><span class="line"><span class="keyword">message</span>(FATAL_ERROR “XXX <span class="keyword">not</span> found”)</span><br><span class="line"></span><br><span class="line"><span class="keyword">endif</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">target_include_directories</span>(yourapp <span class="variable">$&#123;XXX_INCLUDE_DIRS&#125;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">target_link_libraries</span>(yourapp <span class="variable">$&#123;XXX_LIBRARIES&#125;</span>)</span><br></pre></td></tr></table></figure>

<p><strong>现代</strong>：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">find_package</span>(XXX REQUIRED COMPONENTS xxx)</span><br><span class="line"></span><br><span class="line"><span class="keyword">target_link_libraries</span>(yourapp XXX::xxx)</span><br></pre></td></tr></table></figure>

<h3 id="古代CMake常见问题"><a href="#古代CMake常见问题" class="headerlink" title="古代CMake常见问题"></a>古代CMake常见问题</h3><p><strong>链接步骤</strong></p>
<p>1.target_link_libraries(yourapp <strong>${XXX_LIBRARIES}</strong>)</p>
<p>2.target_include_directories(yourapp <strong>${XXX_INCLUDE_DIRS}</strong>)</p>
<p>Q: 我明明链接了 XXX 库，编译时却报错“找不到头文件 XXX.h”怎么办？</p>
<p>A: 你漏了上面的 2。</p>
<p>Q: 我明明编译都通过了，链接却报错“undefined symbol：XXXfunc”怎么办？</p>
<p>A: 你漏了上面的 1。</p>
<p><strong>解决方法</strong></p>
<p>打印检查一下这两个变量是不是空的：message(“!!!!!!” <strong>${XXX_INCLUDE_DIRS}</strong>)，如果为空说明你变量名打错了，CMake 特色就是<strong>找不到变量不报错，而是视为空字符串</strong>。去看一下 FindXXX.cmake 里的注释（那就是文档），到底是什么名字。</p>
<h3 id="总结第三方库的安装和使用"><a href="#总结第三方库的安装和使用" class="headerlink" title="总结第三方库的安装和使用"></a>总结第三方库的安装和使用</h3><p>安装 TBB：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">cd tbb</span><br><span class="line"></span><br><span class="line">./configure --prefix=/opt/tbbinstalldir #以安装在自定义路径为例</span><br><span class="line"></span><br><span class="line">make -j 8</span><br><span class="line"></span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure>

<p>在你的项目里使用 TBB：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cd yourapp</span><br><span class="line"></span><br><span class="line">cmake -B build -DTBB_DIR=/opt/tbbinstalldir/lib/cmake/TBB</span><br><span class="line"></span><br><span class="line">cmake --build build --parallel 8</span><br></pre></td></tr></table></figure>

<p>CMakeLists.txt 这样写：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">project</span>(yourapp)</span><br><span class="line"><span class="keyword">add_executable</span>(yourapp yourmain.cpp)</span><br><span class="line"><span class="keyword">find_package</span>(TBB CONFIG REQUIRED COMPONENTS tbb)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(yourapp PUBLIC TBB::tbb)</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/01/22/CMake%20%E6%A8%A1%E5%9D%97%E5%8C%96%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/" data-id="cld6uioj50005acsfc7wzcd6n" data-title="" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-c++异步编程" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/01/22/c++%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/" class="article-date">
  <time class="dt-published" datetime="2023-01-22T03:54:01.928Z" itemprop="datePublished">2023-01-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="c-异步编程"><a href="#c-异步编程" class="headerlink" title="c++异步编程"></a>c++异步编程</h1><h2 id="std-future"><a href="#std-future" class="headerlink" title="std::future"></a>std::future</h2><p>std::future期待一个返回，从一个异步调用的角度来说，<strong>future更像是函数的返回值</strong>，异步调用往往不知道何时返回，但是如果异步调用的过程需要同步，或者说后一个异步调用需要使用前一个异步调用的结果。这个时候就要用到future。</p>
<p>线程可以周期性的在这个future上等待一小段时间，检查future是否已经ready，如果没有，该线程可以先去做另一个任务，一旦future就绪，<strong>该future就无法复位（无法再次使用这个future等待这个事件），所以future代表的是一次性事件</strong>。</p>
<h3 id="future的类型"><a href="#future的类型" class="headerlink" title="future的类型"></a>future的类型</h3><p>在<code>&lt;future&gt;</code>库的头文件中声明了两种future，唯一future（std::future）和共享future（std::shared_future）这两个是参照std::unique_ptr和std::shared_ptr设立的，前者的实例是仅有的一个指向其关联事件的实例，而后者可以有多个实例指向同一个关联事件，当事件就绪时，所有指向同一事件的std::shared_future实例会变成就绪。</p>
<h3 id="future的使用"><a href="#future的使用" class="headerlink" title="future的使用"></a>future的使用</h3><p>std::future是一个模板，例如<code>std::future&lt;int&gt;</code>，模板参数就是期待返回的类型，虽然future被用于线程间通信，但其本身却并不提供同步访问，必须通过互斥元或其他同步机制来保护访问。</p>
<p>future使用的时机是当你不需要立刻得到一个结果的时候，你可以开启一个线程帮你去做一项任务，并期待这个任务的返回，但是std::thread并没有提供这样的机制，这就需要用到std::async和std::future（都在<code>&lt;future&gt;</code>头文件中声明）。</p>
<p>std::async返回一个std::future对象，而不是给你一个确定的值。当你需要使用这个值的时候，对future使用get()，线程就会阻塞直到future就绪，然后返回该值。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;future&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find_result_to_add</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span> + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">do_other_things</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;Hello World&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	std::future&lt;<span class="type">int</span>&gt; result = std::<span class="built_in">async</span>(find_result_to_add);</span><br><span class="line">	<span class="built_in">do_other_things</span>();</span><br><span class="line">	std::cout &lt;&lt; result.<span class="built_in">get</span>() &lt;&lt; std::endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="std-async"><a href="#std-async" class="headerlink" title="std::async"></a>std::async</h2><p><code>std::async</code>跟<code>std::thread</code>类似，区别在于thread无法获取函数的返回值，而async可以。</p>
<p><code>std::async</code>会自动创建一个线程去调用线程函数，它返回一个<code>std::future</code>，这个future中存储了线程函数返回的结果，当我们需要线程函数的结果时，直接从future中获取，非常方便。</p>
<p>跟thread类似，async允许你通过将额外的参数添加到调用中，来将附加参数传递给函数。如果传入的函数指针是某个类的成员函数，则还需要将类对象指针传入（直接传入，传入指针，或者是std::ref封装）。</p>
<p>默认情况下，std::async是否启动一个新线程，或者在等待future时，任务是否同步运行都取决于你给的参数。这个参数为std::launch类型</p>
<ul>
<li>std::launch::defered表明该函数会被延迟调用，直到在future上调用get()或者wait()为止</li>
<li>std::launch::async，表明函数会在自己创建的线程上运行</li>
<li>std::launch::any &#x3D; std::launch::defered | std::launch::async</li>
<li>std::launch::sync &#x3D; std::launch::defered</li>
</ul>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="class"><span class="keyword">class</span> <span class="title">launch</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">async</span>,<span class="keyword">deferred</span>,<span class="keyword">sync</span>=<span class="keyword">deferred</span>,any=<span class="keyword">async</span>|<span class="keyword">deferred</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>PS：默认选项参数被设置为std::launch::any。如果函数被延迟运行可能永远都不会运行。</strong></p>
<p>async的原理大概是这样的：std::async先将异步操作用std::packaged_task包装起来，然后将异步操作的结果放到std::promise中，外面再通过future.get&#x2F;wait来获取这个未来的结果。std::async类似封装了<code>thread</code>和<code>packged_task</code>的功能，使得我们使用起来更加方便简单。</p>
<h2 id="std-packaged-task"><a href="#std-packaged-task" class="headerlink" title="std::packaged_task"></a>std::packaged_task</h2><p><code>std::packaged_task</code>和<code>std::function</code>类似，区别在于<code>std::packaged_task</code>可以用于异步调用，packaged_task.get_future()可以返回<code>std::future</code>，配合future使用可以异步获取函数的返回值。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;future&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">do_other_things</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;Hello World&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">std::packaged_task&lt;<span class="title">int</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span>&gt; <span class="title">task</span><span class="params">(add)</span></span>;</span><br><span class="line">	<span class="built_in">do_other_things</span>();</span><br><span class="line">	std::future&lt;<span class="type">int</span>&gt; result = task.<span class="built_in">get_future</span>();</span><br><span class="line">	<span class="built_in">task</span>(<span class="number">1</span>, <span class="number">1</span>); <span class="comment">//必须要让任务执行，否则在get()获取future的值时会一直阻塞</span></span><br><span class="line">	std::cout &lt;&lt; result.<span class="built_in">get</span>() &lt;&lt; std::endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="std-promise"><a href="#std-promise" class="headerlink" title="std::promise"></a>std::promise</h2><p><code>std::promise&lt;T&gt;</code>与<code>std::future&lt;T&gt;</code>配合使用，区别在于promise只写，而future只读。promise用于写入函数的返回值，而future则可以从promise处获取返回值。</p>
<p>在创建promise的同时会获得一个future，然后将promise传递给其他线程，当前线程则持有future，future.get()会阻塞直到promise写入返回值。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;future&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(std::promise&lt;std::string&gt;&amp; p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	p.<span class="built_in">set_value</span>(<span class="string">&quot;There is the result whitch you want.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">do_some_other_things</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;Hello World&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	std::promise&lt;std::string&gt; promise;</span><br><span class="line">	std::future&lt;std::string&gt; result = promise.<span class="built_in">get_future</span>();</span><br><span class="line">	<span class="function">std::thread <span class="title">t</span><span class="params">(print, std::ref(promise))</span></span>;</span><br><span class="line">	<span class="built_in">do_some_other_things</span>();</span><br><span class="line">	std::cout &lt;&lt; result.<span class="built_in">get</span>() &lt;&lt; std::endl; <span class="comment">//阻塞直到，p.set_value()执行完成</span></span><br><span class="line">	t.<span class="built_in">join</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/01/22/c++%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/" data-id="cld6uioj10002acsfeusw7vdy" data-title="" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/2/">&laquo; Prev</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/4/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/01/">January 2023</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2023/01/22/%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B/">(no title)</a>
          </li>
        
          <li>
            <a href="/2023/01/22/%E7%BD%91%E7%BB%9Cio%E6%A8%A1%E5%9E%8B/">(no title)</a>
          </li>
        
          <li>
            <a href="/2023/01/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/">(no title)</a>
          </li>
        
          <li>
            <a href="/2023/01/22/%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E5%AE%9A%E6%97%B6%E5%99%A8/">(no title)</a>
          </li>
        
          <li>
            <a href="/2023/01/22/%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%E9%9D%9E%E6%B3%95%E8%BE%93%E5%85%A5%E4%BB%A5%E5%8F%8A%E6%9E%84%E9%80%A0%E5%BC%82%E5%B8%B8%E6%83%85%E5%86%B5/">(no title)</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2023 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>