<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>hufei的博客</title>
  <meta name="keywords" content="">
  <meta name="description" content="hufei的博客">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="description" content="网络模型方案均以粗糙的 Python 玩具代码为例 方案 1（Accept + Read&#x2F;Write）import socket  def handle(client_socket, client_address):     &#x2F;&#x2F; L6     while True:         data &#x3D; client_socket.recv(4096)         if data:">
<meta property="og:type" content="article">
<meta property="og:title" content="hufei的博客">
<meta property="og:url" content="http://example.com/2023/01/22/%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B/index.html">
<meta property="og:site_name" content="hufei的博客">
<meta property="og:description" content="网络模型方案均以粗糙的 Python 玩具代码为例 方案 1（Accept + Read&#x2F;Write）import socket  def handle(client_socket, client_address):     &#x2F;&#x2F; L6     while True:         data &#x3D; client_socket.recv(4096)         if data:">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://sleepy-1256633542.cos.ap-beijing.myqcloud.com/20181222103157.png">
<meta property="og:image" content="https://sleepy-1256633542.cos.ap-beijing.myqcloud.com/20181222102937.png">
<meta property="og:image" content="https://sleepy-1256633542.cos.ap-beijing.myqcloud.com/20181222102957.png">
<meta property="og:image" content="https://sleepy-1256633542.cos.ap-beijing.myqcloud.com/20181222103019.png">
<meta property="og:image" content="https://sleepy-1256633542.cos.ap-beijing.myqcloud.com/20181222103040.png">
<meta property="og:image" content="https://sleepy-1256633542.cos.ap-beijing.myqcloud.com/20181222103102.png">
<meta property="article:published_time" content="2023-01-22T03:54:02.008Z">
<meta property="article:modified_time" content="2022-12-29T10:29:19.779Z">
<meta property="article:author" content="hufei">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://sleepy-1256633542.cos.ap-beijing.myqcloud.com/20181222103157.png">


<link rel="icon" href="/img/avatar.jpg">

<link href="/css/style.css?v=1.1.0" rel="stylesheet">

<link href="/css/hl_theme/atom-light.css?v=1.1.0" rel="stylesheet">

<link href="//cdn.jsdelivr.net/npm/animate.css@4.1.0/animate.min.css" rel="stylesheet">

<script src="//cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js"></script>
<script src="/js/titleTip.js?v=1.1.0" ></script>

<script src="//cdn.jsdelivr.net/npm/highlightjs@9.16.2/highlight.pack.min.js"></script>
<script>
    hljs.initHighlightingOnLoad();
</script>

<script src="//cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js"></script>



<script src="//cdn.jsdelivr.net/npm/jquery.cookie@1.4.1/jquery.cookie.min.js" ></script>

<script src="/js/iconfont.js?v=1.1.0" ></script>

<meta name="generator" content="Hexo 6.3.0"></head>
<div style="display: none">
  <input class="theme_disqus_on" value="false">
  <input class="theme_preload_comment" value="">
  <input class="theme_blog_path" value="">
  <input id="theme_shortcut" value="true" />
  <input id="theme_highlight_on" value="true" />
  <input id="theme_code_copy" value="true" />
</div>



<body>
<aside class="nav">
    <div class="nav-left">
        <a href="/"
   class="avatar_target">
    <img class="avatar"
         src="/img/avatar.jpg"/>
</a>
<div class="author">
    <span>hufei</span>
</div>

<div class="icon">
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
</div>




<ul>
    <li>
        <div class="all active" data-rel="全部文章">全部文章
            
                <small>(40)</small>
            
        </div>
    </li>
    
</ul>
<div class="left-bottom">
    <div class="menus">
        
            
            
    </div>
    <div>
        
        
    </div>
</div>
<input type="hidden" id="yelog_site_posts_number" value="40">

<div style="display: none">
    <span id="busuanzi_value_site_uv"></span>
    <span id="busuanzi_value_site_pv"></span>
</div>

    </div>
    <div class="nav-right">
        <div class="friends-area">
    <div class="friends-title">
        友情链接
        <i class="iconfont icon-left"></i>
    </div>
    <div class="friends-content">
        <ul>
            
        </ul>
    </div>
</div>
        <div class="title-list">
    <div class="right-top">
        <div id="default-panel">
            <i class="iconfont icon-search" data-title="搜索 快捷键 i"></i>
            <div class="right-title">全部文章</div>
            <i class="iconfont icon-file-tree" data-title="切换到大纲视图 快捷键 w"></i>
        </div>
        <div id="search-panel">
            <i class="iconfont icon-left" data-title="返回"></i>
            <input id="local-search-input" autocomplete="off"/>
            <label class="border-line" for="input"></label>
            <i class="iconfont icon-case-sensitive" data-title="大小写敏感"></i>
            <i class="iconfont icon-tag" data-title="标签"></i>
        </div>
        <div id="outline-panel" style="display: none">
            <div class="right-title">大纲</div>
            <i class="iconfont icon-list" data-title="切换到文章列表"></i>
        </div>
    </div>

    <div class="tags-list">
    <input id="tag-search" />
    <div class="tag-wrapper">
        
    </div>

</div>

    
    <div id="local-search-result">

    </div>
    
    <nav id="title-list-nav">
        
        
        <a  class="全部文章 "
           href="/2023/01/22/%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B/"
           data-tag=""
           data-author="" >
            <span class="post-title" title=""></span>
            <span class="post-date" title="2023-01-22 11:54:02">2023/01/22</span>
        </a>
        
        
        <a  class="全部文章 "
           href="/2023/01/22/%E7%BD%91%E7%BB%9Cio%E6%A8%A1%E5%9E%8B/"
           data-tag=""
           data-author="" >
            <span class="post-title" title=""></span>
            <span class="post-date" title="2023-01-22 11:54:02">2023/01/22</span>
        </a>
        
        
        <a  class="全部文章 "
           href="/2023/01/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"
           data-tag=""
           data-author="" >
            <span class="post-title" title=""></span>
            <span class="post-date" title="2023-01-22 11:54:02">2023/01/22</span>
        </a>
        
        
        <a  class="全部文章 "
           href="/2023/01/22/%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E5%AE%9A%E6%97%B6%E5%99%A8/"
           data-tag=""
           data-author="" >
            <span class="post-title" title=""></span>
            <span class="post-date" title="2023-01-22 11:54:02">2023/01/22</span>
        </a>
        
        
        <a  class="全部文章 "
           href="/2023/01/22/%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%E9%9D%9E%E6%B3%95%E8%BE%93%E5%85%A5%E4%BB%A5%E5%8F%8A%E6%9E%84%E9%80%A0%E5%BC%82%E5%B8%B8%E6%83%85%E5%86%B5/"
           data-tag=""
           data-author="" >
            <span class="post-title" title=""></span>
            <span class="post-date" title="2023-01-22 11:54:01">2023/01/22</span>
        </a>
        
        
        <a  class="全部文章 "
           href="/2023/01/22/%E5%86%85%E7%BD%AE%E7%B1%BB%E5%9E%8B%E5%92%8CPOD%E7%B1%BB%E5%9E%8B/"
           data-tag=""
           data-author="" >
            <span class="post-title" title=""></span>
            <span class="post-date" title="2023-01-22 11:54:01">2023/01/22</span>
        </a>
        
        
        <a  class="全部文章 "
           href="/2023/01/22/%E7%B1%BB%E5%9E%8B%E5%AE%89%E5%85%A8/"
           data-tag=""
           data-author="" >
            <span class="post-title" title=""></span>
            <span class="post-date" title="2023-01-22 11:54:01">2023/01/22</span>
        </a>
        
        
        <a  class="全部文章 "
           href="/2023/01/22/%E9%9D%99%E6%80%81%E9%93%BE%E6%8E%A5%E5%92%8C%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5/"
           data-tag=""
           data-author="" >
            <span class="post-title" title=""></span>
            <span class="post-date" title="2023-01-22 11:54:01">2023/01/22</span>
        </a>
        
        
        <a  class="全部文章 "
           href="/2023/01/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"
           data-tag=""
           data-author="" >
            <span class="post-title" title=""></span>
            <span class="post-date" title="2023-01-22 11:54:01">2023/01/22</span>
        </a>
        
        
        <a  class="全部文章 "
           href="/2023/01/22/%E8%B0%B7%E6%AD%8Cc++%E9%A3%8E%E6%A0%BC/"
           data-tag=""
           data-author="" >
            <span class="post-title" title=""></span>
            <span class="post-date" title="2023-01-22 11:54:01">2023/01/22</span>
        </a>
        
        
        <a  class="全部文章 "
           href="/2023/01/22/%E9%98%B2%E5%BE%A1%E5%BC%8F%E7%BC%96%E7%A8%8B%E5%92%8C%E5%A5%91%E7%BA%A6%E5%BC%8F%E7%BC%96%E7%A8%8B%EF%BC%8C%E6%96%AD%E8%A8%80%E5%92%8C%E5%BC%82%E5%B8%B8/"
           data-tag=""
           data-author="" >
            <span class="post-title" title=""></span>
            <span class="post-date" title="2023-01-22 11:54:01">2023/01/22</span>
        </a>
        
        
        <a  class="全部文章 "
           href="/2023/01/22/%E5%A4%9A%E7%BB%B4%E6%95%B0%E7%BB%84/"
           data-tag=""
           data-author="" >
            <span class="post-title" title=""></span>
            <span class="post-date" title="2023-01-22 11:54:01">2023/01/22</span>
        </a>
        
        
        <a  class="全部文章 "
           href="/2023/01/22/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB%E7%AC%94%E8%AE%B0%EF%BC%88%E7%B1%BB%E4%BC%BCcsapp%E7%9A%84%E4%B9%A6%EF%BC%89/"
           data-tag=""
           data-author="" >
            <span class="post-title" title=""></span>
            <span class="post-date" title="2023-01-22 11:54:01">2023/01/22</span>
        </a>
        
        
        <a  class="全部文章 "
           href="/2023/01/22/%E5%B8%B8%E7%94%A8api%E5%92%8C%E5%A4%B4%E6%96%87%E4%BB%B6/"
           data-tag=""
           data-author="" >
            <span class="post-title" title=""></span>
            <span class="post-date" title="2023-01-22 11:54:01">2023/01/22</span>
        </a>
        
        
        <a  class="全部文章 "
           href="/2023/01/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"
           data-tag=""
           data-author="" >
            <span class="post-title" title=""></span>
            <span class="post-date" title="2023-01-22 11:54:01">2023/01/22</span>
        </a>
        
        
        <a  class="全部文章 "
           href="/2023/01/22/%E7%BC%96%E8%AF%91%E6%9C%9F%E5%B8%B8%E9%87%8F%E5%92%8Cconstexpr/"
           data-tag=""
           data-author="" >
            <span class="post-title" title=""></span>
            <span class="post-date" title="2023-01-22 11:54:01">2023/01/22</span>
        </a>
        
        
        <a  class="全部文章 "
           href="/2023/01/22/vscode%20c++%E8%BF%90%E8%A1%8C%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"
           data-tag=""
           data-author="" >
            <span class="post-title" title=""></span>
            <span class="post-date" title="2023-01-22 11:54:01">2023/01/22</span>
        </a>
        
        
        <a  class="全部文章 "
           href="/2023/01/22/stdref/"
           data-tag=""
           data-author="" >
            <span class="post-title" title=""></span>
            <span class="post-date" title="2023-01-22 11:54:01">2023/01/22</span>
        </a>
        
        
        <a  class="全部文章 "
           href="/2023/01/22/stdaccumulate%E5%92%8Cstdtransform/"
           data-tag=""
           data-author="" >
            <span class="post-title" title=""></span>
            <span class="post-date" title="2023-01-22 11:54:01">2023/01/22</span>
        </a>
        
        
        <a  class="全部文章 "
           href="/2023/01/22/socket%20api/"
           data-tag=""
           data-author="" >
            <span class="post-title" title=""></span>
            <span class="post-date" title="2023-01-22 11:54:01">2023/01/22</span>
        </a>
        
        
        <a  class="全部文章 "
           href="/2023/01/22/mysql/"
           data-tag=""
           data-author="" >
            <span class="post-title" title=""></span>
            <span class="post-date" title="2023-01-22 11:54:01">2023/01/22</span>
        </a>
        
        
        <a  class="全部文章 "
           href="/2023/01/22/muduo%E7%BD%91%E7%BB%9C%E6%BA%90%E7%A0%81/"
           data-tag=""
           data-author="" >
            <span class="post-title" title=""></span>
            <span class="post-date" title="2023-01-22 11:54:01">2023/01/22</span>
        </a>
        
        
        <a  class="全部文章 "
           href="/2023/01/22/muduo%E6%97%A5%E5%BF%97/"
           data-tag=""
           data-author="" >
            <span class="post-title" title=""></span>
            <span class="post-date" title="2023-01-22 11:54:01">2023/01/22</span>
        </a>
        
        
        <a  class="全部文章 "
           href="/2023/01/22/Linux%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%9C%8D%E5%8A%A1%E7%AB%AF%E7%BC%96%E7%A8%8B%EF%BC%9A%E4%BD%BF%E7%94%A8muduo%20C++%E7%BD%91%E7%BB%9C%E5%BA%93/"
           data-tag=""
           data-author="" >
            <span class="post-title" title=""></span>
            <span class="post-date" title="2023-01-22 11:54:01">2023/01/22</span>
        </a>
        
        
        <a  class="全部文章 "
           href="/2023/01/22/linux/"
           data-tag=""
           data-author="" >
            <span class="post-title" title=""></span>
            <span class="post-date" title="2023-01-22 11:54:01">2023/01/22</span>
        </a>
        
        
        <a  class="全部文章 "
           href="/2023/01/22/IO%E5%AF%86%E9%9B%86%E5%9E%8B%E4%BB%BB%E5%8A%A1%E5%92%8C%E8%AE%A1%E7%AE%97%E5%AF%86%E9%9B%86%E5%9E%8B%E4%BB%BB%E5%8A%A1/"
           data-tag=""
           data-author="" >
            <span class="post-title" title=""></span>
            <span class="post-date" title="2023-01-22 11:54:01">2023/01/22</span>
        </a>
        
        
        <a  class="全部文章 "
           href="/2023/01/22/io%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E5%8E%9F%E7%90%86/"
           data-tag=""
           data-author="" >
            <span class="post-title" title=""></span>
            <span class="post-date" title="2023-01-22 11:54:01">2023/01/22</span>
        </a>
        
        
        <a  class="全部文章 "
           href="/2023/01/22/csapp/"
           data-tag=""
           data-author="" >
            <span class="post-title" title=""></span>
            <span class="post-date" title="2023-01-22 11:54:01">2023/01/22</span>
        </a>
        
        
        <a  class="全部文章 "
           href="/2023/01/22/CMake%20%E6%A8%A1%E5%9D%97%E5%8C%96%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/"
           data-tag=""
           data-author="" >
            <span class="post-title" title=""></span>
            <span class="post-date" title="2023-01-22 11:54:01">2023/01/22</span>
        </a>
        
        
        <a  class="全部文章 "
           href="/2023/01/22/c++%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/"
           data-tag=""
           data-author="" >
            <span class="post-title" title=""></span>
            <span class="post-date" title="2023-01-22 11:54:01">2023/01/22</span>
        </a>
        
        
        <a  class="全部文章 "
           href="/2023/01/22/c++%E7%B1%BB%E7%9A%84%E9%BB%98%E8%AE%A4%E5%87%BD%E6%95%B0/"
           data-tag=""
           data-author="" >
            <span class="post-title" title=""></span>
            <span class="post-date" title="2023-01-22 11:54:01">2023/01/22</span>
        </a>
        
        
        <a  class="全部文章 "
           href="/2023/01/22/%E8%87%AA%E5%8A%A8%E9%A9%BE%E9%A9%B6/"
           data-tag=""
           data-author="" >
            <span class="post-title" title=""></span>
            <span class="post-date" title="2023-01-22 11:54:01">2023/01/22</span>
        </a>
        
        
        <a  class="全部文章 "
           href="/2023/01/22/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E6%80%A7/"
           data-tag=""
           data-author="" >
            <span class="post-title" title=""></span>
            <span class="post-date" title="2023-01-22 11:54:01">2023/01/22</span>
        </a>
        
        
        <a  class="全部文章 "
           href="/2023/01/22/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/"
           data-tag=""
           data-author="" >
            <span class="post-title" title=""></span>
            <span class="post-date" title="2023-01-22 11:54:01">2023/01/22</span>
        </a>
        
        
        <a  class="全部文章 "
           href="/2023/01/22/%E5%BC%82%E5%B8%B8/"
           data-tag=""
           data-author="" >
            <span class="post-title" title=""></span>
            <span class="post-date" title="2023-01-22 11:54:01">2023/01/22</span>
        </a>
        
        
        <a  class="全部文章 "
           href="/2023/01/22/%E7%BA%BF%E7%A8%8B%E6%B1%A0/"
           data-tag=""
           data-author="" >
            <span class="post-title" title=""></span>
            <span class="post-date" title="2023-01-22 11:54:01">2023/01/22</span>
        </a>
        
        
        <a  class="全部文章 "
           href="/2023/01/22/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%98%9F%E5%88%97/"
           data-tag=""
           data-author="" >
            <span class="post-title" title=""></span>
            <span class="post-date" title="2023-01-22 11:54:01">2023/01/22</span>
        </a>
        
        
        <a  class="全部文章 "
           href="/2023/01/22/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/"
           data-tag=""
           data-author="" >
            <span class="post-title" title=""></span>
            <span class="post-date" title="2023-01-22 11:54:01">2023/01/22</span>
        </a>
        
        
        <a  class="全部文章 "
           href="/2023/01/22/%E7%8E%B0%E4%BB%A3CMake/"
           data-tag=""
           data-author="" >
            <span class="post-title" title=""></span>
            <span class="post-date" title="2023-01-22 11:54:01">2023/01/22</span>
        </a>
        
        
        <a  class="全部文章 "
           href="/2023/01/21/hello-world/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Hello World">Hello World</span>
            <span class="post-date" title="2023-01-21 23:44:22">2023/01/21</span>
        </a>
        
        <div id="no-item-tips">

        </div>
    </nav>
    <div id="outline-list">
    </div>
</div>

    </div>
    <div class="hide-list">
        <div class="semicircle" data-title="切换全屏 快捷键 s">
            <div class="brackets first"><</div>
            <div class="brackets">&gt;</div>
        </div>
    </div>
</aside>
<div id="post">
    <div class="pjax">
        <article id="post-muduo网络源码" class="article article-type-post" itemscope itemprop="blogPost">
    
    <div class="article-meta">
        
        
        
        
    </div>
    <div class="article-meta">
        
            发布时间 : <time class="date" title='最后更新: 2022-12-31 23:58:03'>2023-01-22 11:54</time>
        
    </div>
    <div class="article-meta">
        
        
        <span id="busuanzi_container_page_pv">
            阅读 :<span id="busuanzi_value_page_pv">
                <span class="count-comment">
                    <span class="spinner">
                      <div class="cube1"></div>
                      <div class="cube2"></div>
                    </span>
                </span>
            </span>
        </span>
        
        
    </div>
    
    <div class="toc-ref">
    
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#muduo%E7%BD%91%E7%BB%9C%E6%BA%90%E7%A0%81"><span class="toc-text">muduo网络源码</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%84%E4%B8%AA%E7%B1%BB%E8%AF%A6%E8%A7%A3"><span class="toc-text">各个类详解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#channel"><span class="toc-text">channel</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#poller"><span class="toc-text">poller</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#acceptor"><span class="toc-text">acceptor</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#tcp-server%E5%92%8Ctcp-connection"><span class="toc-text">tcp server和tcp connection</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#timer"><span class="toc-text">timer</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#EventLoop"><span class="toc-text">EventLoop</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E4%BE%8B%E5%AD%90"><span class="toc-text">一个简单的例子</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9E%E6%8E%A5%E7%9A%84%E5%BB%BA%E7%AB%8B"><span class="toc-text">连接的建立</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E7%9A%84%E8%AF%BB%E5%8F%96"><span class="toc-text">消息的读取</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E7%9A%84%E5%8F%91%E9%80%81"><span class="toc-text">消息的发送</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9E%E6%8E%A5%E7%9A%84%E6%96%AD%E5%BC%80"><span class="toc-text">连接的断开</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#runInLoop-%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-text">runInLoop 的实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%94%A4%E9%86%92-EventLoop"><span class="toc-text">为什么要唤醒 EventLoop</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#wakeup-%E6%98%AF%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E7%9A%84"><span class="toc-text">wakeup 是怎么实现的</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#doPendingFunctors-%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-text">doPendingFunctors 的实现</span></a></li></ol></li></ol></li></ol>
    
<style>
    .left-col .switch-btn,
    .left-col .switch-area {
        display: none;
    }
    .toc-level-3 i,
    .toc-level-3 ol {
        display: none !important;
    }
</style>
</div>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="muduo网络源码"><a href="#muduo网络源码" class="headerlink" title="muduo网络源码"></a>muduo网络源码</h1><p>学到的东西：tie延长生命周期；vector的首指针可以直接代替数组首指针；</p>
<h2 id="各个类详解"><a href="#各个类详解" class="headerlink" title="各个类详解"></a>各个类详解</h2><h3 id="channel"><a href="#channel" class="headerlink" title="channel"></a>channel</h3><p>Channel类封装了poll&#x2F;epoll中的 <code>I/O</code> 事件(epoll_event)和事件对应的回调函数，不拥有 <code>fd</code>，可以代表多种实体：<code>listening fd</code>、<code>timer fd</code>、<code>event fd</code> 等。</p>
<p>每个Channel对象自始至终只属于一个EventLoop，因此每个Channel对象都只属于某一个IO线程。</p>
<p>每个Channel对象自始至终只负责一个文件描述符（fd）的IO事件分发，但它并不拥有这个fd，也不会在析构的时候关闭这个fd。</p>
<p>Muduo用户一般不直接使用Channel，而会使用更上层的封装，如TcpConnection。</p>
<pre><code class="c++">class Channel : noncopyable
&#123;
 public:
  typedef std::function&lt;void()&gt; EventCallback;
  typedef std::function&lt;void(Timestamp)&gt; ReadEventCallback;

  Channel(EventLoop* loop, int fd);
  ~Channel();

  void handleEvent(Timestamp receiveTime);

 private:
  static const int kNoneEvent;
  static const int kReadEvent;
  static const int kWriteEvent;

  EventLoop* loop_;
  const int  fd_;
  int        events_;
  int        revents_; // it&#39;s the received event types of epoll or poll
  int        index_; // used by Poller.

  ReadEventCallback readCallback_;
  EventCallback writeCallback_;
  EventCallback closeCallback_;
  EventCallback errorCallback_;
&#125;;
</code></pre>
<p><code>events_</code> 是 <code>Channel</code> 关心的事件，<code>Poller</code> 根据这个来设置。<code>revents_</code> 是 <code>Poller</code> 返回的已就绪的事件，<code>handleEvent()</code> 会调用相应的 <code>callback</code> 来处理。</p>
<p>所有需要由 <code>EventLoop</code> 处理的如 <code>Acceptor</code>、<code>TcpConnection</code> 都有 <code>Channel</code> 成员并设置 <code>callback</code> 注册到 <code>EventLoop</code> 中。<code>Muduo</code> 的 <code>callback</code> 基本都是 <code>member function</code>， 用 <code>std::bind()</code> 绑定 <code>this</code> 指针来注册，一些网络库会采用继承接口类来实现回调的注册。</p>
<p><strong>源码分析</strong></p>
<p>Channel.h源码</p>
<pre><code class="c++">#ifndef MUDUO_NET_CHANNEL_H
#define MUDUO_NET_CHANNEL_H

#include &lt;boost/function.hpp&gt;
#include &lt;boost/noncopyable.hpp&gt;
#include &lt;boost/shared_ptr.hpp&gt;
#include &lt;boost/weak_ptr.hpp&gt;

#include &lt;muduo/base/Timestamp.h&gt;
/*个人理解：channel是一个具体来处理事件的类，它与eventloop关系紧密，主要是根据事件宏定义来调用对应的回调函数
 *主要的事件有三种，读事件，写事件和结束事件
 **/
namespace muduo &#123;
    namespace net &#123;

        class EventLoop;

///
/// A selectable I/O channel.
///
/// This class doesn&#39;t own the file descriptor.
/// The file descriptor could be a socket,
/// an eventfd, a timerfd, or a signalfd
        class Channel : boost::noncopyable &#123;
        public:
            typedef boost::function&lt;void()&gt; EventCallback;
            typedef boost::function&lt;void(Timestamp)&gt; ReadEventCallback;//读事件的回调函数中必须有参数Timestamp

            Channel(EventLoop *loop, int fd);//一个channel要绑定一个EventLoop和一个文件描述符，但channel无权操作fd
            ~Channel();

            void handleEvent(Timestamp receiveTime);//处理事件
            
            //设置四种事件的回调函数
            void setReadCallback(const ReadEventCallback &amp;cb) &#123; readCallback_ = cb; &#125;
            void setWriteCallback(const EventCallback &amp;cb) &#123; writeCallback_ = cb; &#125;
            void setCloseCallback(const EventCallback &amp;cb) &#123; closeCallback_ = cb; &#125;
            void setErrorCallback(const EventCallback &amp;cb) &#123; errorCallback_ = cb; &#125;

            /// Tie this channel to the owner object managed by shared_ptr,
            /// prevent the owner object being destroyed in handleEvent.
            //这个函数，用于延长某些对象的生命期，使其寿命长过Channel::handleEvent()函数。
            void tie(const boost::shared_ptr&lt;void&gt; &amp;);//将一个shared_ptr指针的值赋给tie_

            int fd() const &#123; return fd_; &#125;

            int events() const &#123; return events_; &#125;

            void set_revents(int revt) &#123; revents_ = revt; &#125; // used by pollers
            // int revents() const &#123; return revents_; &#125;
            bool isNoneEvent() const &#123; return events_ == kNoneEvent; &#125;//判断事件是否为0，也就是没有关注的事件

            void enableReading() &#123;
                events_ |= kReadEvent;
                update();
            &#125;//设置读事件，并将当前channel加入到poll队列当中
            // void disableReading() &#123; events_ &amp;= ~kReadEvent; update(); &#125;
            void enableWriting() &#123;
                events_ |= kWriteEvent;
                update();
            &#125;//设置写事件，并将当前channel加入到poll队列当中
            void disableWriting() &#123;
                events_ &amp;= ~kWriteEvent;
                update();
            &#125;//关闭写事件，并将当前channel加入到poll队列当中
            void disableAll() &#123;
                events_ = kNoneEvent;
                update();
            &#125;//关闭所有事件，并暂时删除当前channel
            bool isWriting() const &#123; return events_ &amp; kWriteEvent; &#125;//是否关注写事件

            // for Poller
            int index() &#123; return index_; &#125;//返回序号
            void set_index(int idx) &#123; index_ = idx; &#125;//设置序号

            // for debug
            string reventsToString() const;

            void doNotLogHup() &#123; logHup_ = false; &#125;//把挂起标志位置false

            EventLoop *ownerLoop() &#123; return loop_; &#125;

            void remove();

        private:
            void update();

            void handleEventWithGuard(Timestamp receiveTime);

            static const int kNoneEvent;
            static const int kReadEvent;
            static const int kWriteEvent;

            EventLoop *loop_;            // 所属EventLoop
            const int fd_;            // 文件描述符，但不负责关闭该文件描述符
            int events_;        // 需要epoll关注的事件
            int revents_;        // poll/epoll wait返回的需要处理的事件
            int index_;        // used by Poller.表示在epoll队列中的状态：1.正在队列中2.曾经在队列中3.从来没在队列中
            bool logHup_;        // for POLLHUP是否被挂起

            boost::weak_ptr&lt;void&gt; tie_;//保证channel所在的类
            bool tied_;
            bool eventHandling_;        // 是否处于处理事件中
            ReadEventCallback readCallback_;//当文件描述符产生读事件时，最后调用的读函数
            EventCallback writeCallback_;//当文件描述符产生写事件时，最后调用的写函数
            EventCallback closeCallback_;//当文件描述符产生关闭事件时，最后调用的关闭函数
            EventCallback errorCallback_;//当文件描述符产生错误事件时，最后调用的错误函数
        &#125;;

    &#125;
&#125;
#endif  // MUDUO_NET_CHANNEL_H
</code></pre>
<p>Channel.cc源码</p>
<pre><code class="c++">#include &lt;muduo/base/Logging.h&gt;
#include &lt;muduo/net/Channel.h&gt;
#include &lt;muduo/net/EventLoop.h&gt;

#include &lt;sstream&gt;

#include &lt;poll.h&gt;

using namespace muduo;
using namespace muduo::net;

const int Channel::kNoneEvent = 0;
const int Channel::kReadEvent = POLLIN | POLLPRI;
const int Channel::kWriteEvent = POLLOUT;

Channel::Channel(EventLoop *loop, int fd__)
        : loop_(loop),
          fd_(fd__),
          events_(0),
          revents_(0),
          index_(-1),//就是kNew
          logHup_(true),
          tied_(false),
          eventHandling_(false) &#123;
&#125;

Channel::~Channel() &#123;
    assert(!eventHandling_);
&#125;

void Channel::tie(const boost::shared_ptr&lt;void&gt; &amp;obj)//给tie_指针赋值，tie_指针是一个weak_ptr指针
&#123;
    tie_ = obj;
    tied_ = true;
&#125;

void Channel::update()//把当前的channel加入到poll队列当中
&#123;
    loop_-&gt;updateChannel(this);
&#125;

// 调用这个函数之前确保调用disableAll
// 从EventLoop中移除这个channel
void Channel::remove() &#123;
    assert(isNoneEvent());
    loop_-&gt;removeChannel(this);
&#125;

void Channel::handleEvent(Timestamp receiveTime)//Timestamp主要用于读事件的回调函数
&#123;
    //guard是一个shared_ptr，这样guard指向的对象在智能指针析构前就不会析构了，延长了生命周期
    boost::shared_ptr&lt;void&gt; guard;
    if (tied_) &#123;
        guard = tie_.lock();//提升tie_为shared_ptr，如果提升成功，说明指向一个存在的对象
        if (guard) &#123;
            LOG_TRACE &lt;&lt; &quot;[6] usecount=&quot; &lt;&lt; guard.use_count();
            handleEventWithGuard(receiveTime);
            LOG_TRACE &lt;&lt; &quot;[12] usecount=&quot; &lt;&lt; guard.use_count();
        &#125;
    &#125; else &#123;
        handleEventWithGuard(receiveTime);
    &#125;
&#125;

void Channel::handleEventWithGuard(Timestamp receiveTime)
//查看epoll/poll返回的具体是什么事件，并根据事件的类型进行相应的处理
&#123;
    eventHandling_ = true;
    /*
    if (revents_ &amp; POLLHUP)
    &#123;
        LOG_TRACE &lt;&lt; &quot;1111111111111111&quot;;
    &#125;
    if (revents_ &amp; POLLIN)
    &#123;
        LOG_TRACE &lt;&lt; &quot;2222222222222222&quot;;
    &#125;
    */
    if ((revents_ &amp; POLLHUP) &amp;&amp; !(revents_ &amp; POLLIN))//当事件为挂起并没有可读事件时
    &#123;
        if (logHup_) &#123;
            LOG_WARN &lt;&lt; &quot;Channel::handle_event() POLLHUP&quot;;
        &#125;
        if (closeCallback_) closeCallback_();
    &#125;

    if (revents_ &amp; POLLNVAL)//描述字不是一个打开的文件描述符
    &#123;
        LOG_WARN &lt;&lt; &quot;Channel::handle_event() POLLNVAL&quot;;
    &#125;

    if (revents_ &amp; (POLLERR | POLLNVAL))//发生错误或者描述符不可打开
    &#123;
        if (errorCallback_) errorCallback_();
    &#125;
    if (revents_ &amp; (POLLIN | POLLPRI | POLLRDHUP))//关于读的事件
    &#123;
        if (readCallback_) readCallback_(receiveTime);
    &#125;
    if (revents_ &amp; POLLOUT)//关于写的事件
    &#123;
        if (writeCallback_) writeCallback_();
    &#125;
    eventHandling_ = false;
&#125;

string Channel::reventsToString() const//把事件转成一个string，用于日志打印debug
&#123;
    std::ostringstream oss;
    oss &lt;&lt; fd_ &lt;&lt; &quot;: &quot;;
    if (revents_ &amp; POLLIN)
        oss &lt;&lt; &quot;IN &quot;;
    if (revents_ &amp; POLLPRI)
        oss &lt;&lt; &quot;PRI &quot;;
    if (revents_ &amp; POLLOUT)
        oss &lt;&lt; &quot;OUT &quot;;
    if (revents_ &amp; POLLHUP)
        oss &lt;&lt; &quot;HUP &quot;;
    if (revents_ &amp; POLLRDHUP)
        oss &lt;&lt; &quot;RDHUP &quot;;
    if (revents_ &amp; POLLERR)
        oss &lt;&lt; &quot;ERR &quot;;
    if (revents_ &amp; POLLNVAL)
        oss &lt;&lt; &quot;NVAL &quot;;

    return oss.str().c_str();
&#125;
</code></pre>
<p><strong>Channel::tie()详解</strong></p>
<p>这里是一个智能指针使用的特定场景之一，用于特定时刻延长对象的生命周期。我们知道持有对象的shared_ptr可以延长对象的生命周期，但是如果我们只想在特定时刻延长对象的生命周期怎么办(比如执行对象的成员函数时)。解决方法就是持有对象的weak_ptr，并在函数内升级为shared_ptr。</p>
<pre><code class="c++">//给tie_指针赋值，tie_指针是一个weak_ptr指针
void Channel::tie(const boost::shared_ptr&lt;void&gt; &amp;obj)
&#123;
    tie_ = obj;
    tied_ = true;
&#125;

void Channel::handleEvent(Timestamp receiveTime)//Timestamp主要用于读事件的回调函数
&#123;
    //guard是一个shared_ptr，这样guard指向的对象在handleEventWithGuard()函数执行期间就不会析构了，延长了生命周期
    boost::shared_ptr&lt;void&gt; guard;
    if (tied_) &#123;
        guard = tie_.lock();//提升tie_为shared_ptr，如果提升成功，说明指向一个存在的对象
        if (guard) &#123;
            LOG_TRACE &lt;&lt; &quot;[6] usecount=&quot; &lt;&lt; guard.use_count();
            handleEventWithGuard(receiveTime);
            LOG_TRACE &lt;&lt; &quot;[12] usecount=&quot; &lt;&lt; guard.use_count();
        &#125;
    &#125; else &#123;
        handleEventWithGuard(receiveTime);
    &#125;
&#125;
</code></pre>
<p>结合例子分析，看下面的一个调用时序图</p>
<p><img src="https://raw.githubusercontent.com/hufei96/Image/main/muduo_tie.png" alt="img"></p>
<p>当对方断开TCP连接，这个IO事件会触发Channel::handleEvent()调用，后者会调用用户提供的CloseCallback，而用户代码在onClose()中有可能析构Channel对象，这就造成了灾难。等于说Channel::handleEvent()执行到一半的时候，其所属的Channel对象本身被销毁了。这时程序无疑会出错或崩溃。</p>
<p>Muduo的解决办法是提供Channel::tie(const boost::shared_ptr<void>&amp;)这个函数，用于延长某些对象（可以是Channel对象，也可以是其owner对象）的生命周期，使之长过Channel::handleEvent()函数。</p>
<p>Muduo TcpConnection采用shared_ptr管理对象生命期的原因之一就是因为这个。</p>
<p>当有关闭事件时，调用流程如下：</p>
<p>Channel::handleEvent -&gt; TcpConnection::handleClose -&gt;TcpClient::removeConnection -&gt;TcpConnection::connectDestroyed-&gt;channel_-&gt;remove()。</p>
<p>1、为了在Channel::handleEvent处理期间，防止因其owner对象被修改，进而导致Channel被析构，最后出现不可预估错误。 Channel::tie()的作用就是将Channel的owner对象进行绑定保护起来。</p>
<p> 2、另外channel-&gt;remove的作用是删除channel在Poll中的地址拷贝，而不是销毁channel。channel的销毁由其owner对象决定。</p>
<h3 id="poller"><a href="#poller" class="headerlink" title="poller"></a>poller</h3><p>Poller class 是IO multiplexing的封装。在muduo中它是一个抽象类，因为muduo同时支持poll和epoll两种IO multiplexing机制。</p>
<p>Poller是EventLoop的间接成员，只供其owner EventLoop在IO线程中调用，因此无需加锁。其生命周期和EvenLoop相等。Poller并不拥有Channel，Channel在析构前必须自己unregister（EventLoop::removeChannel()）,避免悬空指针。</p>
<p><strong>Poller.h</strong></p>
<p>Poller.h只是一个简单的抽象类</p>
<pre><code class="c++">#ifndef MUDUO_NET_POLLER_H
#define MUDUO_NET_POLLER_H

#include &lt;vector&gt;
#include &lt;boost/noncopyable.hpp&gt;

#include &lt;muduo/base/Timestamp.h&gt;
#include &lt;muduo/net/EventLoop.h&gt;

namespace muduo &#123;
    namespace net &#123;

        class Channel;

///
/// Base class for IO Multiplexing
///
/// This class doesn&#39;t own the Channel objects.
        // 这个Poller类只是一个抽象类主要实现在EpollPoller/PollPoller中
        class Poller : boost::noncopyable &#123;
        public:
            typedef std::vector&lt;Channel *&gt; ChannelList;

            Poller(EventLoop *loop);

            virtual ~Poller();

            /// Polls the I/O events.
            /// Must be called in the loop thread.
            virtual Timestamp poll(int timeoutMs, ChannelList *activeChannels) = 0; // poll函数

            /// Changes the interested I/O events.
            /// Must be called in the loop thread.
            virtual void updateChannel(Channel *channel) = 0;// 更新Channel

            /// Remove the channel, when it destructs.
            /// Must be called in the loop thread.
            virtual void removeChannel(Channel *channel) = 0;    // 移除Channel

            static Poller *newDefaultPoller(EventLoop *loop);// 在这里会根据环境变量生成epoll或者poll

            void assertInLoopThread() &#123;// 确保所有的操作都在eventloop的线程中
                ownerLoop_-&gt;assertInLoopThread();
            &#125;

        private:
            EventLoop *ownerLoop_;    // Poller所属EventLoop
        &#125;;

    &#125;
&#125;
#endif  // MUDUO_NET_POLLER_H
</code></pre>
<p><strong>EPollPoller.h</strong></p>
<p>这个类主要利用epoll函数，封装了epoll三个函数，</p>
<p>其中epoll_event.data是一个指向channel类的指针，这里可以等价理解为channel就是epoll_event，用于在epoll队列中注册，删除，更改的结构体。因为文件描述符fd，Channel，以及epoll_event结构体（只有需要添加到epoll上时才有epoll_event结构体）三个都是一一对应的关系Channel.fd应该等于fd，epoll_event.data应该等于&amp;Channel。如果不添加到epoll队列中，Channel和fd一一对应，就没有epoll_event结构体了</p>
<p>从epoll队列中删除有两种删除方法，</p>
<p>第一种暂时删除，就是从epoll队列中删除，并且把标志位置为kDeleted，但是并不从ChannelMap channels_中删除</p>
<p>第二种是完全删除，从epoll队列中删除，并且从ChannelMap channels_中也删除，最后把标志位置kNew。</p>
<p>可以理解为ChannelMap channels_的作用就是：暂时不需要的，就从epoll队列中删除，但是在channels_中保留信息，类似与挂起，这样下次再使用这个channel时，只需要添加到epoll队列中即可。而完全删除，就把channels_中也删除。</p>
<p>下面的源码有详细的注释</p>
<pre><code class="c++">#ifndef MUDUO_NET_POLLER_EPOLLPOLLER_H
#define MUDUO_NET_POLLER_EPOLLPOLLER_H

#include &lt;muduo/net/Poller.h&gt;

#include &lt;map&gt;
#include &lt;vector&gt;

struct epoll_event;

namespace muduo &#123;
    namespace net &#123;

///
/// IO Multiplexing with epoll(4).
///
        class EPollPoller : public Poller &#123;
        public:
            EPollPoller(EventLoop *loop);

            virtual ~EPollPoller();

            virtual Timestamp poll(int timeoutMs, ChannelList *activeChannels);

            virtual void updateChannel(Channel *channel);

            virtual void removeChannel(Channel *channel);

        private:
            static const int kInitEventListSize = 16; //默认事件数组大小，是用来装epoll_wait()返回的可读或可写事件的

            void fillActiveChannels(int numEvents, ChannelList *activeChannels) const;

            void update(int operation, Channel *channel);

            typedef std::vector&lt;struct epoll_event&gt; EventList;
            typedef std::map&lt;int, Channel *&gt; ChannelMap;

            int epollfd_;//epoll监视的文件描述符
            EventList events_;//用来存储活跃文件描述符的epoll_event结构体数组
            ChannelMap channels_;//记录标志符是kAdded或者kDeleted的channel和fd
        &#125;;

    &#125;
&#125;
#endif  // MUDUO_NET_POLLER_EPOLLPOLLER_H
</code></pre>
<p><strong>EPollPoller.cc</strong></p>
<p>主要是一些EPollPoller类的具体实现，注释很详细。</p>
<pre><code class="c++">#include &lt;muduo/net/poller/EPollPoller.h&gt;

#include &lt;muduo/base/Logging.h&gt;
#include &lt;muduo/net/Channel.h&gt;

#include &lt;boost/static_assert.hpp&gt;

#include &lt;assert.h&gt;
#include &lt;errno.h&gt;
#include &lt;poll.h&gt;
#include &lt;sys/epoll.h&gt;

using namespace muduo;
using namespace muduo::net;

// On Linux, the constants of poll(2) and epoll(4)
// are expected to be the same.
BOOST_STATIC_ASSERT(EPOLLIN
== POLLIN);
BOOST_STATIC_ASSERT(EPOLLPRI
== POLLPRI);
BOOST_STATIC_ASSERT(EPOLLOUT
== POLLOUT);
BOOST_STATIC_ASSERT(EPOLLRDHUP
== POLLRDHUP);
BOOST_STATIC_ASSERT(EPOLLERR
== POLLERR);
BOOST_STATIC_ASSERT(EPOLLHUP
== POLLHUP);

namespace &#123;
    const int kNew = -1;//代表不在epoll队列中，也不在ChannelMap channels_中
    const int kAdded = 1;//代表正在epoll队列当中
    const int kDeleted = 2;//代表曾经在epoll队列当中过，但是被删除了，现在不在了，但是还是在ChannelMap channels_中的
&#125;

EPollPoller::EPollPoller(EventLoop *loop)
        : Poller(loop),//所属的EventLoop
          epollfd_(::epoll_create1(EPOLL_CLOEXEC)),//创建一个epoll文件描述符，用来监听所有注册的事件
          events_(kInitEventListSize) &#123;//初始化vector
    if (epollfd_ &lt; 0) &#123;
        LOG_SYSFATAL &lt;&lt; &quot;EPollPoller::EPollPoller&quot;;
    &#125;
&#125;

EPollPoller::~EPollPoller()//关闭epoll文件描述符
&#123;
    ::close(epollfd_);
&#125;

Timestamp EPollPoller::poll(int timeoutMs, ChannelList *activeChannels)//封装epoll_wait
&#123;
    int numEvents = ::epoll_wait(epollfd_,
                                 &amp;*events_.begin(),//等价于&amp;events[0],就是传入一个vecotr&lt;struct epoll_event&gt;的首指针进去,用vector首指针代替了数组首指针
                                 static_cast&lt;int&gt;(events_.size()),
                                 timeoutMs);
    Timestamp now(Timestamp::now());
    if (numEvents &gt; 0) &#123;
        LOG_TRACE &lt;&lt; numEvents &lt;&lt; &quot; events happended&quot;;
        fillActiveChannels(numEvents, activeChannels);
        //如果返回的事件数目等于当前事件数组大小，就就扩充events_，分配2倍空间,
        if (implicit_cast&lt;size_t&gt;(numEvents) == events_.size())
        &#123;
            events_.resize(events_.size() * 2);
        &#125;
    &#125; else if (numEvents == 0)//如果timeoutMs设置的是大于0的数，也就是超时时间有效的话，那么过了超时时间并且没有事件发生，就会出现这种情况
    &#123;
        LOG_TRACE &lt;&lt; &quot; nothing happended&quot;;
    &#125; else &#123;
        LOG_SYSERR &lt;&lt; &quot;EPollPoller::poll()&quot;;
    &#125;
    return now;//返回的是事件发生时的时间
&#125;

void EPollPoller::fillActiveChannels(int numEvents,
                                     ChannelList *activeChannels) const //epoll_event转为channel
&#123;
    assert(implicit_cast&lt;size_t&gt;(numEvents) &lt;= events_.size());
    for (int i = 0; i &lt; numEvents; ++i)//将返回的活跃epoll_event转成channel放到activeChannels列表中
    &#123;
        Channel *channel = static_cast&lt;Channel *&gt;(events_[i].data.ptr);//把产生事件的channel变量拿出来
/*
这是epoll模式epoll_event事件的数据结构，其中data不仅可以保存fd，也可以保存一个void*类型的指针。
typedef union epoll_data &#123;
               void    *ptr;
               int      fd;
               uint32_t u32;
               uint64_t u64;
           &#125; epoll_data_t;
           struct epoll_event &#123;
               uint32_t     events;    // Epoll events
               epoll_data_t data;      //User data variable
           &#125;;
*/
#ifndef NDEBUG//在调试时会执行下面的代码，否则就直接忽视
        int fd = channel-&gt;fd();
        ChannelMap::const_iterator it = channels_.find(fd);
        assert(it != channels_.end());
        assert(it-&gt;second == channel);//判断ChannelMap中key和value的对应关系是否准确
#endif
        channel-&gt;set_revents(events_[i].events);//把已经触发的事件写入channel中
        activeChannels-&gt;push_back(channel);//把channel放入要处理的channel列表中
    &#125;
&#125;

void EPollPoller::updateChannel(Channel *channel)//根据channel的序号在epoll队列中来删除，增加channel或者改变channel
&#123;
    Poller::assertInLoopThread();//负责epoll_wait的线程和创建eventloop的线程为同一个
    LOG_TRACE &lt;&lt; &quot;fd = &quot; &lt;&lt; channel-&gt;fd() &lt;&lt; &quot; events = &quot; &lt;&lt; channel-&gt;events();
    const int index = channel-&gt;index();
    if (index == kNew || index == kDeleted)//如果是完全没在或者曾经在epoll队列中的，就添加到epoll队列中
    &#123;
        // a new one, add with EPOLL_CTL_ADD
        int fd = channel-&gt;fd();
        if (index == kNew) &#123;//完全没在epoll队列中
            assert(channels_.find(fd) == channels_.end());//确保这个channel的文件描述符不在channels_中
            channels_[fd] = channel;//将新添加的fd和channel添加到channels_中
        &#125; else // index == kDeleted  曾经在epoll队列中
        &#123;
            assert(channels_.find(fd) != channels_.end());//确保这个channel的文件描述符在channels_中
            assert(channels_[fd] == channel);//确保在epoll队列中channel和fd一致
        &#125;
        channel-&gt;set_index(kAdded);//修改index为已在队列中
        update(EPOLL_CTL_ADD, channel);
    &#125; else//如果是现在就在epoll队列中的，如果没有关注事件了，就暂时删除，如果有关注事件，就修改
    &#123;
        // update existing one with EPOLL_CTL_MOD/DEL
        int fd = channel-&gt;fd();
        (void) fd;
        assert(channels_.find(fd) != channels_.end());//channels_中是否有这个文件描述符
        assert(channels_[fd] == channel);//channels_中channel和fd是否一致
        assert(index == kAdded);//标志位是否正在队列中
        if (channel-&gt;isNoneEvent()) &#123;
            update(EPOLL_CTL_DEL, channel);
            channel-&gt;set_index(kDeleted);
        &#125; else &#123;
            update(EPOLL_CTL_MOD, channel);
        &#125;
    &#125;
&#125;

void EPollPoller::removeChannel(Channel *channel)//完全删除channel
&#123;
    Poller::assertInLoopThread();
    int fd = channel-&gt;fd();
    LOG_TRACE &lt;&lt; &quot;fd = &quot; &lt;&lt; fd;
    assert(channels_.find(fd) != channels_.end());//channels_中是否有这个文件描述符
    assert(channels_[fd] == channel);//channels_中channel和fd是否一致
    assert(channel-&gt;isNoneEvent());//channel中要关注的事件是否为空
    int index = channel-&gt;index();
    assert(index == kAdded || index == kDeleted);//标志位必须是kAdded或者kDeleted
    size_t n = channels_.erase(fd);
    (void) n;
    assert(n == 1);

    if (index == kAdded) &#123;
        update(EPOLL_CTL_DEL, channel);//从epoll队列中删除这个channel
    &#125;
    channel-&gt;set_index(kNew);//设置标志位是kNew，相当于完全删除
&#125;

void EPollPoller::update(int operation, Channel *channel)//主要执行epoll_ctl函数
&#123;
    struct epoll_event event;
    bzero(&amp;event, sizeof event);
    event.events = channel-&gt;events();
    event.data.ptr = channel;//设置epoll_event结构体
    int fd = channel-&gt;fd();
    if (::epoll_ctl(epollfd_, operation, fd, &amp;event) &lt; 0) &#123;
        if (operation == EPOLL_CTL_DEL) &#123;
            LOG_SYSERR &lt;&lt; &quot;epoll_ctl op=&quot; &lt;&lt; operation &lt;&lt; &quot; fd=&quot; &lt;&lt; fd;
        &#125; else &#123;
            LOG_SYSFATAL &lt;&lt; &quot;epoll_ctl op=&quot; &lt;&lt; operation &lt;&lt; &quot; fd=&quot; &lt;&lt; fd;
        &#125;
    &#125;
&#125;
</code></pre>
<h3 id="acceptor"><a href="#acceptor" class="headerlink" title="acceptor"></a>acceptor</h3><p><code>Acceptor</code> 用于初始化socket，监听端口，接受连接并调用传入的 <code>callback</code> 创建连接：</p>
<p>Acceptor的数据成员包括Socket、Channel。</p>
<p>Acceptor的socket是listening socket（即server socket）。</p>
<p>Channel用于观察此socket的readable事件，并Acceptor::handleRead()，后者调用accept(2)来接受连接，并回调用户callback。</p>
<p>Acceptor类在上层应用程序中我们不直接使用，而是把它封装作为TcpServer的成员。</p>
<p>Acceptor.h源码分析</p>
<pre><code class="c++">/*就是用一个Acceptor类专门用一个channel来创建套接字，绑定，监听等操作*/
#ifndef MUDUO_NET_ACCEPTOR_H
#define MUDUO_NET_ACCEPTOR_H

#include &lt;boost/function.hpp&gt;
#include &lt;boost/noncopyable.hpp&gt;

#include &lt;muduo/net/Channel.h&gt;
#include &lt;muduo/net/Socket.h&gt;

namespace muduo &#123;
    namespace net &#123;

        class EventLoop;

        class InetAddress;
///
/// Acceptor of incoming TCP connections.
///
        class Acceptor : boost::noncopyable &#123;
        public:
            typedef boost::function&lt;void(int sockfd,const InetAddress &amp;)&gt; NewConnectionCallback;

            Acceptor(EventLoop *loop, const InetAddress &amp;listenAddr);

            ~Acceptor();
            //newConnectionCallback_是在Acceptor::handleRead里面执行的，也就是在acceptChannel_的读事件发生的时候会被调用
            void setNewConnectionCallback(const NewConnectionCallback &amp;cb) &#123; newConnectionCallback_ = cb; &#125;

            bool listenning() const &#123; return listenning_; &#125;

            void listen();

        private:
            void handleRead();//可读回调函数，绑定在acceptChannel_的读函数上

            EventLoop *loop_;//所属的EventLoop对象
            Socket acceptSocket_;//监听套接字
            Channel acceptChannel_;//和监听套接字绑定的通道 acceptChannel_和监听套接字acceptSocket_绑定
            NewConnectionCallback newConnectionCallback_;//一旦有新连接发生，执行的回调函数
            bool listenning_;//acceptChannel所处的eventloop是否处于监听状态
            int idleFd_;//预留一个fd，用来解决文件描述符过多，引起电平触发不断触发的问题，详见handleRead函数的最后
        &#125;;

    &#125;
&#125;

#endif  // MUDUO_NET_ACCEPTOR_H
</code></pre>
<p>Acceptor.cc源码分析</p>
<pre><code class="c++">#include &lt;muduo/net/Acceptor.h&gt;

#include &lt;muduo/net/EventLoop.h&gt;
#include &lt;muduo/net/InetAddress.h&gt;
#include &lt;muduo/net/SocketsOps.h&gt;

#include &lt;boost/bind.hpp&gt;

#include &lt;errno.h&gt;
#include &lt;fcntl.h&gt;
//#include &lt;sys/types.h&gt;
//#include &lt;sys/stat.h&gt;

using namespace muduo;
using namespace muduo::net;

Acceptor::Acceptor(EventLoop *loop, const InetAddress &amp;listenAddr)
        : loop_(loop),
          acceptSocket_(sockets::createNonblockingOrDie()),//设置监听套接字
          acceptChannel_(loop, acceptSocket_.fd()),
          listenning_(false),
          idleFd_(::open(&quot;/dev/null&quot;, O_RDONLY | O_CLOEXEC))//这个描述符打开一个linux系统的空文件，所有写入的内容都会被丢弃
&#123;
    assert(idleFd_ &gt;= 0);
    acceptSocket_.setReuseAddr(true);
    acceptSocket_.bindAddress(listenAddr);
    acceptChannel_.setReadCallback(boost::bind(&amp;Acceptor::handleRead, this));
&#125;

Acceptor::~Acceptor() &#123;
    acceptChannel_.disableAll();
    acceptChannel_.remove();
    ::close(idleFd_);
&#125;

void Acceptor::listen()//开启监听
&#123;
    loop_-&gt;assertInLoopThread();
    listenning_ = true;
    acceptSocket_.listen();
    acceptChannel_.enableReading();//将socket套接字挂到eventloop的epoll上，并开启读监听
&#125;

void Acceptor::handleRead()//读的回调函数，一旦socket套接字监听到连接，epoll就会立刻调用回调函数
&#123;
    loop_-&gt;assertInLoopThread();
    InetAddress peerAddr(0);//对端的
    //FIXME loop until no more
    int connfd = acceptSocket_.accept(&amp;peerAddr);
    if (connfd &gt;= 0) &#123;
        // string hostport = peerAddr.toIpPort();
        // LOG_TRACE &lt;&lt; &quot;Accepts of &quot; &lt;&lt; hostport;
        if (newConnectionCallback_) &#123;
            newConnectionCallback_(connfd, peerAddr);
        &#125; else &#123;
            sockets::close(connfd);
        &#125;
    &#125; else &#123;
        // Read the section named &quot;The special problem of
        // accept()ing when you can&#39;t&quot; in libev&#39;s doc.
        // By Marc Lehmann, author of livev.
        //在监听套接字可读事件触发时，我们会调用accept接受连接。如果此时注册过回调函数，就执行它。如果没有就直接关闭！
        //另一方面，如果已用文件描述符过多，accept会返回-1，我们构造函数中注册的idleFd_就派上用场了。
        // 当前文件描述符过多，无法接收新的连接。但是由于我们采用LT模式，如果无法接收，可读事件会一直触发。
        // 那么在这个地方的处理机制就是，关掉之前创建的idleFd_，然后去accept让这个事件不会一直触发，
        // 然后再关掉该文件描述符，重新将它设置为空文件描述符。
        //这种机制可以让网络库在处理连接过多，文件描述符不够用时，不至于因为LT模式一直触发而产生坏的影响。
        if (errno == EMFILE)//当accept函数出错时，是因为文件描述符太多了
        &#123;
            ::close(idleFd_);//就关闭一个空闲描述符，相当于现在就有一个空的文件描述符位置了
            idleFd_ = ::accept(acceptSocket_.fd(), NULL, NULL);//然后把刚才没有接受的描述符接受进来
            ::close(idleFd_);//把这个描述符给关闭，相当于忽略这个请求连接了
            idleFd_ = ::open(&quot;/dev/null&quot;, O_RDONLY | O_CLOEXEC);//重新开启这个空闲描述符
        &#125;//之所以这样，是因为poll使用的是水平触发，如果没有这个if判断，就会一直触发
    &#125;
&#125;
</code></pre>
<h3 id="tcp-server和tcp-connection"><a href="#tcp-server和tcp-connection" class="headerlink" title="tcp server和tcp connection"></a>tcp server和tcp connection</h3><p><strong>TcpServer</strong></p>
<p>TcpServer相当于主线程reactor， 此时主线程循环只负责TCP连接的建立，及任务的分配，需要让哪个线程干活， 就把timer或连接分配给那个线程即可；对实时性有要求的connection可以单独用一个线程； 数据量大的connection可以独占一个线程；并把数据处理任务分摊到另几个计算线程中（用线程池）；其他次要的辅助性connections共享一个线程。</p>
<p>分配连接主要通过EventLoopThreadPool 线程池实现，新建TcpConnection时从event loop pool里分配一个loop给TcpConnection。 TcpServer自己的EventLoop只用来接受新连接， 而新连接会用其他EventLoop来执行IO。</p>
<p><strong>EventLoopThreadPool</strong></p>
<p>TcpServer每次新建一条TcpConnection就会通过EventLoopThreadPool::getNextLoop()方法来取一个EventLoop， 目前的getNextLoop()只是循环的从池中取一条loop，如果提供给每条TcpConncetion的是均等的服务，那么这样就能很均匀的分配系统的资源了。</p>
<p> TcpServer的工作方式取决于EventLoopThreadPool中线程的创建数量。</p>
<p>0 意味着所有的I&#x2F;O 都在TcpServer的主事件循环中，不会创建新的线程。</p>
<p>1 意味着所有的 I&#x2F;O 在另一个线程中 ，TcpServer的主线程只负责建立连接。</p>
<p>N 意味着新的连接会被循环的分配到N条线程中工作。</p>
<p>TcpServer.h</p>
<pre><code class="c++">/* 这个类相当于把TcpConnection以及Accept类整合起来，完全能够实现Tcp通信，也就是socket函数都实现了
 * 一个TcpServer类中，有Acceptor，EventLoopThreadPool各一个，以及多个TcpConnection类的指针，
 * 在TcpServer类的启动函数中，先开启EventLoopThreadPool线程池，然后将Acceptor监听函数放入eventloop中去执行
 * 在TcpServer类的构造函数中，就已经把一个成功连接的回调函数绑定在Acceptor类的连接回调函数中，如果Acceptor监听
 * 到有连接进来，先调监听socket描述符的回调函数，把这个连接accept进来，然后再调用newConnectionCallback_函数
 * 来处理连接，每个连接都有一个对应的TcpConnection类来作为缓冲区
 * */
#ifndef MUDUO_NET_TCPSERVER_H
#define MUDUO_NET_TCPSERVER_H

#include &lt;muduo/base/Types.h&gt;
#include &lt;muduo/net/TcpConnection.h&gt;

#include &lt;map&gt;
#include &lt;boost/noncopyable.hpp&gt;
#include &lt;boost/scoped_ptr.hpp&gt;

namespace muduo &#123;
    namespace net &#123;

        class Acceptor;

        class EventLoop;

        class EventLoopThreadPool;

///
/// TCP server, supports single-threaded and thread-pool models.
///
/// This is an interface class, so don&#39;t expose too much details.
        class TcpServer : boost::noncopyable &#123;
        public:
            typedef boost::function&lt;void(EventLoop *)&gt; ThreadInitCallback;

            //TcpServer(EventLoop* loop, const InetAddress&amp; listenAddr);
            TcpServer(EventLoop *loop,
                      const InetAddress &amp;listenAddr,
                      const string &amp;nameArg);

            ~TcpServer();  // force out-line dtor, for scoped_ptr members.

            const string &amp;hostport() const &#123; return hostport_; &#125;

            const string &amp;name() const &#123; return name_; &#125;

            /// Set the number of threads for handling input.
            ///
            /// Always accepts new connection in loop&#39;s thread.
            /// Must be called before @c start
            /// @param numThreads
            /// - 0 means all I/O in loop&#39;s thread, no thread will created.
            ///   this is the default value.
            /// - 1 means all I/O in another thread.
            /// - N means a thread pool with N threads, new connections
            ///   are assigned on a round-robin basis.
            void setThreadNum(int numThreads);

            void setThreadInitCallback(
                    const ThreadInitCallback &amp;cb) &#123; threadInitCallback_ = cb; &#125;//这个函数会作为EventLoopThreadPool::start的入口参数

            /// Starts the server if it&#39;s not listenning.
            ///
            /// It&#39;s harmless to call it multiple times.
            /// Thread safe.
            void start();

            /// Set connection callback.
            /// Not thread safe.
            // 设置连接到来或者连接关闭回调函数,这个函数指针会赋值给TcpConnection::connectionCallback_函数，就是在连接建立之后，和连接断开之前会调用
            void setConnectionCallback(const ConnectionCallback &amp;cb) &#123; connectionCallback_ = cb; &#125;

            /// Set message callback.
            /// Not thread safe.
            //  设置消息到来回调函数，这个函数指针在TcpConnection::handleread函数中调用，也就是TcpConnection的Channel的读函数的一部分
            void setMessageCallback(const MessageCallback &amp;cb) &#123; messageCallback_ = cb; &#125;

            /// Set write complete callback.
            /// Not thread safe.
            /// 在发送完消息以后调用，这个函数指针会赋值给TcpConnection::writeCompleteCallback_函数
            void setWriteCompleteCallback(const WriteCompleteCallback &amp;cb) &#123; writeCompleteCallback_ = cb; &#125;


        private:
            /// Not thread safe, but in loop
            void newConnection(int sockfd, const InetAddress &amp;peerAddr);
            //这个函数会赋值给Acceptor::newConnectionCallback_，在新连接建立以后调用
            /// Thread safe.
            /// 会赋值给TcpConnection::closeCallback_函数，也就是当连接描述符关闭以后调用这个
            void removeConnection(const TcpConnectionPtr &amp;conn);

            /// Not thread safe, but in loop，在上面这个函数removeConnection中调用
            void removeConnectionInLoop(const TcpConnectionPtr &amp;conn);

            typedef std::map &lt;string, TcpConnectionPtr&gt; ConnectionMap;

            EventLoop *loop_;  // the acceptor loop
            const string hostport_;        // 服务的ip:端口
            const string name_;            // 服务名
            boost::scoped_ptr &lt;Acceptor&gt; acceptor_; // avoid revealing Acceptor
            boost::scoped_ptr &lt;EventLoopThreadPool&gt; threadPool_;
            ConnectionCallback connectionCallback_;
            MessageCallback messageCallback_;
            WriteCompleteCallback writeCompleteCallback_;        // 数据发送完毕，会回调此函数
            ThreadInitCallback threadInitCallback_;    // IO线程池中的线程在进入事件循环前，会回调用此函数
            bool started_;
            // always in loop thread
            int nextConnId_;                // 下一个连接ID,每次增加一个就加1
            ConnectionMap connections_;    // 连接列表
        &#125;;

    &#125;
&#125;

#endif  // MUDUO_NET_TCPSERVER_H
</code></pre>
<p>TcpServer.cc</p>
<pre><code class="c++">#include &lt;muduo/net/TcpServer.h&gt;

#include &lt;muduo/base/Logging.h&gt;
#include &lt;muduo/net/Acceptor.h&gt;
#include &lt;muduo/net/EventLoop.h&gt;
#include &lt;muduo/net/EventLoopThreadPool.h&gt;
#include &lt;muduo/net/SocketsOps.h&gt;

#include &lt;boost/bind.hpp&gt;

#include &lt;stdio.h&gt;  // snprintf

using namespace muduo;
using namespace muduo::net;

TcpServer::TcpServer(EventLoop *loop, const InetAddress &amp;listenAddr,
                     const string &amp;nameArg)
        : loop_(CHECK_NOTNULL(loop)),
          hostport_(listenAddr.toIpPort()),
          name_(nameArg),
          acceptor_(new Acceptor(loop, listenAddr)),
          threadPool_(new EventLoopThreadPool(loop)),
          connectionCallback_(defaultConnectionCallback),
          messageCallback_(defaultMessageCallback),
          started_(false),
          nextConnId_(1) &#123;
    // Acceptor::handleRead函数中会回调用TcpServer::newConnection
    // _1对应的是socket文件描述符，_2对应的是对等方的地址(InetAddress)
    acceptor_-&gt;setNewConnectionCallback(
            boost::bind(&amp;TcpServer::newConnection, this, _1, _2));
&#125;

TcpServer::~TcpServer() &#123;
    loop_-&gt;assertInLoopThread();
    LOG_TRACE &lt;&lt; &quot;TcpServer::~TcpServer [&quot; &lt;&lt; name_ &lt;&lt; &quot;] destructing&quot;;

    for (ConnectionMap::iterator it(connections_.begin());
         it != connections_.end(); ++it) &#123;
        TcpConnectionPtr conn = it-&gt;second;
        it-&gt;second.reset();        // 释放当前所控制的对象，引用计数减一
        conn-&gt;getLoop()-&gt;runInLoop(
                boost::bind(&amp;TcpConnection::connectDestroyed, conn));
        conn.reset();            // 释放当前所控制的对象，引用计数减一
    &#125;
&#125;

void TcpServer::setThreadNum(int numThreads) &#123;
    assert(0 &lt;= numThreads);
    threadPool_-&gt;setThreadNum(numThreads);
&#125;

// 该函数多次调用是无害的
// 该函数可以跨线程调用
void TcpServer::start() &#123;
    if (!started_) &#123;
        started_ = true;
        threadPool_-&gt;start(threadInitCallback_);
    &#125;

    if (!acceptor_-&gt;listenning()) &#123;
        // get_pointer返回原生指针
        loop_-&gt;runInLoop(
                boost::bind(&amp;Acceptor::listen, get_pointer(acceptor_)));
    &#125;
&#125;

void TcpServer::newConnection(int sockfd, const InetAddress &amp;peerAddr)//建立新连接以后的回调函数
&#123;
    loop_-&gt;assertInLoopThread();
    // 按照轮叫的方式选择一个EventLoop
    EventLoop *ioLoop = threadPool_-&gt;getNextLoop();
    char buf[32];
    snprintf(buf, sizeof buf, &quot;:%s#%d&quot;, hostport_.c_str(), nextConnId_);//buf的内容是 ip:端口#nextConnId_
    ++nextConnId_;
    string connName = name_ + buf;

    LOG_INFO &lt;&lt; &quot;TcpServer::newConnection [&quot; &lt;&lt; name_
             &lt;&lt; &quot;] - new connection [&quot; &lt;&lt; connName
             &lt;&lt; &quot;] from &quot; &lt;&lt; peerAddr.toIpPort();
    InetAddress localAddr(sockets::getLocalAddr(sockfd));
    // FIXME poll with zero timeout to double confirm the new connection
    // FIXME use make_shared if necessary
    /*TcpConnectionPtr conn(new TcpConnection(loop_,
                                            connName,
                                            sockfd,
                                            localAddr,
                                            peerAddr));*/

    TcpConnectionPtr conn(new TcpConnection(ioLoop,
                                            connName,
                                            sockfd,
                                            localAddr,
                                            peerAddr));

    LOG_TRACE &lt;&lt; &quot;[1] usecount=&quot; &lt;&lt; conn.use_count();
    connections_[connName] = conn;//将连接名和TCPConnection的指针拷贝进连接列表中，这样就有两个shared_ptr指针指向conn了，
    //如果没有这一句程序，这个conn在newConnection函数执行结束以后就会析构掉，所以真正要删除时，也要把这个列表中的对应元素也删除了。
    LOG_TRACE &lt;&lt; &quot;[2] usecount=&quot; &lt;&lt; conn.use_count();
    //设置回调函数
    conn-&gt;setConnectionCallback(connectionCallback_);
    conn-&gt;setMessageCallback(messageCallback_);
    conn-&gt;setWriteCompleteCallback(writeCompleteCallback_);//无论是否非空，都可以先设置，在使用之前会有判断

    conn-&gt;setCloseCallback(
            boost::bind(&amp;TcpServer::removeConnection, this, _1));

    // conn-&gt;connectEstablished();
    ioLoop-&gt;runInLoop(boost::bind(&amp;TcpConnection::connectEstablished, conn));
    //bind在绑定类成员函数时，后面跟的参数一定比输入参数多一个，就是一个类指针，表明这个函数属于那个类变量的，
    //一般都使用this，而这里是用的TcpConnectionPtr
    LOG_TRACE &lt;&lt; &quot;[5] usecount=&quot; &lt;&lt; conn.use_count();

&#125;

void TcpServer::removeConnection(const TcpConnectionPtr &amp;conn) &#123;
    /*
  loop_-&gt;assertInLoopThread();
  LOG_INFO &lt;&lt; &quot;TcpServer::removeConnectionInLoop [&quot; &lt;&lt; name_
           &lt;&lt; &quot;] - connection &quot; &lt;&lt; conn-&gt;name();


  LOG_TRACE &lt;&lt; &quot;[8] usecount=&quot; &lt;&lt; conn.use_count();
  size_t n = connections_.erase(conn-&gt;name());
  LOG_TRACE &lt;&lt; &quot;[9] usecount=&quot; &lt;&lt; conn.use_count();

  (void)n;
  assert(n == 1);
  
  loop_-&gt;queueInLoop(
      boost::bind(&amp;TcpConnection::connectDestroyed, conn));
  LOG_TRACE &lt;&lt; &quot;[10] usecount=&quot; &lt;&lt; conn.use_count();
  */

    loop_-&gt;runInLoop(boost::bind(&amp;TcpServer::removeConnectionInLoop, this, conn));

&#125;

void TcpServer::removeConnectionInLoop(const TcpConnectionPtr &amp;conn)//就是把TcpConnection从Eventloop中移除
&#123;
    loop_-&gt;assertInLoopThread();
    LOG_INFO &lt;&lt; &quot;TcpServer::removeConnectionInLoop [&quot; &lt;&lt; name_
             &lt;&lt; &quot;] - connection &quot; &lt;&lt; conn-&gt;name();


    LOG_TRACE &lt;&lt; &quot;[8] usecount=&quot; &lt;&lt; conn.use_count();
    size_t n = connections_.erase(conn-&gt;name());
    LOG_TRACE &lt;&lt; &quot;[9] usecount=&quot; &lt;&lt; conn.use_count();

    (void) n;
    assert(n == 1);

    EventLoop *ioLoop = conn-&gt;getLoop();
    ioLoop-&gt;queueInLoop(
            boost::bind(&amp;TcpConnection::connectDestroyed, conn));

    //loop_-&gt;queueInLoop(
    //    boost::bind(&amp;TcpConnection::connectDestroyed, conn));
    LOG_TRACE &lt;&lt; &quot;[10] usecount=&quot; &lt;&lt; conn.use_count();


&#125;
</code></pre>
<p><strong>TcpConnection</strong></p>
<p>TcpConnection类主要负责封装一次TCP连接，向Channel类注册回调函数（可读、可写、可关闭、错误处理），将来当Channel类上的事件发生时，调用相应的回调函数进行数据收发或者错误处理。</p>
<p>TcpConnection是使用shared_ptr来管理的类，因为它的生命周期模糊。TcpConnection表示已经建立或正在建立的连接，建立连接后，用户只需要在上层类如TcpServer中设置连接到来和消息到来的处理函数，继而回调TcpConnection中的 setConnectionCallback和setMessageCallback函数，实现对事件的处理。用户需要关心的事件是有限的，其他都由网络库负责。</p>
<p>TcpConnection中封装了InputBuffer和OutputBuffer，用来表示应用层的缓冲区。在发送数据时，如果不能一次将Buffer中的数据发送完毕，它还会继续关注Channel中的可写事件，当sockfd可写时，会再次发送。</p>
<p>前面提到TcpConnection的生存期模糊，主要是因为我们不能在TcpServer中直接erase掉TcpConnection对象，因为此时有可能Channel中的handleEvent还在执行，如果析构TcpConnection对象，那么他的成员channel_也会被析构，会导致core dump。也就是说我们需要TcpConnection 对象生存期要长于handleEvent() 函数，直到执行完connectDestroyed() 后才会析构。</p>
<p><strong>断开连接：</strong></p>
<p>TcpConnection的断开是采用被动方式，即对方先关闭连接，本地read(2)返回0后，调用顺序如下：</p>
<p>handleClose()-&gt;TcpServer::removeConnection-&gt;TcpConnection::connectDestroyed()。</p>
<p>连接关闭时序图：</p>
<p>​    <img src="https://raw.githubusercontent.com/hufei96/Image/main/muduo_tcp_close.png" alt="img"></p>
<p>当连接到来，创建一个TcpConnection对象，立刻用shared_ptr来管理，引用计数为1，在Channel中维护一个weak_ptr（tie_），将这个shared_ptr对象赋值给_tie，引用计数仍然为1。当连接关闭时，在handleEvent中，将tie_提升，得到一个shard_ptr对象，引用计数就变成了2。当shared_ptr的计数不为0时，TcpConnection不会被销毁。</p>
<p>TcpConnection.h</p>
<pre><code class="c++">/*这个类主要用来和buffer类一起作为非阻塞IO的一个读取桥梁，其中主要封装的函数是从文件描述符中读取传输的数据到
 *接受缓冲区中，或者把规定数据，或者触发写事件的输出缓冲区的数据写入对应的文件描述符中。
 */
#ifndef MUDUO_NET_TCPCONNECTION_H
#define MUDUO_NET_TCPCONNECTION_H

#include &lt;muduo/base/Mutex.h&gt;
#include &lt;muduo/base/StringPiece.h&gt;
#include &lt;muduo/base/Types.h&gt;
#include &lt;muduo/net/Callbacks.h&gt;
#include &lt;muduo/net/Buffer.h&gt;
#include &lt;muduo/net/InetAddress.h&gt;

#include &lt;boost/any.hpp&gt;
#include &lt;boost/enable_shared_from_this.hpp&gt;
#include &lt;boost/noncopyable.hpp&gt;
#include &lt;boost/scoped_ptr.hpp&gt;
#include &lt;boost/shared_ptr.hpp&gt;

namespace muduo &#123;
    namespace net &#123;

        class Channel;

        class EventLoop;

        class Socket;

///
/// TCP connection, for both client and server usage.
///
/// This is an interface class, so don&#39;t expose too much details.
        class TcpConnection : boost::noncopyable,public boost::enable_shared_from_this&lt;TcpConnection&gt; &#123;
        public:
            /// Constructs a TcpConnection with a connected sockfd
            ///
            /// User should not create this object.
            TcpConnection(EventLoop *loop,const string &amp;name,int sockfd,
                          const InetAddress &amp;localAddr,
                          const InetAddress &amp;peerAddr);

            ~TcpConnection();

            EventLoop *getLoop() const &#123; return loop_; &#125;//获取当前TcpConnection所在的Eventloop
            const string &amp;name() const &#123; return name_; &#125;//
            const InetAddress &amp;localAddress() &#123; return localAddr_; &#125;

            const InetAddress &amp;peerAddress() &#123; return peerAddr_; &#125;

            bool connected() const &#123; return state_ == kConnected; &#125;

            // void send(string&amp;&amp; message); // C++11
            void send(const void *message, size_t len);

            void send(const StringPiece &amp;message);

            // void send(Buffer&amp;&amp; message); // C++11
            void send(Buffer *message);  // this one will swap data
            void shutdown(); // NOT thread safe, no simultaneous calling
            void setTcpNoDelay(bool on);

            void setContext(const boost::any &amp;context) &#123; context_ = context; &#125;

            const boost::any &amp;getContext() const//得到常数值的context_
            &#123; return context_; &#125;

            boost::any *getMutableContext()//得到可以改变的context_
            &#123; return &amp;context_; &#125;

            void setConnectionCallback(const ConnectionCallback &amp;cb) &#123; connectionCallback_ = cb; &#125;
            //在handleClose，connectEstablished，connectDestroyed中调用，个人理解这个连接回调函数主要起到
            //显示作用，就是在和连接描述符建立连接或者关闭连接前，显示连接状态的，表明还在连接中

            void setMessageCallback(const MessageCallback &amp;cb) &#123; messageCallback_ = cb; &#125;
            //在handleRead函数当中调用了，也可以理解为channel_写函数的一部分

            void setWriteCompleteCallback(const WriteCompleteCallback &amp;cb) &#123; writeCompleteCallback_ = cb; &#125;
            //在handleWrite和sendInLoop写函数中，写完调用的

            void setHighWaterMarkCallback(const HighWaterMarkCallback &amp;cb, size_t highWaterMark) &#123;
                highWaterMarkCallback_ = cb;
                highWaterMark_ = highWaterMark;
            &#125;//都在sendInLoop中调用了

            Buffer *inputBuffer() &#123; return &amp;inputBuffer_; &#125;

            /// Internal use only.
            void setCloseCallback(const CloseCallback &amp;cb) &#123; closeCallback_ = cb; &#125;//在handleClose函数中调用

            // called when TcpServer accepts a new connection
            void connectEstablished();   // should be called only once
            // called when TcpServer has removed me from its map
            void connectDestroyed();  // should be called only once

        private:
            enum StateE &#123;
                kDisconnected, kConnecting, kConnected, kDisconnecting
            &#125;;

            void handleRead(Timestamp receiveTime);//绑定channel_的读函数
            void handleWrite();//绑定channel_的写函数
            void handleClose();//绑定channel_的关闭函数，同时也在handleRead中调用
            void handleError();////绑定channel_的错误函数
            void sendInLoop(const StringPiece &amp;message);

            void sendInLoop(const void *message, size_t len);

            void shutdownInLoop();

            void setState(StateE s) &#123; state_ = s; &#125;//设置状态位

            EventLoop *loop_;            // 所属EventLoop
            string name_;                // 连接名
            StateE state_;  // FIXME: use atomic variable
            // we don&#39;t expose those classes to client.
            //连接状态
            boost::scoped_ptr &lt;Socket&gt; socket_;
            boost::scoped_ptr &lt;Channel&gt; channel_;
            //channel_在TCPServer中绑定了连接套接字，就是能够实现通信的那个connfd套接字，这个套接字是从Socket::accept函数得到的
            //在Tcpclient绑定的是创建的套接字，因为客户端只需要一个套接字就可以了，这个套接字是从socket()函数中得到的
            InetAddress localAddr_;//当前服务端的地址
            InetAddress peerAddr_;//当前建立连接的客户端地址
            ConnectionCallback connectionCallback_;
            MessageCallback messageCallback_;
            WriteCompleteCallback writeCompleteCallback_;        // 数据发送完毕回调函数，即所有的用户数据都已拷贝到内核缓冲区时回调该函数
            // outputBuffer_被清空也会回调该函数，可以理解为低水位标回调函数
            HighWaterMarkCallback highWaterMarkCallback_;        // 高水位标回调函数
            CloseCallback closeCallback_;
            size_t highWaterMark_;        // 高水位标
            Buffer inputBuffer_;            // 应用层接收缓冲区
            Buffer outputBuffer_;            // 应用层发送缓冲区
            boost::any context_;            // 绑定一个未知类型的上下文对象，一般用来放HttpContext类的
        &#125;;

        typedef boost::shared_ptr &lt;TcpConnection&gt; TcpConnectionPtr;

    &#125;
&#125;

#endif  // MUDUO_NET_TCPCONNECTION_H
</code></pre>
<p>TcpConnection.cc</p>
<pre><code class="c++">#include &lt;muduo/net/TcpConnection.h&gt;

#include &lt;muduo/base/Logging.h&gt;
#include &lt;muduo/net/Channel.h&gt;
#include &lt;muduo/net/EventLoop.h&gt;
#include &lt;muduo/net/Socket.h&gt;
#include &lt;muduo/net/SocketsOps.h&gt;

#include &lt;boost/bind.hpp&gt;

#include &lt;errno.h&gt;
#include &lt;stdio.h&gt;

using namespace muduo;
using namespace muduo::net;

void muduo::net::defaultConnectionCallback(const TcpConnectionPtr &amp;conn)//默认的连接回调函数，输出连接状态
&#123;
    LOG_TRACE &lt;&lt; conn-&gt;localAddress().toIpPort() &lt;&lt; &quot; -&gt; &quot;
              &lt;&lt; conn-&gt;peerAddress().toIpPort() &lt;&lt; &quot; is &quot;
              &lt;&lt; (conn-&gt;connected() ? &quot;UP&quot; : &quot;DOWN&quot;);
&#125;

void muduo::net::defaultMessageCallback(const TcpConnectionPtr &amp;, Buffer *buf, Timestamp)
//默认的有消息时执行的回调函数，把缓冲区读指针和写指针回到初始化的位置
//可以理解为将缓冲区清零
&#123;
    buf-&gt;retrieveAll();
&#125;

TcpConnection::TcpConnection(EventLoop *loop, const string &amp;nameArg, int sockfd,
                             const InetAddress &amp;localAddr,
                             const InetAddress &amp;peerAddr)
        : loop_(CHECK_NOTNULL(loop)), // 所属EventLoop
          name_(nameArg),// 连接名
          state_(kConnecting),//连接状态
          socket_(new Socket(sockfd)),//连接套接字
          channel_(new Channel(loop, sockfd)),
          //channel_在TCPServer中绑定了连接套接字，就是能够实现通信的那个connfd套接字，这个套接字是从Socket::accept函数得到的
          //在Tcpclient绑定的是创建的套接字，因为客户端只需要一个套接字就可以了，这个套接字是从socket()函数中得到的
          localAddr_(localAddr),//当前服务端的地址
          peerAddr_(peerAddr),//当前建立连接的客户端地址
          highWaterMark_(64 * 1024 * 1024) &#123;
    // 通道可读事件到来的时候，回调TcpConnection::handleRead，_1是事件发生时间
    channel_-&gt;setReadCallback(boost::bind(&amp;TcpConnection::handleRead, this, _1));
    // 通道可写事件到来的时候，回调TcpConnection::handleWrite
    channel_-&gt;setWriteCallback(boost::bind(&amp;TcpConnection::handleWrite, this));
    // 连接关闭，回调TcpConnection::handleClose
    channel_-&gt;setCloseCallback(boost::bind(&amp;TcpConnection::handleClose, this));
    // 发生错误，回调TcpConnection::handleError
    channel_-&gt;setErrorCallback(boost::bind(&amp;TcpConnection::handleError, this));
    LOG_DEBUG &lt;&lt; &quot;TcpConnection::ctor[&quot; &lt;&lt; name_ &lt;&lt; &quot;] at &quot; &lt;&lt; this&lt;&lt; &quot; fd=&quot; &lt;&lt; sockfd;
    socket_-&gt;setKeepAlive(true);//定期探测连接是否存在，类似于心跳包
&#125;

TcpConnection::~TcpConnection() &#123;
    LOG_DEBUG &lt;&lt; &quot;TcpConnection::dtor[&quot; &lt;&lt; name_ &lt;&lt; &quot;] at &quot; &lt;&lt; this
              &lt;&lt; &quot; fd=&quot; &lt;&lt; channel_-&gt;fd();
&#125;

// 线程安全，可以跨线程调用
void TcpConnection::send(const void *data, size_t len) &#123;
    if (state_ == kConnected) &#123;
        if (loop_-&gt;isInLoopThread()) &#123;
            sendInLoop(data, len);
        &#125; else &#123;
            string message(static_cast&lt;const char *&gt;(data), len);
            loop_-&gt;runInLoop(boost::bind(&amp;TcpConnection::sendInLoop,this,message));
        &#125;
    &#125;
&#125;

// 线程安全，可以跨线程调用
void TcpConnection::send(const StringPiece &amp;message) &#123;
    if (state_ == kConnected) &#123;
        if (loop_-&gt;isInLoopThread()) &#123;
            sendInLoop(message);
        &#125; else &#123;
            loop_-&gt;runInLoop(boost::bind(&amp;TcpConnection::sendInLoop,this,message.as_string()));
            //std::forward&lt;string&gt;(message)));
        &#125;
    &#125;
&#125;

// 线程安全，可以跨线程调用
void TcpConnection::send(Buffer *buf) &#123;
    if (state_ == kConnected) &#123;
        if (loop_-&gt;isInLoopThread()) &#123;
            sendInLoop(buf-&gt;peek(), buf-&gt;readableBytes());
            buf-&gt;retrieveAll();
        &#125; else &#123;
            loop_-&gt;runInLoop(boost::bind(&amp;TcpConnection::sendInLoop,this,buf-&gt;retrieveAllAsString()));
            //std::forward&lt;string&gt;(message)));
        &#125;
    &#125;
&#125;

void TcpConnection::sendInLoop(const StringPiece &amp;message) &#123;
    sendInLoop(message.data(), message.size());
&#125;

void TcpConnection::sendInLoop(const void *data, size_t len) &#123;
    /*
    loop_-&gt;assertInLoopThread();
    sockets::write(channel_-&gt;fd(), data, len);
    */
    loop_-&gt;assertInLoopThread();
    ssize_t nwrote = 0;
    size_t remaining = len;
    bool error = false;
    if (state_ == kDisconnected) &#123;
        LOG_WARN &lt;&lt; &quot;disconnected, give up writing&quot;;
        return;
    &#125;
    // if no thing in output queue, try writing directly
    // 通道没有关注可写事件并且发送缓冲区没有数据，直接write
    if (!channel_-&gt;isWriting() &amp;&amp; outputBuffer_.readableBytes() == 0) &#123;
        nwrote = sockets::write(channel_-&gt;fd(), data, len);
        if (nwrote &gt;= 0) &#123;
            remaining = len - nwrote;
            // 写完了，回调writeCompleteCallback_
            if (remaining == 0 &amp;&amp; writeCompleteCallback_) &#123;
                loop_-&gt;queueInLoop(boost::bind(writeCompleteCallback_, shared_from_this()));
            &#125;
        &#125; else // nwrote &lt; 0
        &#123;
            nwrote = 0;
            if (errno != EWOULDBLOCK) &#123;
                LOG_SYSERR &lt;&lt; &quot;TcpConnection::sendInLoop&quot;;
                if (errno == EPIPE) // FIXME: any others?
                &#123;
                    error = true;
                &#125;
            &#125;
        &#125;
    &#125;

    assert(remaining &lt;= len);
    // 没有错误，并且还有未写完的数据（说明内核发送缓冲区满，要将未写完的数据添加到output buffer中）
    if (!error &amp;&amp; remaining &gt; 0) &#123;
        LOG_TRACE &lt;&lt; &quot;I am going to write more data&quot;;
        size_t oldLen = outputBuffer_.readableBytes();
        // 如果超过highWaterMark_（高水位标），回调highWaterMarkCallback_
        if (oldLen + remaining &gt;= highWaterMark_
            &amp;&amp; oldLen &lt; highWaterMark_
            &amp;&amp; highWaterMarkCallback_) &#123;
            loop_-&gt;queueInLoop(boost::bind(highWaterMarkCallback_, shared_from_this(), oldLen + remaining));
        &#125;
        outputBuffer_.append(static_cast&lt;const char *&gt;(data) + nwrote, remaining);//将剩余数据存入应用层发送缓冲区
        if (!channel_-&gt;isWriting()) &#123;
            channel_-&gt;enableWriting();        // 关注POLLOUT事件
        &#125;
    &#125;
&#125;

void TcpConnection::shutdown()//关闭连接
&#123;
    // FIXME: use compare and swap
    if (state_ == kConnected) &#123;
        setState(kDisconnecting);
        // FIXME: shared_from_this()?
        loop_-&gt;runInLoop(boost::bind(&amp;TcpConnection::shutdownInLoop, this));
    &#125;
&#125;

void TcpConnection::shutdownInLoop()//在loop中关闭写半边，还是可以读数据
&#123;
    loop_-&gt;assertInLoopThread();
    if (!channel_-&gt;isWriting()) &#123;
        // we are not writing
        socket_-&gt;shutdownWrite();
    &#125;
&#125;

void TcpConnection::setTcpNoDelay(bool on)//设置TCP延迟连接
&#123;
    socket_-&gt;setTcpNoDelay(on);
&#125;

void TcpConnection::connectEstablished()//这个建立连接是TcpConnection类中的channel加入到对应的比如Tcpclient或者Tcpserver类所属的eventloop中
&#123;
    loop_-&gt;assertInLoopThread();
    assert(state_ == kConnecting);//设置正在连接状态
    setState(kConnected);
    LOG_TRACE &lt;&lt; &quot;[3] usecount=&quot; &lt;&lt; shared_from_this().use_count();
    channel_-&gt;tie(shared_from_this());
    channel_-&gt;enableReading();    // TcpConnection所对应的通道加入到Poller关注

    connectionCallback_(shared_from_this());
    LOG_TRACE &lt;&lt; &quot;[4] usecount=&quot; &lt;&lt; shared_from_this().use_count();
&#125;

void TcpConnection::connectDestroyed()//取消连接，从对应的Eventloop上的epoll队列中去除
&#123;
    loop_-&gt;assertInLoopThread();
    if (state_ == kConnected) &#123;
        setState(kDisconnected);
        channel_-&gt;disableAll();

        connectionCallback_(shared_from_this());
    &#125;
    channel_-&gt;remove();//将channel从epoll队列中移除
&#125;

void TcpConnection::handleRead(Timestamp receiveTime)//处理读事件的函数
&#123;
    /*
    loop_-&gt;assertInLoopThread();
    int savedErrno = 0;
    ssize_t n = inputBuffer_.readFd(channel_-&gt;fd(), &amp;savedErrno);
    if (n &gt; 0)
    &#123;
      messageCallback_(shared_from_this(), &amp;inputBuffer_, receiveTime);
    &#125;
    else if (n == 0)
    &#123;
      handleClose();
    &#125;
    else
    &#123;
      errno = savedErrno;
      LOG_SYSERR &lt;&lt; &quot;TcpConnection::handleRead&quot;;
      handleError();
    &#125;
    */

    /*
    loop_-&gt;assertInLoopThread();
    int savedErrno = 0;
    char buf[65536];
    ssize_t n = ::read(channel_-&gt;fd(), buf, sizeof buf);
    if (n &gt; 0)
    &#123;
      messageCallback_(shared_from_this(), buf, n);
    &#125;
    else if (n == 0)
    &#123;
      handleClose();
    &#125;
    else
    &#123;
      errno = savedErrno;
      LOG_SYSERR &lt;&lt; &quot;TcpConnection::handleRead&quot;;
      handleError();
    &#125;
    */
    loop_-&gt;assertInLoopThread();
    int savedErrno = 0;
    ssize_t n = inputBuffer_.readFd(channel_-&gt;fd(), &amp;savedErrno);//直接将数据读到inputBuffer_缓冲区
    if (n &gt; 0) &#123;
        messageCallback_(shared_from_this(), &amp;inputBuffer_, receiveTime);
    &#125; else if (n == 0) &#123;
        handleClose();//如果读到的数据为0，就自动退出
    &#125; else &#123;
        errno = savedErrno;
        LOG_SYSERR &lt;&lt; &quot;TcpConnection::handleRead&quot;;
        handleError();
    &#125;
&#125;

// 监听到写事件了，就调用这个函数，此时服务器已经把要写的内容写到outputBuffer_中去了，所以要写的内容从读指针处开始
void TcpConnection::handleWrite() &#123;
    loop_-&gt;assertInLoopThread();
    if (channel_-&gt;isWriting())//查看是否有写事件需要关注
    &#123;
        ssize_t n = sockets::write(channel_-&gt;fd(),
                                   outputBuffer_.peek(),
                                   outputBuffer_.readableBytes());//写到文件描述符中去
        if (n &gt; 0) &#123;
            outputBuffer_.retrieve(n);//处理读写指针
            if (outputBuffer_.readableBytes() == 0)     // 发送缓冲区已清空
            &#123;
                channel_-&gt;disableWriting();        // 停止关注POLLOUT事件，以免出现busy loop
                if (writeCompleteCallback_)        // 回调writeCompleteCallback_
                &#123;
                    // 应用层发送缓冲区被清空，就回调用writeCompleteCallback_
                    // 发送给IO线程进行处理
                    loop_-&gt;queueInLoop(boost::bind(writeCompleteCallback_, shared_from_this()));
                &#125;
                if (state_ == kDisconnecting)    // 发送缓冲区已清空并且连接状态是kDisconnecting, 要关闭连接
                &#123;
                    shutdownInLoop();        // 关闭写连接
                &#125;
            &#125; else &#123;
                LOG_TRACE &lt;&lt; &quot;I am going to write more data&quot;;
            &#125;
        &#125; else &#123;
            LOG_SYSERR &lt;&lt; &quot;TcpConnection::handleWrite&quot;;
            // if (state_ == kDisconnecting)
            // &#123;
            //   shutdownInLoop();
            // &#125;
        &#125;
    &#125; else &#123;
        LOG_TRACE &lt;&lt; &quot;Connection fd = &quot; &lt;&lt; channel_-&gt;fd()
                  &lt;&lt; &quot; is down, no more writing&quot;;
    &#125;
&#125;

void TcpConnection::handleClose()//关闭事件处理，也是epoll如果发生关闭事件的回调函数
&#123;
    loop_-&gt;assertInLoopThread();
    LOG_TRACE &lt;&lt; &quot;fd = &quot; &lt;&lt; channel_-&gt;fd() &lt;&lt; &quot; state = &quot; &lt;&lt; state_;
    assert(state_ == kConnected || state_ == kDisconnecting);
    // we don&#39;t close fd, leave it to dtor, so we can find leaks easily.
    setState(kDisconnected);
    channel_-&gt;disableAll();

    TcpConnectionPtr guardThis(shared_from_this());
    connectionCallback_(guardThis);        // 在结束前，最后一次处理一下，这一行，可以不调用
    LOG_TRACE &lt;&lt; &quot;[7] usecount=&quot; &lt;&lt; guardThis.use_count();
    // must be the last line
    closeCallback_(guardThis);    // 调用TcpServer::removeConnection
    LOG_TRACE &lt;&lt; &quot;[11] usecount=&quot; &lt;&lt; guardThis.use_count();
&#125;

void TcpConnection::handleError()//处理错误的函数，也是epoll如果发生错误事件的回调函数
&#123;
    int err = sockets::getSocketError(channel_-&gt;fd());
    LOG_ERROR &lt;&lt; &quot;TcpConnection::handleError [&quot; &lt;&lt; name_
              &lt;&lt; &quot;] - SO_ERROR = &quot; &lt;&lt; err &lt;&lt; &quot; &quot; &lt;&lt; strerror_tl(err);
&#125;
</code></pre>
<h3 id="timer"><a href="#timer" class="headerlink" title="timer"></a>timer</h3><p>Muduo的定时器功能主要由三个class实现，TimerId，Timer，TimerQueue，TimerQueue的接口只有两个addTimer()和cancel()，addTimer()是提供给EventLoop使用的， EventLoop会把它封装成更好用的三个函数：runAt()、runAfter()、runEvery()。</p>
<p><strong>大体实现</strong></p>
<p>muduo 定时器封装了 Timer.h 里面保存的是超时时间和回调函数, TimerQueue.h 使用set容器保存多个定时器, 然后在TimerQueue中使用timerfd_create创建一个timerfd句柄, 插入定时器A后先比较A的触发时间和TimerQueue的触发时间, 如果A的触发时间比其小就使用timerfd_settime重置TimerQueue的timerfd的触发时间, TimerQueue中的timerfd的触发时间永远与保存的定时器中触发时间最小的那个相同, 然后timerfd触发可读后, 遍历保存的多个定时器, 看看有没有同时到期的, 有执行回调函数</p>
<p>TimerQueue的封装是为了让未到期的时间Timer有序的排列起来，这样，能够更具当前时间找到已经到期的Timer也能高效的添加和删除Timer。</p>
<p>所谓的到期与未到期，与当前在当前时间之前表示已经到期，之后则是未到期。为了方便计算，muduo重载了operator&lt;主要是用来比较微秒大小。</p>
<p>到期的时间应该被清除去执行相应的回调，未到期的时间则应该有序的排列起来。</p>
<p> 对于TimerQueue的数据结构，作者提出了几个方案。</p>
<p>1.传统线性表，查找复杂度为O(n)</p>
<p>2.二叉堆实现优先级队列，不过C++标准的make_heap()不能高效地完成删除操作。</p>
<p> 最终，为了防止时间相同所导致的Key相同的情况，使用set和pair</p>
<pre><code>typedef std::pair&lt;Timestamp, Timer*&gt;Entry;

typedef std::set&lt;Entry&gt;TimerList;

TimerList timers_;
</code></pre>
<p><strong>timerfd介绍</strong></p>
<p>这节介绍muduo中定时器的实现。先看一个2.6内核新增的有关定时的系统调用，基于这几个系统调用可以实现基于文件描述符的定时器。使文件描述符在某一特定时间可读。</p>
<pre><code class="c++">#include &lt;sys/timerfd.h&gt;

    int timerfd_create(int clockid, int flags);

    int timerfd_settime(int fd, int flags,
           const struct itimerspec * new_value,
           struct itimerspec * old_value);

    int timerfd_gettime(int fd, struct itimerspec *curr_value);
</code></pre>
<p>1、timerfd_create用于创建一个定时器文件，函数返回值是一个文件句柄fd。</p>
<p>2、timerfd_settime用于设置新的超时时间，并开始计时。flag为0表示相对时间，为1表示绝对时间。new_value为这次设置的新时间，old_value为上次设置的时间。返回0表示设置成功。</p>
<p>3、timerfd_gettime用于获得定时器距离下次超时还剩下的时间。如果调用时定时器已经到期，并且该定时器处于循环模式（设置超时时间时struct itimerspec::it_interval不为0），那么调用此函数之后定时器重新开始计时。</p>
<p><strong>TimerId介绍</strong></p>
<p>TimerId非常简单，它被设计用来取消Timer的，它的结构很简单，只有一个Timer指针和其序列号。</p>
<pre><code class="c++">/*封装了timer类到构造和析构函数中，我的理解就是RAII的思想
 * TimerId非常简单，它被设计用来取消Timer的，它的结构很简单，只有一个Timer指针和其序列号。*/
#ifndef MUDUO_NET_TIMERID_H
#define MUDUO_NET_TIMERID_H

#include &lt;muduo/base/copyable.h&gt;

namespace muduo &#123;
    namespace net &#123;

        class Timer;

///
/// An opaque identifier, for canceling Timer.
///
        class TimerId : public muduo::copyable &#123;
        public:
            TimerId()
                    : timer_(NULL),
                      sequence_(0) &#123;
            &#125;

            TimerId(Timer *timer, int64_t seq)
                    : timer_(timer),
                      sequence_(seq) &#123;
            &#125;

            // default copy-ctor, dtor and assignment are okay

            friend class TimerQueue;//友元，就是可以访问类的私有成员变量，但不是类中的成员

        private:
            Timer *timer_;
            int64_t sequence_;
        &#125;;

    &#125;
&#125;

#endif  // MUDUO_NET_TIMERID_H
</code></pre>
<p><strong>Timer</strong></p>
<p>Timer封装了定时器的一些参数，例如超时回调函数、超时时间、定时器是否重复、重复间隔时间、定时器的序列号。其函数大都是设置这些参数，run()用来调用回调函数，restart()用来重启定时器（如果设置为重复）。其源码相对简单</p>
<pre><code class="c++">/*计时器类*/
#ifndef MUDUO_NET_TIMER_H
#define MUDUO_NET_TIMER_H

#include &lt;boost/noncopyable.hpp&gt;

#include &lt;muduo/base/Atomic.h&gt;
#include &lt;muduo/base/Timestamp.h&gt;
#include &lt;muduo/net/Callbacks.h&gt;

namespace muduo &#123;
    namespace net &#123;
///
/// Internal class for timer event.
///
        class Timer : boost::noncopyable &#123;
        public:
            Timer(const TimerCallback &amp;cb, Timestamp when, double interval)
                    : callback_(cb),//回调函数
                      expiration_(when),//超时时间
                      interval_(interval),//如果重复，间隔时间
                      repeat_(interval &gt; 0.0),//如果间隔大于0，就重复
                      sequence_(s_numCreated_.incrementAndGet()) &#123;&#125;//当前定时器的序列号
            //调用回调函数.
            void run() const &#123;
                callback_();
            &#125;

            Timestamp expiration() const &#123; return expiration_; &#125;//返回超时时刻
            bool repeat() const &#123; return repeat_; &#125;//返回是否重复
            int64_t sequence() const &#123; return sequence_; &#125;//返回定时器序号

            void restart(Timestamp now);//重新开始

            static int64_t numCreated() &#123; return s_numCreated_.get(); &#125;//返回最新的序号值

        private:
            const TimerCallback callback_;        // 定时器回调函数
            Timestamp expiration_;                // 下一次的超时时间戳类
            const double interval_;                // 超时时间间隔，如果是一次性定时器，该值为0
            const bool repeat_;                    // 是否重复
            const int64_t sequence_;                // 定时器序号，不会重复

            static AtomicInt64 s_numCreated_;        // 定时器计数，当前已经创建的定时器数量
        &#125;;
    &#125;
&#125;
#endif  // MUDUO_NET_TIMER_H
</code></pre>
<p><strong>TimerQueue</strong></p>
<p>虽然TimerQueue中有Queue，但是其实现时基于Set的，而不是Queue。这样可以高效地插入、删除定时器，且找到当前已经超时的定时器。TimerQueue的public接口只有两个，添加和删除。</p>
<pre><code>void addTimerInLoop(Timer* timer);

void cancelInLoop(TimerId timerId);
</code></pre>
<p>定时器管理类，其中timer类就是TimerQueue需要管理的元素，而timerId就是一个简单的timer封装，避免销毁和创建操作</p>
<p>但是要注意的是timer并没有自己计时的功能，所以需要依靠timerfd这个系统函数统一计时timerfd是一个系统计时函数，当所设置的时间到了，会通过timerfd这个文件描述符进行提示通信，而其他计时函数可能是通过信号量，或者其他方式，但是都没有文件描述符好，并且也可以用timerfd监听。</p>
<p>如何使用timerfd来为所有的计时器计时：timerfd每次都设置在计时器列表中到期时间最近的那个到期时间，这样timerfd到期以后，也就是最近的那个计时器到期，所以每次都是手动重置timerfd的计时时间，为最近的计时器到期时间</p>
<p>内部有channel，和timerfd关联。添加新的Timer后，在超时后，timerfd可读，会处理channel事件，之后调用Timer的回调函数；在timerfd的事件处理后，还有检查一遍超时定时器，如果其属性为重复还有再次添加到定时器集合中。</p>
<p>内部有两种类型的Set</p>
<pre><code>typedef std::pair&lt;Timestamp, Timer*&gt; Entry;

typedef std::set&lt;Entry&gt; TimerList;

typedef std::pair&lt;Timer*, int64_t&gt; ActiveTimer;

typedef std::set&lt;ActiveTimer&gt; ActiveTimerSet;
</code></pre>
<p>TimerQueue.h</p>
<pre><code class="c++">#ifndef MUDUO_NET_TIMERQUEUE_H
#define MUDUO_NET_TIMERQUEUE_H

#include &lt;set&gt;
#include &lt;vector&gt;

#include &lt;boost/noncopyable.hpp&gt;

#include &lt;muduo/base/Mutex.h&gt;
#include &lt;muduo/base/Timestamp.h&gt;
#include &lt;muduo/net/Callbacks.h&gt;
#include &lt;muduo/net/Channel.h&gt;

namespace muduo &#123;
    namespace net &#123;

        class EventLoop;

        class Timer;

        class TimerId;

///
/// A best efforts timer queue.
/// No guarantee that the callback will be on time.
///
        class TimerQueue : boost::noncopyable &#123;
        public:
            TimerQueue(EventLoop *loop);

            ~TimerQueue();

            ///
            /// Schedules the callback to be run at given time,
            /// repeats if @c interval &gt; 0.0.
            ///
            /// Must be thread safe. Usually be called from other threads.
            // 一定是线程安全的，可以跨线程调用。通常情况下被其它线程调用。
            TimerId addTimer(const TimerCallback &amp;cb,
                             Timestamp when,
                             double interval);

            void cancel(TimerId timerId);

        private:

            // FIXME: use unique_ptr&lt;Timer&gt; instead of raw pointers.
            // unique_ptr是C++ 11标准的一个独享所有权的智能指针
            // 无法得到指向同一对象的两个unique_ptr指针
            // 但可以进行移动构造与移动赋值操作，即所有权可以移动到另一个对象（而非拷贝构造）
            typedef std::pair&lt;Timestamp, Timer *&gt; Entry;
            typedef std::set &lt;Entry&gt; TimerList;
            typedef std::pair&lt;Timer *, int64_t&gt; ActiveTimer;
            typedef std::set &lt;ActiveTimer&gt; ActiveTimerSet;
            //set中存储的是pair类型，那么默认先按照pair的第一个元素排序，如果相同，再按照第二个元素排序。
            //所以这两种set都是存放定时器的列表，但是一个根据定时器的到时时间来存储，
            //一个根据定时器地址来存储，但是存储的定时器都是同一个，目的是为了区分同一到期时间的定时器？？？

            // 以下成员函数只可能在其所属的I/O线程中调用，因而不必加锁。
            // 服务器性能杀手之一是锁竞争，所以要尽可能少用锁
            void addTimerInLoop(Timer *timer);

            void cancelInLoop(TimerId timerId);

            // called when timerfd alarms
            void handleRead();//timerfdChannel_的读函数
            // move out all expired timers
            // 返回超时的定时器列表
            std::vector &lt;Entry&gt; getExpired(Timestamp now);

            void reset(const std::vector &lt;Entry&gt; &amp;expired, Timestamp now);

            bool insert(Timer *timer);

            EventLoop *loop_;        // 所属EventLoop
            const int timerfd_;
            //过一段事件，就筛选一次，看看TimerList中有多少定时器到时间了，就处理一下，但是这样延迟很高，不太理解
            Channel timerfdChannel_;//与timefd绑定
            // Timer list sorted by expiration
            TimerList timers_;    // timers_是按到期时间排序，也是存放未到时间的定时器

            // for cancel()
            // timers_与activeTimers_保存的是相同的数据
            // timers_是按到期时间排序，activeTimers_是按对象地址排序
            ActiveTimerSet activeTimers_;//还未到时间的定时器,这里面存放的定时器是和timers_一样的，只是顺序不同
            bool callingExpiredTimers_; /* atomic *///是否在处理过期定时器的标志
            ActiveTimerSet cancelingTimers_;    // 保存的是被取消的定时器
            // 用这个列表的作用是，当出现一个循环的计时器被取消时，就要通过reset函数中对
            //ActiveTimerSet列表来暂停对这个计时器的重置
        &#125;;

    &#125;
&#125;
#endif  // MUDUO_NET_TIMERQUEUE_H
</code></pre>
<p>TimerQueue.cc</p>
<pre><code class="c++">#define __STDC_LIMIT_MACROS

#include &lt;muduo/net/TimerQueue.h&gt;

#include &lt;muduo/base/Logging.h&gt;
#include &lt;muduo/net/EventLoop.h&gt;
#include &lt;muduo/net/Timer.h&gt;
#include &lt;muduo/net/TimerId.h&gt;

#include &lt;boost/bind.hpp&gt;

#include &lt;sys/timerfd.h&gt;

namespace muduo &#123;
    namespace net &#123;
        namespace detail &#123;

            // 创建定时器
            int createTimerfd() &#123;
                int timerfd = ::timerfd_create(CLOCK_MONOTONIC,
                                               TFD_NONBLOCK | TFD_CLOEXEC);//CLOCK_MONOTONIC参数表明计时器的时间是从系统打开开始计时的
                //CLOCK_MONOTONIC表示的是时间类型
                if (timerfd &lt; 0) &#123;
                    LOG_SYSFATAL &lt;&lt; &quot;Failed in timerfd_create&quot;;
                &#125;
                return timerfd;
            &#125;

            // 计算超时时刻与当前时间的时间差
            struct timespec howMuchTimeFromNow(Timestamp when) &#123;
                int64_t microseconds = when.microSecondsSinceEpoch()
                                       - Timestamp::now().microSecondsSinceEpoch();
                if (microseconds &lt; 100) &#123;
                    microseconds = 100;
                &#125;
                struct timespec ts;
                ts.tv_sec = static_cast&lt;time_t&gt;(
                        microseconds / Timestamp::kMicroSecondsPerSecond);
                ts.tv_nsec = static_cast&lt;long&gt;(
                        (microseconds % Timestamp::kMicroSecondsPerSecond) * 1000);
                return ts;
            &#125;

            // 清除定时器，避免一直触发//处理超时事件。超时后，timerfd变为可读
            void readTimerfd(int timerfd, Timestamp now) &#123;
                uint64_t howmany;
                ssize_t n = ::read(timerfd, &amp;howmany, sizeof howmany);
                LOG_TRACE &lt;&lt; &quot;TimerQueue::handleRead() &quot; &lt;&lt; howmany &lt;&lt; &quot; at &quot; &lt;&lt; now.toString();
                if (n != sizeof howmany) &#123;
                    LOG_ERROR &lt;&lt; &quot;TimerQueue::handleRead() reads &quot; &lt;&lt; n &lt;&lt; &quot; bytes instead of 8&quot;;
                &#125;
            &#125;

            // 重置定时器的超时时间（不是周期性的定时器，时间到expiration就结束了）
            // 在这里面itimerspec.it_interval都是设置的0，每次都是计时结束以后手动重新设置，然后再计时的。
            void resetTimerfd(int timerfd, Timestamp expiration) &#123;
                // wake up loop by timerfd_settime()
                struct itimerspec newValue;
                struct itimerspec oldValue;
                bzero(&amp;newValue, sizeof newValue);
                bzero(&amp;oldValue, sizeof oldValue);
                newValue.it_value = howMuchTimeFromNow(expiration);
                int ret = ::timerfd_settime(timerfd, 0, &amp;newValue, &amp;oldValue);
                if (ret) &#123;
                    LOG_SYSERR &lt;&lt; &quot;timerfd_settime()&quot;;
                &#125;
            &#125;

        &#125;
    &#125;
&#125;

using namespace muduo;
using namespace muduo::net;
using namespace muduo::net::detail;

TimerQueue::TimerQueue(EventLoop *loop)
        : loop_(loop),
          timerfd_(createTimerfd()),
          timerfdChannel_(loop, timerfd_),//timerfd相关的channel
          timers_(),
          callingExpiredTimers_(false) &#123;
    timerfdChannel_.setReadCallback(
            boost::bind(&amp;TimerQueue::handleRead, this));
    // we are always reading the timerfd, we disarm it with timerfd_settime.
    timerfdChannel_.enableReading();//设置关注读事件，并且加入epoll队列
&#125;

TimerQueue::~TimerQueue() &#123;
    ::close(timerfd_);
    // do not remove channel, since we&#39;re in EventLoop::dtor();
    for (TimerList::iterator it = timers_.begin();
         it != timers_.end(); ++it) &#123;
        delete it-&gt;second;
    &#125;
&#125;

TimerId TimerQueue::addTimer(const TimerCallback &amp;cb,
                             Timestamp when,
                             double interval)//创建并增加Timer进队列中
&#123;
    Timer *timer = new Timer(cb, when, interval);

    loop_-&gt;runInLoop(
            boost::bind(&amp;TimerQueue::addTimerInLoop, this, timer));

    //addTimerInLoop(timer);
    return TimerId(timer, timer-&gt;sequence());
&#125;

void TimerQueue::cancel(TimerId timerId)//取消
&#123;
    loop_-&gt;runInLoop(
            boost::bind(&amp;TimerQueue::cancelInLoop, this, timerId));
    //cancelInLoop(timerId);
&#125;

void TimerQueue::addTimerInLoop(Timer *timer) &#123;
    loop_-&gt;assertInLoopThread();
    // 插入一个定时器，有可能会使得最早到期的定时器发生改变
    bool earliestChanged = insert(timer);

    if (earliestChanged) &#123;
        // 重置timefd定时器的超时时刻(timerfd_settime)
        resetTimerfd(timerfd_, timer-&gt;expiration());
    &#125;
&#125;

void TimerQueue::cancelInLoop(TimerId timerId)//取消的回调函数
//取消计时器，就是把该计时器从两个队列中删除，
//现在有一种特殊情况，就是如果刚好在处理定时器的过程中，并且这个要取消的定时器就是在被处理的，并且是循环定时器，那么如果不加入cancelingTimers_列表
//就会出现，在重置时又把这个定时器重启了，但是这个定时器应该是要被取消的
&#123;
    loop_-&gt;assertInLoopThread();
    assert(timers_.size() == activeTimers_.size());
    ActiveTimer timer(timerId.timer_, timerId.sequence_);
    // 查找该定时器
    ActiveTimerSet::iterator it = activeTimers_.find(timer);
    if (it != activeTimers_.end()) &#123;
        size_t n = timers_.erase(Entry(it-&gt;first-&gt;expiration(), it-&gt;first));
        assert(n == 1);
        (void) n;
        delete it-&gt;first; // FIXME: no delete please,如果用了unique_ptr,这里就不需要手动删除了
        activeTimers_.erase(it);
    &#125;//用activeTimers_列表来搜索，然后找到先删除timers_，再删除activeTimers_
    else if (callingExpiredTimers_)
        //如果在未到时间的定时器中没有找到，并且线程正在处理过期的定时器，那么可能这个定时器正在被处理，就将这些定时器放到cancelingTimers_数组中
    &#123;
        // 已经到期，并且正在调用回调函数的定时器，为了在重置时，避免被重置，而是被忽略
        cancelingTimers_.insert(timer);
    &#125;
    assert(timers_.size() == activeTimers_.size());
&#125;

void TimerQueue::handleRead()//TimerChannel的回调函数，也就是当timefd定时器到时的时候，就会调用这个函数
&#123;
    loop_-&gt;assertInLoopThread();
    Timestamp now(Timestamp::now());
    readTimerfd(timerfd_, now);        // 清除该事件，避免一直触发

    // 获取该时刻之前所有的定时器列表(即超时定时器列表)
    std::vector &lt;Entry&gt; expired = getExpired(now);

    callingExpiredTimers_ = true;//处理到期的定时器
    cancelingTimers_.clear();//每次处理前，把要取消的定时器列表清空
    // safe to callback outside critical section
    for (std::vector&lt;Entry&gt;::iterator it = expired.begin();
         it != expired.end(); ++it) &#123;
        // 这里回调定时器timer处理函数
        it-&gt;second-&gt;run();
    &#125;
    callingExpiredTimers_ = false;

    // 不是一次性定时器，需要重启
    reset(expired, now);//如果之前处理定时器回调函数时间较长，那么在这段时间中，已经有定时器到期了，轻则产生延迟，重则
&#125;

// rvo
std::vector &lt;TimerQueue::Entry&gt; TimerQueue::getExpired(Timestamp now)//得到已经过期的计时器
&#123;
    assert(timers_.size() == activeTimers_.size());
    std::vector &lt;Entry&gt; expired;//存放已经过期的定时器
    Entry sentry(now, reinterpret_cast&lt;Timer *&gt;(UINTPTR_MAX));//我理解是找了一个指针可以取到的最大数，为了避免和其他指针冲突，
    //因为这个指针没有什么意义，仅仅是为了构成一个Entry结构体，有意义的是第一个元素now

    // 返回第一个未到期的Timer的迭代器
    // lower_bound的含义是返回第一个值&gt;=sentry的元素的iterator
    // 即*end &gt;= sentry，从而end-&gt;first &gt; now
    TimerList::iterator end = timers_.lower_bound(sentry);
    assert(end == timers_.end() || now &lt; end-&gt;first);
    // 将到期的定时器插入到expired中
    std::copy(timers_.begin(), end, back_inserter(expired));//back_inserter是迭代器的一种操作，效果和expired.push_back()一样
    // 从timers_中移除到期的定时器
    timers_.erase(timers_.begin(), end);

    // 从activeTimers_中移除到期的定时器
    for (std::vector&lt;Entry&gt;::iterator it = expired.begin();
         it != expired.end(); ++it) &#123;
        ActiveTimer timer(it-&gt;second, it-&gt;second-&gt;sequence());
        size_t n = activeTimers_.erase(timer);
        assert(n == 1);
        (void) n;//避免编译器出现变量n未使用的警告？？？
    &#125;

    assert(timers_.size() == activeTimers_.size());
    return expired;
&#125;

void TimerQueue::reset(const std::vector &lt;Entry&gt; &amp;expired, Timestamp now)//重启两种定时器，一种是timefd，另外一种是定时器列表中需要重复的定时器
&#123;
    Timestamp nextExpire;
    //重启定时器列表中过期的定时器，如果需要重复的话
    for (std::vector&lt;Entry&gt;::const_iterator it = expired.begin();
         it != expired.end(); ++it) &#123;
        ActiveTimer timer(it-&gt;second, it-&gt;second-&gt;sequence());
        // 如果是重复的定时器并且是未取消定时器，则重启该定时器
        if (it-&gt;second-&gt;repeat()
            &amp;&amp; cancelingTimers_.find(timer) == cancelingTimers_.end()) &#123;
            it-&gt;second-&gt;restart(now);
            insert(it-&gt;second);
        &#125; else//不需要重复就删除这个定时器
        &#123;
            // 一次性定时器或者已被取消的定时器是不能重置的，因此删除该定时器
            // FIXME move to a free list
            delete it-&gt;second; // FIXME: no delete please
        &#125;
    &#125;
    //重启timefd，设置的时间就是定时器列表中最快到期的时间
    if (!timers_.empty()) &#123;
        // 获取最早到期的定时器超时时间
        nextExpire = timers_.begin()-&gt;second-&gt;expiration();
    &#125;

    if (nextExpire.valid()) &#123;
        // 重置定时器的超时时刻(timerfd_settime)
        resetTimerfd(timerfd_, nextExpire);
    &#125;
&#125;

bool TimerQueue::insert(Timer *timer)//把定时器插入到timers_和activeTimers_队列中去
&#123;
    loop_-&gt;assertInLoopThread();
    assert(timers_.size() == activeTimers_.size());
    // 最早到期时间是否改变
    bool earliestChanged = false;//这个变量的意义是显示最早到期时间是否改变，通俗点说就是这个插入的定时器的位置在timers_的
    //首位，也就是这个插入的定时器的到期时间是timers_中已经存储的定时器中最早的，那么这个标志位就会置true
    Timestamp when = timer-&gt;expiration();//超时时刻
    TimerList::iterator it = timers_.begin();
    // 如果timers_为空或者when小于timers_中的最早到期时间
    if (it == timers_.end() || when &lt; it-&gt;first) &#123;
        earliestChanged = true;//表示定时器最早，所以置true
    &#125;
    //要分别插入到两个set中
    &#123;
        // 插入到timers_中
        std::pair&lt;TimerList::iterator, bool&gt; result
                = timers_.insert(Entry(when, timer));
        assert(result.second);
        (void) result;
    &#125;
    &#123;
        // 插入到activeTimers_中
        std::pair&lt;ActiveTimerSet::iterator, bool&gt; result
                = activeTimers_.insert(ActiveTimer(timer, timer-&gt;sequence()));
        assert(result.second);
        (void) result;
    &#125;

    assert(timers_.size() == activeTimers_.size());
    return earliestChanged;//返回最早到期的时间有没有改变
&#125;
</code></pre>
<h3 id="EventLoop"><a href="#EventLoop" class="headerlink" title="EventLoop"></a>EventLoop</h3><p><code>EventLoop</code> 整合了 <code>Channel</code> 和 <code>Poller</code> 提供更方便的接口来使用，主要功能为：处理 <code>Channel</code>、处理定时事件、处理任务事件。主要接口如下：</p>
<pre><code class="c++">class EventLoop : noncopyable
&#123;
 public:
  // EventLoop
  void loop();
  void quit();

  // 任务事件
  void wakeup();
  void runInLoop(Functor cb);
  void queueInLoop(Functor cb);

  // 定时器
  TimerId runAt(Timestamp time, TimerCallback cb);
  TimerId runAfter(double delay, TimerCallback cb);
  TimerId runEvery(double interval, TimerCallback cb);
  void cancel(TimerId timerId);

  // 处理 Channel
  void updateChannel(Channel* channel);
  void removeChannel(Channel* channel);
  bool hasChannel(Channel* channel);
&#125;;
</code></pre>
<p><code>EventLoop</code> 的用法是先注册 <code>Channel</code>，如 <code>listening fd</code>，然后调用 <code>loop()</code> 一直循环处理各种任务，在 <code>loop</code> 中可以注册新的 <code>Channel</code>、定时事件和任务事件：</p>
<pre><code>void EventLoop::loop()
&#123;
  while (!quit_)
  &#123;
    activeChannels_.clear();
    pollReturnTime_ = poller_-&gt;poll(kPollTimeMs, &amp;activeChannels_);
    for (Channel* channel : activeChannels_)
    &#123;
      currentActiveChannel_ = channel;
      currentActiveChannel_-&gt;handleEvent(pollReturnTime_);
    &#125;
    doPendingFunctors();
  &#125;
&#125;
</code></pre>
<p>先来说任务事件，使用场景主要是其他线程想要在 <code>EventLoop</code> 线程做些工作，比如 <code>EventLoop</code> 线程把耗时的任务放到 <code>threadpool</code> 中执行，完成后通知 <code>EventLoop</code> 线程获取结果。 最常见的实现方式是用 <code>pipe(2)</code>：<code>EventLoop</code> 注册读事件，其他线程把结果保存在队列中，然后写 <code>pipe</code>，<code>EventLoop</code> 线程就会唤醒处理。<code>Muduo</code> 也是类似实现，只是用 <code>eventfd(2)</code> 来唤醒。</p>
<h2 id="一个简单的例子"><a href="#一个简单的例子" class="headerlink" title="一个简单的例子"></a>一个简单的例子</h2><p>首先从最简单的 echo server 入手，来介绍 muduo 的基本使用，同时也方便后面概念的理解。</p>
<pre><code class="cpp">void onMessage(const muduo::net::TcpConnectionPtr&amp; conn,
                           muduo::net::Buffer* buf,
                           muduo::Timestamp time)
&#123;
  conn-&gt;send(buf);
&#125;

int main()
&#123;
    muduo::net::EventLoop loop;
    muduo::net::InetAddress listenAddr(2007);
    TcpServer server(&amp;loop, listenAddr);
    server.setMessageCallback(onMessage);
    server.start();
    loop.loop();
&#125;
</code></pre>
<p>echo-server 的代码量非常简洁。一个典型的 muduo 的 TcpServer 工作流程如下：</p>
<ol>
<li>建立一个事件循环器 EventLoop(reactor)</li>
<li>建立对应的业务服务器 TcpServer，并指定它的reactor和地址</li>
<li>设置 TcpServer 的 Callback</li>
<li>启动 server</li>
<li>开启事件循环</li>
</ol>
<p>陈硕认为，TCP 网络编程的本质是处理三个半事件，即：</p>
<ol>
<li>连接的建立</li>
<li>连接的断开：包括主动断开和被动断开</li>
<li>消息到达，文件描述符可读。</li>
<li>消息发送完毕。这个算半个事件。</li>
</ol>
<p>我们接下来分析下 muduo 是怎么处理和实现这三个半事件的</p>
<h2 id="连接的建立"><a href="#连接的建立" class="headerlink" title="连接的建立"></a>连接的建立</h2><p>在我们单纯使用 linux 的 API，编写一个简单的 Tcp 服务器时，建立一个新的连接通常需要四步：</p>
<blockquote>
<p>步骤 1. socket() &#x2F;&#x2F; 调用 socket 函数建立监听 socket<br>步骤 2. bind() &#x2F;&#x2F; 绑定地址和端口<br>步骤 3. listen() &#x2F;&#x2F; 开始监听端口<br>步骤 4. accept() &#x2F;&#x2F; 返回新建立连接的 fd</p>
</blockquote>
<p>我们接下来分析下，这四个步骤在 muduo 中都是何时进行的：</p>
<p>首先在 TcpServer 对象构建时，TcpServer 的属性 acceptor 同时也被建立。<br>在 Acceptor 的构造函数中分别调用了 socket 函数和 bind 函数完成了 <strong>步骤 1</strong>和<strong>步骤 2</strong>。<br>即，当 <code>TcpServer server(&amp;loop, listenAddr)</code> 执行结束时，监听 socket 已经建立好，并已绑定到对应地址和端口了。</p>
<p>而当执行 <code>server.start()</code> 时，主要做了两个工作：</p>
<ol>
<li>在监听 socket 上启动 listen 函数，也就是 <strong>步骤 3</strong>；</li>
<li>将监听 socket 的可读事件注册到 EventLoop 中。</li>
</ol>
<p>此时，程序已完成对socket的监听，但还不够，因为此时程序的主角 <code>EventLoop</code> 尚未启动。<br>当调用 <code>loop.loop()</code> 时，程序开始循环监听该 socket 的可读事件。</p>
<p>当新连接请求建立时，可读事件触发，此时该事件对应的 callback 在 EventLoop::loop() 中被调用。<br>该事件的 callback 实际上就是 Acceptor::handleRead() 方法。</p>
<p>在 Acceptor::handleRead() 方法中，做了三件事：</p>
<ol>
<li>调用了 accept 函数，完成了 <strong>步骤 4</strong>，实现了连接的建立。得到一个已连接 socket 的 fd。</li>
<li>创建 TcpConnection 对象。</li>
<li>将已连接 socket 的可读事件注册到 EventLoop 中。</li>
</ol>
<p>这里还有一个需要注意的点，创建的 TcpConnnection 对象是个 shared_ptr，该对象会被保存在 TcpServer 的 connections 中。这样才能保证引用计数大于 0，对象不被释放。</p>
<p>至此，一个新的连接已完全建立好，该连接的socket可读事件也已注册到 EventLoop 中了。</p>
<h2 id="消息的读取"><a href="#消息的读取" class="headerlink" title="消息的读取"></a>消息的读取</h2><p>上节讲到，在新连接建立的时候，会将新连接的 socket 的可读事件注册到 EventLoop 中。<br>假如客户端发送消息，导致已连接 socket 的可读事件触发，该事件对应的 callback 同样也会在 EventLoop::loop() 中被调用。</p>
<p>该事件的 callback 实际上就是 TcpConnection::handleRead 方法。<br>在 TcpConnection::handleRead 方法中，主要做了两件事：</p>
<ol>
<li>从 socket 中读取数据，并将其放入 inputbuffer 中</li>
<li>调用 messageCallback，执行业务逻辑。</li>
</ol>
<pre><code class="c++">ssize_t n = inputBuffer_.readFd(channel_-&gt;fd(), &amp;savedErrno);
if (n&gt; 0)
&#123;
    messageCallback_(shared_from_this(), &amp;inputBuffer_, receiveTime);
&#125;
</code></pre>
<p>messageCallback 是在建立新连接时，将 <code>TcpServer::messageCallback</code> 方法 bind 到了 <code>TcpConnection::messageCallback</code> 的方法。</p>
<p><code>TcpServer::messageCallback</code> 就是业务逻辑的主要实现函数。通常情况下，我们可以在里面实现消息的编解码、消息的分发等工作，这里就不再深入探讨了。</p>
<p>在我们上面给出的示例代码中，echo-server 的 messageCallback 非常简单，就是直接将得到的数据，重新 send 回去。在实际的业务处理中，一般都会调用 TcpConnection::send() 方法，给客户端回复消息。</p>
<p>这里需要注意的是，在 messageCallback 中，用户会有可能会把任务抛给自定义的 Worker 线程池处理。<br>但是这个在 Worker 线程池中任务，<strong>切忌直接对 Buffer 的操作</strong>。因为 Buffer 并不是线程安全的。</p>
<p>我们需要记住一个准则:</p>
<blockquote>
<p><strong>所有对 IO 和 buffer 的读写，都应该在 IO 线程中完成。</strong></p>
</blockquote>
<p>一般情况下，先在交给 Worker 线程池之前，应该现在 IO 线程中把 Buffer 进行切分解包等动作。将解包后的消息交由线程池处理，避免多个线程操作同一个资源。</p>
<h2 id="消息的发送"><a href="#消息的发送" class="headerlink" title="消息的发送"></a>消息的发送</h2><p>用户通过调用 TcpConnection::send() 向客户端回复消息。由于 muduo 中使用了 OutputBuffer，因此消息的发送过程比较复杂。</p>
<p>首先需要注意的是线程安全问题, 上文说到对于消息的读写必须都在 EventLoop 的同一个线程 (通常称为 IO 线程) 中进行：<br>因此，TcpConnection::send 必须要保证线程安全性，它是这么做的：</p>
<pre><code class="c++">void TcpConnection::send(const StringPiece&amp; message)
&#123;
  if (state_ == kConnected)
  &#123;
    if (loop_-&gt;isInLoopThread())
    &#123;
      sendInLoop(message);
    &#125;
    else
    &#123;
      loop_-&gt;runInLoop(
          boost::bind(&amp;TcpConnection::sendInLoop,
                      this,     // FIXME
                      message.as_string()));
    &#125;
  &#125;
&#125;
</code></pre>
<p>检测 send 的时候，是否在当前 IO 线程，如果是的话，直接进行写相关操作 <code>sendInLoop</code>。<br>如果不在一个线程的话，需要将该任务抛给 IO 线程执行 <code>runInloop</code>, 以保证 write 动作是在 IO 线程中执行的。我们后面会讲解 <code>runInloop</code> 的具体实现。</p>
<p>在 sendInloop 中，做了下面几件事：</p>
<ol>
<li>假如 OutputBuffer 为空，则直接向 socket 写数据</li>
<li>如果向 socket 写数据没有写完，则统计剩余的字节个数，并进行下一步。没有写完可能是因为此时 socket 的 TCP 缓冲区已满了。</li>
<li>如果此时 OutputBuffer 中的旧数据的个数和未写完字节个数之和大于 highWaterMark，则将 highWaterMarkCallback 放入待执行队列中</li>
<li><strong>将对应 socket 的可写事件注册到 EventLoop 中</strong></li>
</ol>
<p>注意：直到发送消息的时候，muduo 才会把 socket 的可写事件注册到了 EventLoop 中。在此之前只注册了可读事件。</p>
<p>连接 socket 的可写事件对应的 callback 是 TcpConnection::handleWrite()<br>当某个 socket 的可写事件触发时，TcpConnection::handleWrite 会做两个工作：</p>
<ol>
<li>尽可能将数据从 OutputBuffer 中向 socket 中 write 数据</li>
<li>如果 OutputBuffer 没有剩余的，则 <strong>将该 socket 的可写事件移除</strong>，并调用 writeCompleteCallback</li>
</ol>
<p><strong>为什么要移除可写事件</strong></p>
<p>因为当 OutputBuffer 中没数据时，我们不需要向 socket 中写入数据。但是此时 socket 一直是处于可写状态的， 这将会导致 TcpConnection::handleWrite() 一直被触发。然而这个触发毫无意义，因为并没有什么可以写的。</p>
<p>所以 muduo 的处理方式是，当 OutputBuffer 还有数据时，socket 可写事件是注册状态。当 OutputBuffer 为空时，则将 socket 的可写事件移除。</p>
<p>此外，highWaterMarkCallback 和 writeCompleteCallback 一般配合使用，起到限流的作用。在《linux 多线程服务器端编程》一书的 8.9.3 一节中有详细讲解。这里就不再赘述了</p>
<h2 id="连接的断开"><a href="#连接的断开" class="headerlink" title="连接的断开"></a>连接的断开</h2><p>我们看下 muduo 对于连接的断开是怎么处理的。<br>连接的断开分为被动断开和主动断开。主动断开和被动断开的处理方式基本一致，因此本文只讲下被动断开的部分。</p>
<p>被动断开即客户端断开了连接，server 端需要感知到这个断开的过程，然后进行的相关的处理。</p>
<p>其中感知远程断开这一步是在 Tcp 连接的可读事件处理函数 <code>handleRead</code> 中进行的：当对 socket 进行 read 操作时，返回值为 0，则说明此时连接已断开。</p>
<p>接下来会做四件事情：</p>
<ol>
<li>将该 TCP 连接对应的事件从 EventLoop 移除</li>
<li>调用用户的 ConnectionCallback</li>
<li>将对应的 TcpConnection 对象从 Server 移除。</li>
<li>close 对应的 fd。此步骤是在析构函数中自动触发的，当 TcpConnection 对象被移除后，引用计数为 0，对象析构时会调用 close。</li>
</ol>
<h2 id="runInLoop-的实现"><a href="#runInLoop-的实现" class="headerlink" title="runInLoop 的实现"></a>runInLoop 的实现</h2><p>在讲解消息的发送过程时候，我们讲到为了保证对 buffer 和 socket 的写动作是在 IO 线程中进行，使用了一个 <code>runInLoop</code> 函数，将该写任务抛给了 IO 线程处理。</p>
<p>我们接下来看下 <code>runInLoop</code> 的实现：</p>
<pre><code class="cpp">void EventLoop::runInLoop(const Functor&amp; cb)
&#123;
  if (isInLoopThread())
  &#123;
    cb();
  &#125;
  else
  &#123;
    queueInLoop(cb);
  &#125;
&#125;
</code></pre>
<p>这里可以看到，做了一层判断。如果调用时是此 EventLoop 的运行线程，则直接执行此函数。<br>否则调用 <code>queueInLoop</code> 函数。我们看下 <code>queueInLoop</code> 的实现。</p>
<pre><code class="cpp">void EventLoop::queueInLoop(const Functor&amp; cb)
&#123;
  &#123;
  MutexLockGuard lock(mutex_);
  pendingFunctors_.push_back(cb);
  &#125;

  if (!isInLoopThread() || callingPendingFunctors_)
  &#123;
    wakeup();
  &#125;
&#125;
</code></pre>
<p>这里有两个动作：</p>
<ol>
<li>加锁，然后将该函数放到该 EventLoop 的 pendingFunctors_队列中。</li>
<li>判断是否要唤醒 EventLoop，如果是则调用 wakeup() 唤醒该 EventLoop。</li>
</ol>
<p>这里有几个问题：</p>
<ul>
<li>为什么要唤醒 EventLoop？</li>
<li>wakeup 是怎么实现的?</li>
<li>pendingFunctors_是如何被消费的?</li>
</ul>
<h3 id="为什么要唤醒-EventLoop"><a href="#为什么要唤醒-EventLoop" class="headerlink" title="为什么要唤醒 EventLoop"></a>为什么要唤醒 EventLoop</h3><p>我们首先调用了 <code>pendingFunctors_.push_back(cb)</code>, 将该函数放在 pendingFunctors_中。EventLoop 的每一轮循环在最后会调用 doPendingFunctors 依次执行这些函数。</p>
<p>而 EventLoop 的唤醒是通过 epoll_wait 实现的，如果此时该 EventLoop 中迟迟没有事件触发，那么 epoll_wait 一直就会阻塞。 这样会导致，pendingFunctors_中的任务迟迟不能被执行了。</p>
<p>所以必须要唤醒 EventLoop ，从而让pendingFunctors_中的任务尽快被执行。</p>
<h3 id="wakeup-是怎么实现的"><a href="#wakeup-是怎么实现的" class="headerlink" title="wakeup 是怎么实现的"></a>wakeup 是怎么实现的</h3><p>muduo 这里采用了对 eventfd 的读写来实现对 EventLoop 的唤醒。</p>
<p>在 EventLoop 建立之后，就创建一个 eventfd，并将其可读事件注册到 EventLoop 中。</p>
<p><code>wakeup()</code> 的过程本质上是对这个 eventfd 进行写操作，以触发该 eventfd 的可读事件。这样就起到了唤醒 EventLoop 的作用。</p>
<pre><code class="cpp">void EventLoop::wakeup()
&#123;
  uint64_t one = 1;
  sockets::write(wakeupFd_, &amp;one, sizeof one);
&#125;
</code></pre>
<p>很多库为了兼容 macOS，往往使用 pipe 来实现这个功能。muduo 采用了 eventfd，性能更好些，但代价是不能支持 macOS 了。不过 muduo 似乎从一开始的定位就不打算支持？</p>
<h3 id="doPendingFunctors-的实现"><a href="#doPendingFunctors-的实现" class="headerlink" title="doPendingFunctors 的实现"></a>doPendingFunctors 的实现</h3><p>本部分讲下 <code>doPendingFunctors</code> 的实现，muduo 是如何处理这些待处理的函数的，以及中间用了哪些优化操作。<br>代码如下所示：</p>
<pre><code class="cpp">void EventLoop::doPendingFunctors()
&#123;
  std::vector&lt;Functor&gt; functors;

  callingPendingFunctors_ = true;

  &#123;
  MutexLockGuard lock(mutex_);
  functors.swap(pendingFunctors_);
  &#125;

  for (size_t i = 0; i &lt; functors.size(); ++i)
  &#123;
    functors[i]();
  &#125;
  callingPendingFunctors_ = false;
&#125;
</code></pre>
<p>从代码可以看到，函数非常简单。大概只有十行代码，但是这十行代码中却有两个非常巧妙的地方。</p>
<ol>
<li><strong>callingPendingFunctors_的作用</strong></li>
</ol>
<p>从代码可以看出，如果 callingPendingFunctors_为 false，则说明此时尚未开始执行 doPendingFunctors 函数。<br>这个有什么作用呢，我们需要结合下 queueInLoop 中，对是否执行 wakeup() 的判断</p>
<pre><code class="none">if (!isInLoopThread() || callingPendingFunctors_)
&#123;
  wakeup();
&#125;
</code></pre>
<p>这里还需要结合下 EventLoop 循环的实现，其中 <code>doPendingFunctors()</code> 是 <strong>每轮循环的最后一步处理</strong>。<br>如果调用 queueInLoop 和 EventLoop 在同一个线程，且 callingPendingFunctors_为 false 时，则说明：<strong>此时尚未执行到 doPendingFunctors()。</strong><br>那么此时即使不用 wakeup，也可以在之后照旧执行 doPendingFunctors() 了。</p>
<p>这么做的好处非常明显，可以减少对 eventfd 的 IO 读写。</p>
<ol>
<li><strong>锁范围的减少</strong><br>在此函数中，有一段特别的代码：</li>
</ol>
<pre><code class="cpp">std::vector&lt;Functor&gt; functors;
&#123;
  MutexLockGuard lock(mutex_);
  functors.swap(pendingFunctors_);
&#125;
</code></pre>
<p>这个作用是 pendingFunctors_和 functors 的内容进行交换，实际上就是此时 functors 持有了 pendingFunctors_的内容，而 pendingFunctors_被清空了。</p>
<p>这个好处是什么呢？<br>如果不这么做，直接遍历 pendingFunctors_, 然后处理对应的函数。这样的话，锁会一直等到所有函数处理完才会被释放。在此期间，queueInLoop 将不可用。</p>
<p>而以上的写法，可以极大减小锁范围，整个锁的持有时间就是 swap 那一下的时间。待处理函数执行的时候，其他线程还是可以继续调用 queueInLoop。</p>

      
       
    </div>
</article>







    




    </div>
    <div class="copyright">
        <p class="footer-entry">
    ©2017 hufei
</p>
<p class="footer-entry">Built with <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/yelog/hexo-theme-3-hexo" target="_blank">3-hexo</a> theme</p>

    </div>
    <div class="full-toc">
        <button class="full" data-title="切换全屏 快捷键 s"><span class="min "></span></button>
<a class="" id="rocket" ></a>

    </div>
</div>

</body>
<script src="/js/jquery.pjax.js?v=1.1.0" ></script>

<script src="/js/script.js?v=1.1.0" ></script>
<script>
    var img_resize = 'default';
    function initArticle() {
        /*渲染对应的表格样式*/
        
            $("#post .pjax table").addClass("green_title");
        

        /*渲染打赏样式*/
        

        /*高亮代码块行号*/
        

        /*访问数量*/
        
        $.getScript("//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js");
        

        /*代码高亮，行号对齐*/
        $('.pre-numbering').css('line-height',$('.has-numbering').css('line-height'));

        
        
    }

    /*打赏页面隐藏与展示*/
    

</script>

<!--加入行号的高亮代码块样式-->

<!--自定义样式设置-->
<style>
    
    
    .nav {
        width: 542px;
    }
    .nav.fullscreen {
        margin-left: -542px;
    }
    .nav-left {
        width: 120px;
    }
    
    
    @media screen and (max-width: 1468px) {
        .nav {
            width: 492px;
        }
        .nav.fullscreen {
            margin-left: -492px;
        }
        .nav-left {
            width: 100px;
        }
    }
    
    
    @media screen and (max-width: 1024px) {
        .nav {
            width: 492px;
            margin-left: -492px
        }
        .nav.fullscreen {
            margin-left: 0;
        }
    }
    
    @media screen and (max-width: 426px) {
        .nav {
            width: 100%;
        }
        .nav-left {
            width: 100%;
        }
    }
    
    
    .nav-right .title-list nav a .post-title, .nav-right .title-list #local-search-result a .post-title {
        color: #383636;
    }
    
    
    .nav-right .title-list nav a .post-date, .nav-right .title-list #local-search-result a .post-date {
        color: #5e5e5f;
    }
    
    
    .nav-right nav a.hover, #local-search-result a.hover{
        background-color: #e2e0e0;
    }
    
    

    /*列表样式*/
    

    /* 背景图样式 */
    
    


    /*引用块样式*/
    

    /*文章列表背景图*/
    

    
</style>







</html>
