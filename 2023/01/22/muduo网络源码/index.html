<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0"><title>Hexo | Hexo</title><meta name="author" content="John Doe"><meta name="copyright" content="John Doe"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="muduo网络源码学到的东西：tie延长生命周期；vector的首指针可以直接代替数组首指针； 各个类详解channelChannel类封装了poll&#x2F;epoll中的 I&#x2F;O 事件(epoll_event)和事件对应的回调函数，不拥有 fd，可以代表多种实体：listening fd、timer fd、event fd 等。 每个Channel对象自始至终只属于一个EventLoop，因">
<meta property="og:type" content="article">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/2023/01/22/muduo%E7%BD%91%E7%BB%9C%E6%BA%90%E7%A0%81/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="muduo网络源码学到的东西：tie延长生命周期；vector的首指针可以直接代替数组首指针； 各个类详解channelChannel类封装了poll&#x2F;epoll中的 I&#x2F;O 事件(epoll_event)和事件对应的回调函数，不拥有 fd，可以代表多种实体：listening fd、timer fd、event fd 等。 每个Channel对象自始至终只属于一个EventLoop，因">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png">
<meta property="article:published_time" content="2023-01-22T03:54:01.949Z">
<meta property="article:modified_time" content="2022-12-31T15:58:03.612Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2023/01/22/muduo%E7%BD%91%E7%BB%9C%E6%BA%90%E7%A0%81/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: 'Just',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Hexo',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-12-31 23:58:03'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = url => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      link.onload = () => resolve()
      link.onerror = () => reject()
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">40</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">0</div></a></div><hr/></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="Hexo"><span class="site-name">Hexo</span></a></span><div id="menus"><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">No title</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2023-01-22T03:54:01.949Z" title="Created 2023-01-22 11:54:01">2023-01-22</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2022-12-31T15:58:03.612Z" title="Updated 2022-12-31 23:58:03">2022-12-31</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post View:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="muduo网络源码"><a href="#muduo网络源码" class="headerlink" title="muduo网络源码"></a>muduo网络源码</h1><p>学到的东西：tie延长生命周期；vector的首指针可以直接代替数组首指针；</p>
<h2 id="各个类详解"><a href="#各个类详解" class="headerlink" title="各个类详解"></a>各个类详解</h2><h3 id="channel"><a href="#channel" class="headerlink" title="channel"></a>channel</h3><p>Channel类封装了poll&#x2F;epoll中的 <code>I/O</code> 事件(epoll_event)和事件对应的回调函数，不拥有 <code>fd</code>，可以代表多种实体：<code>listening fd</code>、<code>timer fd</code>、<code>event fd</code> 等。</p>
<p>每个Channel对象自始至终只属于一个EventLoop，因此每个Channel对象都只属于某一个IO线程。</p>
<p>每个Channel对象自始至终只负责一个文件描述符（fd）的IO事件分发，但它并不拥有这个fd，也不会在析构的时候关闭这个fd。</p>
<p>Muduo用户一般不直接使用Channel，而会使用更上层的封装，如TcpConnection。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Channel</span> : noncopyable</span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">typedef</span> std::function&lt;<span class="type">void</span>()&gt; EventCallback;</span><br><span class="line">  <span class="keyword">typedef</span> std::function&lt;<span class="type">void</span>(Timestamp)&gt; ReadEventCallback;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">Channel</span>(EventLoop* loop, <span class="type">int</span> fd);</span><br><span class="line">  ~<span class="built_in">Channel</span>();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">handleEvent</span><span class="params">(Timestamp receiveTime)</span></span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> kNoneEvent;</span><br><span class="line">  <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> kReadEvent;</span><br><span class="line">  <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> kWriteEvent;</span><br><span class="line"></span><br><span class="line">  EventLoop* loop_;</span><br><span class="line">  <span class="type">const</span> <span class="type">int</span>  fd_;</span><br><span class="line">  <span class="type">int</span>        events_;</span><br><span class="line">  <span class="type">int</span>        revents_; <span class="comment">// it&#x27;s the received event types of epoll or poll</span></span><br><span class="line">  <span class="type">int</span>        index_; <span class="comment">// used by Poller.</span></span><br><span class="line"></span><br><span class="line">  ReadEventCallback readCallback_;</span><br><span class="line">  EventCallback writeCallback_;</span><br><span class="line">  EventCallback closeCallback_;</span><br><span class="line">  EventCallback errorCallback_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>events_</code> 是 <code>Channel</code> 关心的事件，<code>Poller</code> 根据这个来设置。<code>revents_</code> 是 <code>Poller</code> 返回的已就绪的事件，<code>handleEvent()</code> 会调用相应的 <code>callback</code> 来处理。</p>
<p>所有需要由 <code>EventLoop</code> 处理的如 <code>Acceptor</code>、<code>TcpConnection</code> 都有 <code>Channel</code> 成员并设置 <code>callback</code> 注册到 <code>EventLoop</code> 中。<code>Muduo</code> 的 <code>callback</code> 基本都是 <code>member function</code>， 用 <code>std::bind()</code> 绑定 <code>this</code> 指针来注册，一些网络库会采用继承接口类来实现回调的注册。</p>
<p><strong>源码分析</strong></p>
<p>Channel.h源码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> MUDUO_NET_CHANNEL_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MUDUO_NET_CHANNEL_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/function.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/noncopyable.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/shared_ptr.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/weak_ptr.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;muduo/base/Timestamp.h&gt;</span></span></span><br><span class="line"><span class="comment">/*个人理解：channel是一个具体来处理事件的类，它与eventloop关系紧密，主要是根据事件宏定义来调用对应的回调函数</span></span><br><span class="line"><span class="comment"> *主要的事件有三种，读事件，写事件和结束事件</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">namespace</span> muduo &#123;</span><br><span class="line">    <span class="keyword">namespace</span> net &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">class</span> <span class="title class_">EventLoop</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// A selectable I/O channel.</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// This class doesn&#x27;t own the file descriptor.</span></span><br><span class="line"><span class="comment">/// The file descriptor could be a socket,</span></span><br><span class="line"><span class="comment">/// an eventfd, a timerfd, or a signalfd</span></span><br><span class="line">        <span class="keyword">class</span> <span class="title class_">Channel</span> : boost::noncopyable &#123;</span><br><span class="line">        <span class="keyword">public</span>:</span><br><span class="line">            <span class="keyword">typedef</span> boost::function&lt;<span class="type">void</span>()&gt; EventCallback;</span><br><span class="line">            <span class="keyword">typedef</span> boost::function&lt;<span class="type">void</span>(Timestamp)&gt; ReadEventCallback;<span class="comment">//读事件的回调函数中必须有参数Timestamp</span></span><br><span class="line"></span><br><span class="line">            <span class="built_in">Channel</span>(EventLoop *loop, <span class="type">int</span> fd);<span class="comment">//一个channel要绑定一个EventLoop和一个文件描述符，但channel无权操作fd</span></span><br><span class="line">            ~<span class="built_in">Channel</span>();</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="type">void</span> <span class="title">handleEvent</span><span class="params">(Timestamp receiveTime)</span></span>;<span class="comment">//处理事件</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">//设置四种事件的回调函数</span></span><br><span class="line">            <span class="function"><span class="type">void</span> <span class="title">setReadCallback</span><span class="params">(<span class="type">const</span> ReadEventCallback &amp;cb)</span> </span>&#123; readCallback_ = cb; &#125;</span><br><span class="line">            <span class="function"><span class="type">void</span> <span class="title">setWriteCallback</span><span class="params">(<span class="type">const</span> EventCallback &amp;cb)</span> </span>&#123; writeCallback_ = cb; &#125;</span><br><span class="line">            <span class="function"><span class="type">void</span> <span class="title">setCloseCallback</span><span class="params">(<span class="type">const</span> EventCallback &amp;cb)</span> </span>&#123; closeCallback_ = cb; &#125;</span><br><span class="line">            <span class="function"><span class="type">void</span> <span class="title">setErrorCallback</span><span class="params">(<span class="type">const</span> EventCallback &amp;cb)</span> </span>&#123; errorCallback_ = cb; &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/// Tie this channel to the owner object managed by shared_ptr,</span></span><br><span class="line">            <span class="comment">/// prevent the owner object being destroyed in handleEvent.</span></span><br><span class="line">            <span class="comment">//这个函数，用于延长某些对象的生命期，使其寿命长过Channel::handleEvent()函数。</span></span><br><span class="line">            <span class="function"><span class="type">void</span> <span class="title">tie</span><span class="params">(<span class="type">const</span> boost::shared_ptr&lt;<span class="type">void</span>&gt; &amp;)</span></span>;<span class="comment">//将一个shared_ptr指针的值赋给tie_</span></span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="type">int</span> <span class="title">fd</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> fd_; &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="type">int</span> <span class="title">events</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> events_; &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="type">void</span> <span class="title">set_revents</span><span class="params">(<span class="type">int</span> revt)</span> </span>&#123; revents_ = revt; &#125; <span class="comment">// used by pollers</span></span><br><span class="line">            <span class="comment">// int revents() const &#123; return revents_; &#125;</span></span><br><span class="line">            <span class="function"><span class="type">bool</span> <span class="title">isNoneEvent</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> events_ == kNoneEvent; &#125;<span class="comment">//判断事件是否为0，也就是没有关注的事件</span></span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="type">void</span> <span class="title">enableReading</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                events_ |= kReadEvent;</span><br><span class="line">                <span class="built_in">update</span>();</span><br><span class="line">            &#125;<span class="comment">//设置读事件，并将当前channel加入到poll队列当中</span></span><br><span class="line">            <span class="comment">// void disableReading() &#123; events_ &amp;= ~kReadEvent; update(); &#125;</span></span><br><span class="line">            <span class="function"><span class="type">void</span> <span class="title">enableWriting</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                events_ |= kWriteEvent;</span><br><span class="line">                <span class="built_in">update</span>();</span><br><span class="line">            &#125;<span class="comment">//设置写事件，并将当前channel加入到poll队列当中</span></span><br><span class="line">            <span class="function"><span class="type">void</span> <span class="title">disableWriting</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                events_ &amp;= ~kWriteEvent;</span><br><span class="line">                <span class="built_in">update</span>();</span><br><span class="line">            &#125;<span class="comment">//关闭写事件，并将当前channel加入到poll队列当中</span></span><br><span class="line">            <span class="function"><span class="type">void</span> <span class="title">disableAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                events_ = kNoneEvent;</span><br><span class="line">                <span class="built_in">update</span>();</span><br><span class="line">            &#125;<span class="comment">//关闭所有事件，并暂时删除当前channel</span></span><br><span class="line">            <span class="function"><span class="type">bool</span> <span class="title">isWriting</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> events_ &amp; kWriteEvent; &#125;<span class="comment">//是否关注写事件</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// for Poller</span></span><br><span class="line">            <span class="function"><span class="type">int</span> <span class="title">index</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> index_; &#125;<span class="comment">//返回序号</span></span><br><span class="line">            <span class="function"><span class="type">void</span> <span class="title">set_index</span><span class="params">(<span class="type">int</span> idx)</span> </span>&#123; index_ = idx; &#125;<span class="comment">//设置序号</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// for debug</span></span><br><span class="line">            <span class="function">string <span class="title">reventsToString</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="type">void</span> <span class="title">doNotLogHup</span><span class="params">()</span> </span>&#123; logHup_ = <span class="literal">false</span>; &#125;<span class="comment">//把挂起标志位置false</span></span><br><span class="line"></span><br><span class="line">            <span class="function">EventLoop *<span class="title">ownerLoop</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> loop_; &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="type">void</span> <span class="title">remove</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span>:</span><br><span class="line">            <span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="type">void</span> <span class="title">handleEventWithGuard</span><span class="params">(Timestamp receiveTime)</span></span>;</span><br><span class="line"></span><br><span class="line">            <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> kNoneEvent;</span><br><span class="line">            <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> kReadEvent;</span><br><span class="line">            <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> kWriteEvent;</span><br><span class="line"></span><br><span class="line">            EventLoop *loop_;            <span class="comment">// 所属EventLoop</span></span><br><span class="line">            <span class="type">const</span> <span class="type">int</span> fd_;            <span class="comment">// 文件描述符，但不负责关闭该文件描述符</span></span><br><span class="line">            <span class="type">int</span> events_;        <span class="comment">// 需要epoll关注的事件</span></span><br><span class="line">            <span class="type">int</span> revents_;        <span class="comment">// poll/epoll wait返回的需要处理的事件</span></span><br><span class="line">            <span class="type">int</span> index_;        <span class="comment">// used by Poller.表示在epoll队列中的状态：1.正在队列中2.曾经在队列中3.从来没在队列中</span></span><br><span class="line">            <span class="type">bool</span> logHup_;        <span class="comment">// for POLLHUP是否被挂起</span></span><br><span class="line"></span><br><span class="line">            boost::weak_ptr&lt;<span class="type">void</span>&gt; tie_;<span class="comment">//保证channel所在的类</span></span><br><span class="line">            <span class="type">bool</span> tied_;</span><br><span class="line">            <span class="type">bool</span> eventHandling_;        <span class="comment">// 是否处于处理事件中</span></span><br><span class="line">            ReadEventCallback readCallback_;<span class="comment">//当文件描述符产生读事件时，最后调用的读函数</span></span><br><span class="line">            EventCallback writeCallback_;<span class="comment">//当文件描述符产生写事件时，最后调用的写函数</span></span><br><span class="line">            EventCallback closeCallback_;<span class="comment">//当文件描述符产生关闭事件时，最后调用的关闭函数</span></span><br><span class="line">            EventCallback errorCallback_;<span class="comment">//当文件描述符产生错误事件时，最后调用的错误函数</span></span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span>  <span class="comment">// MUDUO_NET_CHANNEL_H</span></span></span><br></pre></td></tr></table></figure>

<p>Channel.cc源码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;muduo/base/Logging.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;muduo/net/Channel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;muduo/net/EventLoop.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;poll.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> muduo;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> muduo::net;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> Channel::kNoneEvent = <span class="number">0</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> Channel::kReadEvent = POLLIN | POLLPRI;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> Channel::kWriteEvent = POLLOUT;</span><br><span class="line"></span><br><span class="line">Channel::<span class="built_in">Channel</span>(EventLoop *loop, <span class="type">int</span> fd__)</span><br><span class="line">        : <span class="built_in">loop_</span>(loop),</span><br><span class="line">          <span class="built_in">fd_</span>(fd__),</span><br><span class="line">          <span class="built_in">events_</span>(<span class="number">0</span>),</span><br><span class="line">          <span class="built_in">revents_</span>(<span class="number">0</span>),</span><br><span class="line">          <span class="built_in">index_</span>(<span class="number">-1</span>),<span class="comment">//就是kNew</span></span><br><span class="line">          <span class="built_in">logHup_</span>(<span class="literal">true</span>),</span><br><span class="line">          <span class="built_in">tied_</span>(<span class="literal">false</span>),</span><br><span class="line">          <span class="built_in">eventHandling_</span>(<span class="literal">false</span>) &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Channel::~<span class="built_in">Channel</span>() &#123;</span><br><span class="line">    <span class="built_in">assert</span>(!eventHandling_);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Channel::tie</span><span class="params">(<span class="type">const</span> boost::shared_ptr&lt;<span class="type">void</span>&gt; &amp;obj)</span><span class="comment">//给tie_指针赋值，tie_指针是一个weak_ptr指针</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tie_ = obj;</span><br><span class="line">    tied_ = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Channel::update</span><span class="params">()</span><span class="comment">//把当前的channel加入到poll队列当中</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    loop_-&gt;<span class="built_in">updateChannel</span>(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用这个函数之前确保调用disableAll</span></span><br><span class="line"><span class="comment">// 从EventLoop中移除这个channel</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Channel::remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(<span class="built_in">isNoneEvent</span>());</span><br><span class="line">    loop_-&gt;<span class="built_in">removeChannel</span>(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Channel::handleEvent</span><span class="params">(Timestamp receiveTime)</span><span class="comment">//Timestamp主要用于读事件的回调函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//guard是一个shared_ptr，这样guard指向的对象在智能指针析构前就不会析构了，延长了生命周期</span></span><br><span class="line">    boost::shared_ptr&lt;<span class="type">void</span>&gt; guard;</span><br><span class="line">    <span class="keyword">if</span> (tied_) &#123;</span><br><span class="line">        guard = tie_.<span class="built_in">lock</span>();<span class="comment">//提升tie_为shared_ptr，如果提升成功，说明指向一个存在的对象</span></span><br><span class="line">        <span class="keyword">if</span> (guard) &#123;</span><br><span class="line">            LOG_TRACE &lt;&lt; <span class="string">&quot;[6] usecount=&quot;</span> &lt;&lt; guard.<span class="built_in">use_count</span>();</span><br><span class="line">            <span class="built_in">handleEventWithGuard</span>(receiveTime);</span><br><span class="line">            LOG_TRACE &lt;&lt; <span class="string">&quot;[12] usecount=&quot;</span> &lt;&lt; guard.<span class="built_in">use_count</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">handleEventWithGuard</span>(receiveTime);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Channel::handleEventWithGuard</span><span class="params">(Timestamp receiveTime)</span></span></span><br><span class="line"><span class="function"><span class="comment">//查看epoll/poll返回的具体是什么事件，并根据事件的类型进行相应的处理</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    eventHandling_ = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    if (revents_ &amp; POLLHUP)</span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">        LOG_TRACE &lt;&lt; &quot;1111111111111111&quot;;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    if (revents_ &amp; POLLIN)</span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">        LOG_TRACE &lt;&lt; &quot;2222222222222222&quot;;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">if</span> ((revents_ &amp; POLLHUP) &amp;&amp; !(revents_ &amp; POLLIN))<span class="comment">//当事件为挂起并没有可读事件时</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (logHup_) &#123;</span><br><span class="line">            LOG_WARN &lt;&lt; <span class="string">&quot;Channel::handle_event() POLLHUP&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (closeCallback_) <span class="built_in">closeCallback_</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (revents_ &amp; POLLNVAL)<span class="comment">//描述字不是一个打开的文件描述符</span></span><br><span class="line">    &#123;</span><br><span class="line">        LOG_WARN &lt;&lt; <span class="string">&quot;Channel::handle_event() POLLNVAL&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (revents_ &amp; (POLLERR | POLLNVAL))<span class="comment">//发生错误或者描述符不可打开</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (errorCallback_) <span class="built_in">errorCallback_</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (revents_ &amp; (POLLIN | POLLPRI | POLLRDHUP))<span class="comment">//关于读的事件</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (readCallback_) <span class="built_in">readCallback_</span>(receiveTime);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (revents_ &amp; POLLOUT)<span class="comment">//关于写的事件</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (writeCallback_) <span class="built_in">writeCallback_</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    eventHandling_ = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">string <span class="title">Channel::reventsToString</span><span class="params">()</span> <span class="type">const</span><span class="comment">//把事件转成一个string，用于日志打印debug</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::ostringstream oss;</span><br><span class="line">    oss &lt;&lt; fd_ &lt;&lt; <span class="string">&quot;: &quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> (revents_ &amp; POLLIN)</span><br><span class="line">        oss &lt;&lt; <span class="string">&quot;IN &quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> (revents_ &amp; POLLPRI)</span><br><span class="line">        oss &lt;&lt; <span class="string">&quot;PRI &quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> (revents_ &amp; POLLOUT)</span><br><span class="line">        oss &lt;&lt; <span class="string">&quot;OUT &quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> (revents_ &amp; POLLHUP)</span><br><span class="line">        oss &lt;&lt; <span class="string">&quot;HUP &quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> (revents_ &amp; POLLRDHUP)</span><br><span class="line">        oss &lt;&lt; <span class="string">&quot;RDHUP &quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> (revents_ &amp; POLLERR)</span><br><span class="line">        oss &lt;&lt; <span class="string">&quot;ERR &quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> (revents_ &amp; POLLNVAL)</span><br><span class="line">        oss &lt;&lt; <span class="string">&quot;NVAL &quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> oss.<span class="built_in">str</span>().<span class="built_in">c_str</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Channel::tie()详解</strong></p>
<p>这里是一个智能指针使用的特定场景之一，用于特定时刻延长对象的生命周期。我们知道持有对象的shared_ptr可以延长对象的生命周期，但是如果我们只想在特定时刻延长对象的生命周期怎么办(比如执行对象的成员函数时)。解决方法就是持有对象的weak_ptr，并在函数内升级为shared_ptr。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//给tie_指针赋值，tie_指针是一个weak_ptr指针</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Channel::tie</span><span class="params">(<span class="type">const</span> boost::shared_ptr&lt;<span class="type">void</span>&gt; &amp;obj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tie_ = obj;</span><br><span class="line">    tied_ = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Channel::handleEvent</span><span class="params">(Timestamp receiveTime)</span><span class="comment">//Timestamp主要用于读事件的回调函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//guard是一个shared_ptr，这样guard指向的对象在handleEventWithGuard()函数执行期间就不会析构了，延长了生命周期</span></span><br><span class="line">    boost::shared_ptr&lt;<span class="type">void</span>&gt; guard;</span><br><span class="line">    <span class="keyword">if</span> (tied_) &#123;</span><br><span class="line">        guard = tie_.<span class="built_in">lock</span>();<span class="comment">//提升tie_为shared_ptr，如果提升成功，说明指向一个存在的对象</span></span><br><span class="line">        <span class="keyword">if</span> (guard) &#123;</span><br><span class="line">            LOG_TRACE &lt;&lt; <span class="string">&quot;[6] usecount=&quot;</span> &lt;&lt; guard.<span class="built_in">use_count</span>();</span><br><span class="line">            <span class="built_in">handleEventWithGuard</span>(receiveTime);</span><br><span class="line">            LOG_TRACE &lt;&lt; <span class="string">&quot;[12] usecount=&quot;</span> &lt;&lt; guard.<span class="built_in">use_count</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">handleEventWithGuard</span>(receiveTime);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结合例子分析，看下面的一个调用时序图</p>
<p><img src="https://raw.githubusercontent.com/hufei96/Image/main/muduo_tie.png" alt="img"></p>
<p>当对方断开TCP连接，这个IO事件会触发Channel::handleEvent()调用，后者会调用用户提供的CloseCallback，而用户代码在onClose()中有可能析构Channel对象，这就造成了灾难。等于说Channel::handleEvent()执行到一半的时候，其所属的Channel对象本身被销毁了。这时程序无疑会出错或崩溃。</p>
<p>Muduo的解决办法是提供Channel::tie(const boost::shared_ptr<void>&amp;)这个函数，用于延长某些对象（可以是Channel对象，也可以是其owner对象）的生命周期，使之长过Channel::handleEvent()函数。</p>
<p>Muduo TcpConnection采用shared_ptr管理对象生命期的原因之一就是因为这个。</p>
<p>当有关闭事件时，调用流程如下：</p>
<p>Channel::handleEvent -&gt; TcpConnection::handleClose -&gt;TcpClient::removeConnection -&gt;TcpConnection::connectDestroyed-&gt;channel_-&gt;remove()。</p>
<p>1、为了在Channel::handleEvent处理期间，防止因其owner对象被修改，进而导致Channel被析构，最后出现不可预估错误。 Channel::tie()的作用就是将Channel的owner对象进行绑定保护起来。</p>
<p> 2、另外channel-&gt;remove的作用是删除channel在Poll中的地址拷贝，而不是销毁channel。channel的销毁由其owner对象决定。</p>
<h3 id="poller"><a href="#poller" class="headerlink" title="poller"></a>poller</h3><p>Poller class 是IO multiplexing的封装。在muduo中它是一个抽象类，因为muduo同时支持poll和epoll两种IO multiplexing机制。</p>
<p>Poller是EventLoop的间接成员，只供其owner EventLoop在IO线程中调用，因此无需加锁。其生命周期和EvenLoop相等。Poller并不拥有Channel，Channel在析构前必须自己unregister（EventLoop::removeChannel()）,避免悬空指针。</p>
<p><strong>Poller.h</strong></p>
<p>Poller.h只是一个简单的抽象类</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> MUDUO_NET_POLLER_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MUDUO_NET_POLLER_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/noncopyable.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;muduo/base/Timestamp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;muduo/net/EventLoop.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> muduo &#123;</span><br><span class="line">    <span class="keyword">namespace</span> net &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">class</span> <span class="title class_">Channel</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// Base class for IO Multiplexing</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// This class doesn&#x27;t own the Channel objects.</span></span><br><span class="line">        <span class="comment">// 这个Poller类只是一个抽象类主要实现在EpollPoller/PollPoller中</span></span><br><span class="line">        <span class="keyword">class</span> <span class="title class_">Poller</span> : boost::noncopyable &#123;</span><br><span class="line">        <span class="keyword">public</span>:</span><br><span class="line">            <span class="keyword">typedef</span> std::vector&lt;Channel *&gt; ChannelList;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">Poller</span>(EventLoop *loop);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">virtual</span> ~<span class="built_in">Poller</span>();</span><br><span class="line"></span><br><span class="line">            <span class="comment">/// Polls the I/O events.</span></span><br><span class="line">            <span class="comment">/// Must be called in the loop thread.</span></span><br><span class="line">            <span class="function"><span class="keyword">virtual</span> Timestamp <span class="title">poll</span><span class="params">(<span class="type">int</span> timeoutMs, ChannelList *activeChannels)</span> </span>= <span class="number">0</span>; <span class="comment">// poll函数</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">/// Changes the interested I/O events.</span></span><br><span class="line">            <span class="comment">/// Must be called in the loop thread.</span></span><br><span class="line">            <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">updateChannel</span><span class="params">(Channel *channel)</span> </span>= <span class="number">0</span>;<span class="comment">// 更新Channel</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">/// Remove the channel, when it destructs.</span></span><br><span class="line">            <span class="comment">/// Must be called in the loop thread.</span></span><br><span class="line">            <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">removeChannel</span><span class="params">(Channel *channel)</span> </span>= <span class="number">0</span>;    <span class="comment">// 移除Channel</span></span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="type">static</span> Poller *<span class="title">newDefaultPoller</span><span class="params">(EventLoop *loop)</span></span>;<span class="comment">// 在这里会根据环境变量生成epoll或者poll</span></span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="type">void</span> <span class="title">assertInLoopThread</span><span class="params">()</span> </span>&#123;<span class="comment">// 确保所有的操作都在eventloop的线程中</span></span><br><span class="line">                ownerLoop_-&gt;<span class="built_in">assertInLoopThread</span>();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span>:</span><br><span class="line">            EventLoop *ownerLoop_;    <span class="comment">// Poller所属EventLoop</span></span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span>  <span class="comment">// MUDUO_NET_POLLER_H</span></span></span><br></pre></td></tr></table></figure>

<p><strong>EPollPoller.h</strong></p>
<p>这个类主要利用epoll函数，封装了epoll三个函数，</p>
<p>其中epoll_event.data是一个指向channel类的指针，这里可以等价理解为channel就是epoll_event，用于在epoll队列中注册，删除，更改的结构体。因为文件描述符fd，Channel，以及epoll_event结构体（只有需要添加到epoll上时才有epoll_event结构体）三个都是一一对应的关系Channel.fd应该等于fd，epoll_event.data应该等于&amp;Channel。如果不添加到epoll队列中，Channel和fd一一对应，就没有epoll_event结构体了</p>
<p>从epoll队列中删除有两种删除方法，</p>
<p>第一种暂时删除，就是从epoll队列中删除，并且把标志位置为kDeleted，但是并不从ChannelMap channels_中删除</p>
<p>第二种是完全删除，从epoll队列中删除，并且从ChannelMap channels_中也删除，最后把标志位置kNew。</p>
<p>可以理解为ChannelMap channels_的作用就是：暂时不需要的，就从epoll队列中删除，但是在channels_中保留信息，类似与挂起，这样下次再使用这个channel时，只需要添加到epoll队列中即可。而完全删除，就把channels_中也删除。</p>
<p>下面的源码有详细的注释</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> MUDUO_NET_POLLER_EPOLLPOLLER_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MUDUO_NET_POLLER_EPOLLPOLLER_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;muduo/net/Poller.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">epoll_event</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> muduo &#123;</span><br><span class="line">    <span class="keyword">namespace</span> net &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// IO Multiplexing with epoll(4).</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line">        <span class="keyword">class</span> <span class="title class_">EPollPoller</span> : <span class="keyword">public</span> Poller &#123;</span><br><span class="line">        <span class="keyword">public</span>:</span><br><span class="line">            <span class="built_in">EPollPoller</span>(EventLoop *loop);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">virtual</span> ~<span class="built_in">EPollPoller</span>();</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">virtual</span> Timestamp <span class="title">poll</span><span class="params">(<span class="type">int</span> timeoutMs, ChannelList *activeChannels)</span></span>;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">updateChannel</span><span class="params">(Channel *channel)</span></span>;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">removeChannel</span><span class="params">(Channel *channel)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span>:</span><br><span class="line">            <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> kInitEventListSize = <span class="number">16</span>; <span class="comment">//默认事件数组大小，是用来装epoll_wait()返回的可读或可写事件的</span></span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="type">void</span> <span class="title">fillActiveChannels</span><span class="params">(<span class="type">int</span> numEvents, ChannelList *activeChannels)</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> operation, Channel *channel)</span></span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">typedef</span> std::vector&lt;<span class="keyword">struct</span> epoll_event&gt; EventList;</span><br><span class="line">            <span class="keyword">typedef</span> std::map&lt;<span class="type">int</span>, Channel *&gt; ChannelMap;</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> epollfd_;<span class="comment">//epoll监视的文件描述符</span></span><br><span class="line">            EventList events_;<span class="comment">//用来存储活跃文件描述符的epoll_event结构体数组</span></span><br><span class="line">            ChannelMap channels_;<span class="comment">//记录标志符是kAdded或者kDeleted的channel和fd</span></span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span>  <span class="comment">// MUDUO_NET_POLLER_EPOLLPOLLER_H</span></span></span><br></pre></td></tr></table></figure>

<p><strong>EPollPoller.cc</strong></p>
<p>主要是一些EPollPoller类的具体实现，注释很详细。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;muduo/net/poller/EPollPoller.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;muduo/base/Logging.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;muduo/net/Channel.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/static_assert.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;poll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> muduo;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> muduo::net;</span><br><span class="line"></span><br><span class="line"><span class="comment">// On Linux, the constants of poll(2) and epoll(4)</span></span><br><span class="line"><span class="comment">// are expected to be the same.</span></span><br><span class="line"><span class="built_in">BOOST_STATIC_ASSERT</span>(EPOLLIN</span><br><span class="line">== POLLIN);</span><br><span class="line"><span class="built_in">BOOST_STATIC_ASSERT</span>(EPOLLPRI</span><br><span class="line">== POLLPRI);</span><br><span class="line"><span class="built_in">BOOST_STATIC_ASSERT</span>(EPOLLOUT</span><br><span class="line">== POLLOUT);</span><br><span class="line"><span class="built_in">BOOST_STATIC_ASSERT</span>(EPOLLRDHUP</span><br><span class="line">== POLLRDHUP);</span><br><span class="line"><span class="built_in">BOOST_STATIC_ASSERT</span>(EPOLLERR</span><br><span class="line">== POLLERR);</span><br><span class="line"><span class="built_in">BOOST_STATIC_ASSERT</span>(EPOLLHUP</span><br><span class="line">== POLLHUP);</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> kNew = <span class="number">-1</span>;<span class="comment">//代表不在epoll队列中，也不在ChannelMap channels_中</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> kAdded = <span class="number">1</span>;<span class="comment">//代表正在epoll队列当中</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> kDeleted = <span class="number">2</span>;<span class="comment">//代表曾经在epoll队列当中过，但是被删除了，现在不在了，但是还是在ChannelMap channels_中的</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">EPollPoller::<span class="built_in">EPollPoller</span>(EventLoop *loop)</span><br><span class="line">        : <span class="built_in">Poller</span>(loop),<span class="comment">//所属的EventLoop</span></span><br><span class="line">          <span class="built_in">epollfd_</span>(::<span class="built_in">epoll_create1</span>(EPOLL_CLOEXEC)),<span class="comment">//创建一个epoll文件描述符，用来监听所有注册的事件</span></span><br><span class="line">          <span class="built_in">events_</span>(kInitEventListSize) &#123;<span class="comment">//初始化vector</span></span><br><span class="line">    <span class="keyword">if</span> (epollfd_ &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        LOG_SYSFATAL &lt;&lt; <span class="string">&quot;EPollPoller::EPollPoller&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">EPollPoller::~<span class="built_in">EPollPoller</span>()<span class="comment">//关闭epoll文件描述符</span></span><br><span class="line">&#123;</span><br><span class="line">    ::<span class="built_in">close</span>(epollfd_);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Timestamp <span class="title">EPollPoller::poll</span><span class="params">(<span class="type">int</span> timeoutMs, ChannelList *activeChannels)</span><span class="comment">//封装epoll_wait</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> numEvents = ::<span class="built_in">epoll_wait</span>(epollfd_,</span><br><span class="line">                                 &amp;*events_.<span class="built_in">begin</span>(),<span class="comment">//等价于&amp;events[0],就是传入一个vecotr&lt;struct epoll_event&gt;的首指针进去,用vector首指针代替了数组首指针</span></span><br><span class="line">                                 <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(events_.<span class="built_in">size</span>()),</span><br><span class="line">                                 timeoutMs);</span><br><span class="line">    <span class="function">Timestamp <span class="title">now</span><span class="params">(Timestamp::now())</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (numEvents &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        LOG_TRACE &lt;&lt; numEvents &lt;&lt; <span class="string">&quot; events happended&quot;</span>;</span><br><span class="line">        <span class="built_in">fillActiveChannels</span>(numEvents, activeChannels);</span><br><span class="line">        <span class="comment">//如果返回的事件数目等于当前事件数组大小，就就扩充events_，分配2倍空间,</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">implicit_cast</span>&lt;<span class="type">size_t</span>&gt;(numEvents) == events_.<span class="built_in">size</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            events_.<span class="built_in">resize</span>(events_.<span class="built_in">size</span>() * <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (numEvents == <span class="number">0</span>)<span class="comment">//如果timeoutMs设置的是大于0的数，也就是超时时间有效的话，那么过了超时时间并且没有事件发生，就会出现这种情况</span></span><br><span class="line">    &#123;</span><br><span class="line">        LOG_TRACE &lt;&lt; <span class="string">&quot; nothing happended&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        LOG_SYSERR &lt;&lt; <span class="string">&quot;EPollPoller::poll()&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> now;<span class="comment">//返回的是事件发生时的时间</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">EPollPoller::fillActiveChannels</span><span class="params">(<span class="type">int</span> numEvents,</span></span></span><br><span class="line"><span class="params"><span class="function">                                     ChannelList *activeChannels)</span> <span class="type">const</span> <span class="comment">//epoll_event转为channel</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(<span class="built_in">implicit_cast</span>&lt;<span class="type">size_t</span>&gt;(numEvents) &lt;= events_.<span class="built_in">size</span>());</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numEvents; ++i)<span class="comment">//将返回的活跃epoll_event转成channel放到activeChannels列表中</span></span><br><span class="line">    &#123;</span><br><span class="line">        Channel *channel = <span class="built_in">static_cast</span>&lt;Channel *&gt;(events_[i].data.ptr);<span class="comment">//把产生事件的channel变量拿出来</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">这是epoll模式epoll_event事件的数据结构，其中data不仅可以保存fd，也可以保存一个void*类型的指针。</span></span><br><span class="line"><span class="comment">typedef union epoll_data &#123;</span></span><br><span class="line"><span class="comment">               void    *ptr;</span></span><br><span class="line"><span class="comment">               int      fd;</span></span><br><span class="line"><span class="comment">               uint32_t u32;</span></span><br><span class="line"><span class="comment">               uint64_t u64;</span></span><br><span class="line"><span class="comment">           &#125; epoll_data_t;</span></span><br><span class="line"><span class="comment">           struct epoll_event &#123;</span></span><br><span class="line"><span class="comment">               uint32_t     events;    // Epoll events</span></span><br><span class="line"><span class="comment">               epoll_data_t data;      //User data variable</span></span><br><span class="line"><span class="comment">           &#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> NDEBUG<span class="comment">//在调试时会执行下面的代码，否则就直接忽视</span></span></span><br><span class="line">        <span class="type">int</span> fd = channel-&gt;<span class="built_in">fd</span>();</span><br><span class="line">        ChannelMap::const_iterator it = channels_.<span class="built_in">find</span>(fd);</span><br><span class="line">        <span class="built_in">assert</span>(it != channels_.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">assert</span>(it-&gt;second == channel);<span class="comment">//判断ChannelMap中key和value的对应关系是否准确</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">        channel-&gt;<span class="built_in">set_revents</span>(events_[i].events);<span class="comment">//把已经触发的事件写入channel中</span></span><br><span class="line">        activeChannels-&gt;<span class="built_in">push_back</span>(channel);<span class="comment">//把channel放入要处理的channel列表中</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">EPollPoller::updateChannel</span><span class="params">(Channel *channel)</span><span class="comment">//根据channel的序号在epoll队列中来删除，增加channel或者改变channel</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Poller::<span class="built_in">assertInLoopThread</span>();<span class="comment">//负责epoll_wait的线程和创建eventloop的线程为同一个</span></span><br><span class="line">    LOG_TRACE &lt;&lt; <span class="string">&quot;fd = &quot;</span> &lt;&lt; channel-&gt;<span class="built_in">fd</span>() &lt;&lt; <span class="string">&quot; events = &quot;</span> &lt;&lt; channel-&gt;<span class="built_in">events</span>();</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> index = channel-&gt;<span class="built_in">index</span>();</span><br><span class="line">    <span class="keyword">if</span> (index == kNew || index == kDeleted)<span class="comment">//如果是完全没在或者曾经在epoll队列中的，就添加到epoll队列中</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// a new one, add with EPOLL_CTL_ADD</span></span><br><span class="line">        <span class="type">int</span> fd = channel-&gt;<span class="built_in">fd</span>();</span><br><span class="line">        <span class="keyword">if</span> (index == kNew) &#123;<span class="comment">//完全没在epoll队列中</span></span><br><span class="line">            <span class="built_in">assert</span>(channels_.<span class="built_in">find</span>(fd) == channels_.<span class="built_in">end</span>());<span class="comment">//确保这个channel的文件描述符不在channels_中</span></span><br><span class="line">            channels_[fd] = channel;<span class="comment">//将新添加的fd和channel添加到channels_中</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="comment">// index == kDeleted  曾经在epoll队列中</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">assert</span>(channels_.<span class="built_in">find</span>(fd) != channels_.<span class="built_in">end</span>());<span class="comment">//确保这个channel的文件描述符在channels_中</span></span><br><span class="line">            <span class="built_in">assert</span>(channels_[fd] == channel);<span class="comment">//确保在epoll队列中channel和fd一致</span></span><br><span class="line">        &#125;</span><br><span class="line">        channel-&gt;<span class="built_in">set_index</span>(kAdded);<span class="comment">//修改index为已在队列中</span></span><br><span class="line">        <span class="built_in">update</span>(EPOLL_CTL_ADD, channel);</span><br><span class="line">    &#125; <span class="keyword">else</span><span class="comment">//如果是现在就在epoll队列中的，如果没有关注事件了，就暂时删除，如果有关注事件，就修改</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// update existing one with EPOLL_CTL_MOD/DEL</span></span><br><span class="line">        <span class="type">int</span> fd = channel-&gt;<span class="built_in">fd</span>();</span><br><span class="line">        (<span class="type">void</span>) fd;</span><br><span class="line">        <span class="built_in">assert</span>(channels_.<span class="built_in">find</span>(fd) != channels_.<span class="built_in">end</span>());<span class="comment">//channels_中是否有这个文件描述符</span></span><br><span class="line">        <span class="built_in">assert</span>(channels_[fd] == channel);<span class="comment">//channels_中channel和fd是否一致</span></span><br><span class="line">        <span class="built_in">assert</span>(index == kAdded);<span class="comment">//标志位是否正在队列中</span></span><br><span class="line">        <span class="keyword">if</span> (channel-&gt;<span class="built_in">isNoneEvent</span>()) &#123;</span><br><span class="line">            <span class="built_in">update</span>(EPOLL_CTL_DEL, channel);</span><br><span class="line">            channel-&gt;<span class="built_in">set_index</span>(kDeleted);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">update</span>(EPOLL_CTL_MOD, channel);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">EPollPoller::removeChannel</span><span class="params">(Channel *channel)</span><span class="comment">//完全删除channel</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Poller::<span class="built_in">assertInLoopThread</span>();</span><br><span class="line">    <span class="type">int</span> fd = channel-&gt;<span class="built_in">fd</span>();</span><br><span class="line">    LOG_TRACE &lt;&lt; <span class="string">&quot;fd = &quot;</span> &lt;&lt; fd;</span><br><span class="line">    <span class="built_in">assert</span>(channels_.<span class="built_in">find</span>(fd) != channels_.<span class="built_in">end</span>());<span class="comment">//channels_中是否有这个文件描述符</span></span><br><span class="line">    <span class="built_in">assert</span>(channels_[fd] == channel);<span class="comment">//channels_中channel和fd是否一致</span></span><br><span class="line">    <span class="built_in">assert</span>(channel-&gt;<span class="built_in">isNoneEvent</span>());<span class="comment">//channel中要关注的事件是否为空</span></span><br><span class="line">    <span class="type">int</span> index = channel-&gt;<span class="built_in">index</span>();</span><br><span class="line">    <span class="built_in">assert</span>(index == kAdded || index == kDeleted);<span class="comment">//标志位必须是kAdded或者kDeleted</span></span><br><span class="line">    <span class="type">size_t</span> n = channels_.<span class="built_in">erase</span>(fd);</span><br><span class="line">    (<span class="type">void</span>) n;</span><br><span class="line">    <span class="built_in">assert</span>(n == <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (index == kAdded) &#123;</span><br><span class="line">        <span class="built_in">update</span>(EPOLL_CTL_DEL, channel);<span class="comment">//从epoll队列中删除这个channel</span></span><br><span class="line">    &#125;</span><br><span class="line">    channel-&gt;<span class="built_in">set_index</span>(kNew);<span class="comment">//设置标志位是kNew，相当于完全删除</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">EPollPoller::update</span><span class="params">(<span class="type">int</span> operation, Channel *channel)</span><span class="comment">//主要执行epoll_ctl函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">epoll_event</span> event;</span><br><span class="line">    <span class="built_in">bzero</span>(&amp;event, <span class="keyword">sizeof</span> event);</span><br><span class="line">    event.events = channel-&gt;<span class="built_in">events</span>();</span><br><span class="line">    event.data.ptr = channel;<span class="comment">//设置epoll_event结构体</span></span><br><span class="line">    <span class="type">int</span> fd = channel-&gt;<span class="built_in">fd</span>();</span><br><span class="line">    <span class="keyword">if</span> (::<span class="built_in">epoll_ctl</span>(epollfd_, operation, fd, &amp;event) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (operation == EPOLL_CTL_DEL) &#123;</span><br><span class="line">            LOG_SYSERR &lt;&lt; <span class="string">&quot;epoll_ctl op=&quot;</span> &lt;&lt; operation &lt;&lt; <span class="string">&quot; fd=&quot;</span> &lt;&lt; fd;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            LOG_SYSFATAL &lt;&lt; <span class="string">&quot;epoll_ctl op=&quot;</span> &lt;&lt; operation &lt;&lt; <span class="string">&quot; fd=&quot;</span> &lt;&lt; fd;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="acceptor"><a href="#acceptor" class="headerlink" title="acceptor"></a>acceptor</h3><p><code>Acceptor</code> 用于初始化socket，监听端口，接受连接并调用传入的 <code>callback</code> 创建连接：</p>
<p>Acceptor的数据成员包括Socket、Channel。</p>
<p>Acceptor的socket是listening socket（即server socket）。</p>
<p>Channel用于观察此socket的readable事件，并Acceptor::handleRead()，后者调用accept(2)来接受连接，并回调用户callback。</p>
<p>Acceptor类在上层应用程序中我们不直接使用，而是把它封装作为TcpServer的成员。</p>
<p>Acceptor.h源码分析</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*就是用一个Acceptor类专门用一个channel来创建套接字，绑定，监听等操作*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> MUDUO_NET_ACCEPTOR_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MUDUO_NET_ACCEPTOR_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/function.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/noncopyable.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;muduo/net/Channel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;muduo/net/Socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> muduo &#123;</span><br><span class="line">    <span class="keyword">namespace</span> net &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">class</span> <span class="title class_">EventLoop</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">class</span> <span class="title class_">InetAddress</span>;</span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// Acceptor of incoming TCP connections.</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line">        <span class="keyword">class</span> <span class="title class_">Acceptor</span> : boost::noncopyable &#123;</span><br><span class="line">        <span class="keyword">public</span>:</span><br><span class="line">            <span class="keyword">typedef</span> boost::function&lt;<span class="type">void</span>(<span class="type">int</span> sockfd,<span class="type">const</span> InetAddress &amp;)&gt; NewConnectionCallback;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">Acceptor</span>(EventLoop *loop, <span class="type">const</span> InetAddress &amp;listenAddr);</span><br><span class="line"></span><br><span class="line">            ~<span class="built_in">Acceptor</span>();</span><br><span class="line">            <span class="comment">//newConnectionCallback_是在Acceptor::handleRead里面执行的，也就是在acceptChannel_的读事件发生的时候会被调用</span></span><br><span class="line">            <span class="function"><span class="type">void</span> <span class="title">setNewConnectionCallback</span><span class="params">(<span class="type">const</span> NewConnectionCallback &amp;cb)</span> </span>&#123; newConnectionCallback_ = cb; &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="type">bool</span> <span class="title">listenning</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> listenning_; &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="type">void</span> <span class="title">listen</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span>:</span><br><span class="line">            <span class="function"><span class="type">void</span> <span class="title">handleRead</span><span class="params">()</span></span>;<span class="comment">//可读回调函数，绑定在acceptChannel_的读函数上</span></span><br><span class="line"></span><br><span class="line">            EventLoop *loop_;<span class="comment">//所属的EventLoop对象</span></span><br><span class="line">            Socket acceptSocket_;<span class="comment">//监听套接字</span></span><br><span class="line">            Channel acceptChannel_;<span class="comment">//和监听套接字绑定的通道 acceptChannel_和监听套接字acceptSocket_绑定</span></span><br><span class="line">            NewConnectionCallback newConnectionCallback_;<span class="comment">//一旦有新连接发生，执行的回调函数</span></span><br><span class="line">            <span class="type">bool</span> listenning_;<span class="comment">//acceptChannel所处的eventloop是否处于监听状态</span></span><br><span class="line">            <span class="type">int</span> idleFd_;<span class="comment">//预留一个fd，用来解决文件描述符过多，引起电平触发不断触发的问题，详见handleRead函数的最后</span></span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span>  <span class="comment">// MUDUO_NET_ACCEPTOR_H</span></span></span><br></pre></td></tr></table></figure>

<p>Acceptor.cc源码分析</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;muduo/net/Acceptor.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;muduo/net/EventLoop.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;muduo/net/InetAddress.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;muduo/net/SocketsOps.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/bind.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="comment">//#include &lt;sys/types.h&gt;</span></span><br><span class="line"><span class="comment">//#include &lt;sys/stat.h&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> muduo;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> muduo::net;</span><br><span class="line"></span><br><span class="line">Acceptor::<span class="built_in">Acceptor</span>(EventLoop *loop, <span class="type">const</span> InetAddress &amp;listenAddr)</span><br><span class="line">        : <span class="built_in">loop_</span>(loop),</span><br><span class="line">          <span class="built_in">acceptSocket_</span>(sockets::<span class="built_in">createNonblockingOrDie</span>()),<span class="comment">//设置监听套接字</span></span><br><span class="line">          <span class="built_in">acceptChannel_</span>(loop, acceptSocket_.<span class="built_in">fd</span>()),</span><br><span class="line">          <span class="built_in">listenning_</span>(<span class="literal">false</span>),</span><br><span class="line">          <span class="built_in">idleFd_</span>(::<span class="built_in">open</span>(<span class="string">&quot;/dev/null&quot;</span>, O_RDONLY | O_CLOEXEC))<span class="comment">//这个描述符打开一个linux系统的空文件，所有写入的内容都会被丢弃</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">assert</span>(idleFd_ &gt;= <span class="number">0</span>);</span><br><span class="line">    acceptSocket_.<span class="built_in">setReuseAddr</span>(<span class="literal">true</span>);</span><br><span class="line">    acceptSocket_.<span class="built_in">bindAddress</span>(listenAddr);</span><br><span class="line">    acceptChannel_.<span class="built_in">setReadCallback</span>(boost::<span class="built_in">bind</span>(&amp;Acceptor::handleRead, <span class="keyword">this</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Acceptor::~<span class="built_in">Acceptor</span>() &#123;</span><br><span class="line">    acceptChannel_.<span class="built_in">disableAll</span>();</span><br><span class="line">    acceptChannel_.<span class="built_in">remove</span>();</span><br><span class="line">    ::<span class="built_in">close</span>(idleFd_);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Acceptor::listen</span><span class="params">()</span><span class="comment">//开启监听</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    loop_-&gt;<span class="built_in">assertInLoopThread</span>();</span><br><span class="line">    listenning_ = <span class="literal">true</span>;</span><br><span class="line">    acceptSocket_.<span class="built_in">listen</span>();</span><br><span class="line">    acceptChannel_.<span class="built_in">enableReading</span>();<span class="comment">//将socket套接字挂到eventloop的epoll上，并开启读监听</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Acceptor::handleRead</span><span class="params">()</span><span class="comment">//读的回调函数，一旦socket套接字监听到连接，epoll就会立刻调用回调函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    loop_-&gt;<span class="built_in">assertInLoopThread</span>();</span><br><span class="line">    <span class="function">InetAddress <span class="title">peerAddr</span><span class="params">(<span class="number">0</span>)</span></span>;<span class="comment">//对端的</span></span><br><span class="line">    <span class="comment">//FIXME loop until no more</span></span><br><span class="line">    <span class="type">int</span> connfd = acceptSocket_.<span class="built_in">accept</span>(&amp;peerAddr);</span><br><span class="line">    <span class="keyword">if</span> (connfd &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// string hostport = peerAddr.toIpPort();</span></span><br><span class="line">        <span class="comment">// LOG_TRACE &lt;&lt; &quot;Accepts of &quot; &lt;&lt; hostport;</span></span><br><span class="line">        <span class="keyword">if</span> (newConnectionCallback_) &#123;</span><br><span class="line">            <span class="built_in">newConnectionCallback_</span>(connfd, peerAddr);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            sockets::<span class="built_in">close</span>(connfd);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Read the section named &quot;The special problem of</span></span><br><span class="line">        <span class="comment">// accept()ing when you can&#x27;t&quot; in libev&#x27;s doc.</span></span><br><span class="line">        <span class="comment">// By Marc Lehmann, author of livev.</span></span><br><span class="line">        <span class="comment">//在监听套接字可读事件触发时，我们会调用accept接受连接。如果此时注册过回调函数，就执行它。如果没有就直接关闭！</span></span><br><span class="line">        <span class="comment">//另一方面，如果已用文件描述符过多，accept会返回-1，我们构造函数中注册的idleFd_就派上用场了。</span></span><br><span class="line">        <span class="comment">// 当前文件描述符过多，无法接收新的连接。但是由于我们采用LT模式，如果无法接收，可读事件会一直触发。</span></span><br><span class="line">        <span class="comment">// 那么在这个地方的处理机制就是，关掉之前创建的idleFd_，然后去accept让这个事件不会一直触发，</span></span><br><span class="line">        <span class="comment">// 然后再关掉该文件描述符，重新将它设置为空文件描述符。</span></span><br><span class="line">        <span class="comment">//这种机制可以让网络库在处理连接过多，文件描述符不够用时，不至于因为LT模式一直触发而产生坏的影响。</span></span><br><span class="line">        <span class="keyword">if</span> (errno == EMFILE)<span class="comment">//当accept函数出错时，是因为文件描述符太多了</span></span><br><span class="line">        &#123;</span><br><span class="line">            ::<span class="built_in">close</span>(idleFd_);<span class="comment">//就关闭一个空闲描述符，相当于现在就有一个空的文件描述符位置了</span></span><br><span class="line">            idleFd_ = ::<span class="built_in">accept</span>(acceptSocket_.<span class="built_in">fd</span>(), <span class="literal">NULL</span>, <span class="literal">NULL</span>);<span class="comment">//然后把刚才没有接受的描述符接受进来</span></span><br><span class="line">            ::<span class="built_in">close</span>(idleFd_);<span class="comment">//把这个描述符给关闭，相当于忽略这个请求连接了</span></span><br><span class="line">            idleFd_ = ::<span class="built_in">open</span>(<span class="string">&quot;/dev/null&quot;</span>, O_RDONLY | O_CLOEXEC);<span class="comment">//重新开启这个空闲描述符</span></span><br><span class="line">        &#125;<span class="comment">//之所以这样，是因为poll使用的是水平触发，如果没有这个if判断，就会一直触发</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="tcp-server和tcp-connection"><a href="#tcp-server和tcp-connection" class="headerlink" title="tcp server和tcp connection"></a>tcp server和tcp connection</h3><p><strong>TcpServer</strong></p>
<p>TcpServer相当于主线程reactor， 此时主线程循环只负责TCP连接的建立，及任务的分配，需要让哪个线程干活， 就把timer或连接分配给那个线程即可；对实时性有要求的connection可以单独用一个线程； 数据量大的connection可以独占一个线程；并把数据处理任务分摊到另几个计算线程中（用线程池）；其他次要的辅助性connections共享一个线程。</p>
<p>分配连接主要通过EventLoopThreadPool 线程池实现，新建TcpConnection时从event loop pool里分配一个loop给TcpConnection。 TcpServer自己的EventLoop只用来接受新连接， 而新连接会用其他EventLoop来执行IO。</p>
<p><strong>EventLoopThreadPool</strong></p>
<p>TcpServer每次新建一条TcpConnection就会通过EventLoopThreadPool::getNextLoop()方法来取一个EventLoop， 目前的getNextLoop()只是循环的从池中取一条loop，如果提供给每条TcpConncetion的是均等的服务，那么这样就能很均匀的分配系统的资源了。</p>
<p> TcpServer的工作方式取决于EventLoopThreadPool中线程的创建数量。</p>
<p>0 意味着所有的I&#x2F;O 都在TcpServer的主事件循环中，不会创建新的线程。</p>
<p>1 意味着所有的 I&#x2F;O 在另一个线程中 ，TcpServer的主线程只负责建立连接。</p>
<p>N 意味着新的连接会被循环的分配到N条线程中工作。</p>
<p>TcpServer.h</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 这个类相当于把TcpConnection以及Accept类整合起来，完全能够实现Tcp通信，也就是socket函数都实现了</span></span><br><span class="line"><span class="comment"> * 一个TcpServer类中，有Acceptor，EventLoopThreadPool各一个，以及多个TcpConnection类的指针，</span></span><br><span class="line"><span class="comment"> * 在TcpServer类的启动函数中，先开启EventLoopThreadPool线程池，然后将Acceptor监听函数放入eventloop中去执行</span></span><br><span class="line"><span class="comment"> * 在TcpServer类的构造函数中，就已经把一个成功连接的回调函数绑定在Acceptor类的连接回调函数中，如果Acceptor监听</span></span><br><span class="line"><span class="comment"> * 到有连接进来，先调监听socket描述符的回调函数，把这个连接accept进来，然后再调用newConnectionCallback_函数</span></span><br><span class="line"><span class="comment"> * 来处理连接，每个连接都有一个对应的TcpConnection类来作为缓冲区</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> MUDUO_NET_TCPSERVER_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MUDUO_NET_TCPSERVER_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;muduo/base/Types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;muduo/net/TcpConnection.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/noncopyable.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/scoped_ptr.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> muduo &#123;</span><br><span class="line">    <span class="keyword">namespace</span> net &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">class</span> <span class="title class_">Acceptor</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">class</span> <span class="title class_">EventLoop</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">class</span> <span class="title class_">EventLoopThreadPool</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// TCP server, supports single-threaded and thread-pool models.</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// This is an interface class, so don&#x27;t expose too much details.</span></span><br><span class="line">        <span class="keyword">class</span> <span class="title class_">TcpServer</span> : boost::noncopyable &#123;</span><br><span class="line">        <span class="keyword">public</span>:</span><br><span class="line">            <span class="keyword">typedef</span> boost::function&lt;<span class="type">void</span>(EventLoop *)&gt; ThreadInitCallback;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//TcpServer(EventLoop* loop, const InetAddress&amp; listenAddr);</span></span><br><span class="line">            <span class="built_in">TcpServer</span>(EventLoop *loop,</span><br><span class="line">                      <span class="type">const</span> InetAddress &amp;listenAddr,</span><br><span class="line">                      <span class="type">const</span> string &amp;nameArg);</span><br><span class="line"></span><br><span class="line">            ~<span class="built_in">TcpServer</span>();  <span class="comment">// force out-line dtor, for scoped_ptr members.</span></span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="type">const</span> string &amp;<span class="title">hostport</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> hostport_; &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="type">const</span> string &amp;<span class="title">name</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> name_; &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/// Set the number of threads for handling input.</span></span><br><span class="line">            <span class="comment">///</span></span><br><span class="line">            <span class="comment">/// Always accepts new connection in loop&#x27;s thread.</span></span><br><span class="line">            <span class="comment">/// Must be called before @c start</span></span><br><span class="line">            <span class="comment">/// @param numThreads</span></span><br><span class="line">            <span class="comment">/// - 0 means all I/O in loop&#x27;s thread, no thread will created.</span></span><br><span class="line">            <span class="comment">///   this is the default value.</span></span><br><span class="line">            <span class="comment">/// - 1 means all I/O in another thread.</span></span><br><span class="line">            <span class="comment">/// - N means a thread pool with N threads, new connections</span></span><br><span class="line">            <span class="comment">///   are assigned on a round-robin basis.</span></span><br><span class="line">            <span class="function"><span class="type">void</span> <span class="title">setThreadNum</span><span class="params">(<span class="type">int</span> numThreads)</span></span>;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="type">void</span> <span class="title">setThreadInitCallback</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">                    <span class="type">const</span> ThreadInitCallback &amp;cb)</span> </span>&#123; threadInitCallback_ = cb; &#125;<span class="comment">//这个函数会作为EventLoopThreadPool::start的入口参数</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">/// Starts the server if it&#x27;s not listenning.</span></span><br><span class="line">            <span class="comment">///</span></span><br><span class="line">            <span class="comment">/// It&#x27;s harmless to call it multiple times.</span></span><br><span class="line">            <span class="comment">/// Thread safe.</span></span><br><span class="line">            <span class="function"><span class="type">void</span> <span class="title">start</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/// Set connection callback.</span></span><br><span class="line">            <span class="comment">/// Not thread safe.</span></span><br><span class="line">            <span class="comment">// 设置连接到来或者连接关闭回调函数,这个函数指针会赋值给TcpConnection::connectionCallback_函数，就是在连接建立之后，和连接断开之前会调用</span></span><br><span class="line">            <span class="function"><span class="type">void</span> <span class="title">setConnectionCallback</span><span class="params">(<span class="type">const</span> ConnectionCallback &amp;cb)</span> </span>&#123; connectionCallback_ = cb; &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/// Set message callback.</span></span><br><span class="line">            <span class="comment">/// Not thread safe.</span></span><br><span class="line">            <span class="comment">//  设置消息到来回调函数，这个函数指针在TcpConnection::handleread函数中调用，也就是TcpConnection的Channel的读函数的一部分</span></span><br><span class="line">            <span class="function"><span class="type">void</span> <span class="title">setMessageCallback</span><span class="params">(<span class="type">const</span> MessageCallback &amp;cb)</span> </span>&#123; messageCallback_ = cb; &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/// Set write complete callback.</span></span><br><span class="line">            <span class="comment">/// Not thread safe.</span></span><br><span class="line">            <span class="comment">/// 在发送完消息以后调用，这个函数指针会赋值给TcpConnection::writeCompleteCallback_函数</span></span><br><span class="line">            <span class="function"><span class="type">void</span> <span class="title">setWriteCompleteCallback</span><span class="params">(<span class="type">const</span> WriteCompleteCallback &amp;cb)</span> </span>&#123; writeCompleteCallback_ = cb; &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span>:</span><br><span class="line">            <span class="comment">/// Not thread safe, but in loop</span></span><br><span class="line">            <span class="function"><span class="type">void</span> <span class="title">newConnection</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> InetAddress &amp;peerAddr)</span></span>;</span><br><span class="line">            <span class="comment">//这个函数会赋值给Acceptor::newConnectionCallback_，在新连接建立以后调用</span></span><br><span class="line">            <span class="comment">/// Thread safe.</span></span><br><span class="line">            <span class="comment">/// 会赋值给TcpConnection::closeCallback_函数，也就是当连接描述符关闭以后调用这个</span></span><br><span class="line">            <span class="function"><span class="type">void</span> <span class="title">removeConnection</span><span class="params">(<span class="type">const</span> TcpConnectionPtr &amp;conn)</span></span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/// Not thread safe, but in loop，在上面这个函数removeConnection中调用</span></span><br><span class="line">            <span class="function"><span class="type">void</span> <span class="title">removeConnectionInLoop</span><span class="params">(<span class="type">const</span> TcpConnectionPtr &amp;conn)</span></span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">typedef</span> std::map &lt;string, TcpConnectionPtr&gt; ConnectionMap;</span><br><span class="line"></span><br><span class="line">            EventLoop *loop_;  <span class="comment">// the acceptor loop</span></span><br><span class="line">            <span class="type">const</span> string hostport_;        <span class="comment">// 服务的ip:端口</span></span><br><span class="line">            <span class="type">const</span> string name_;            <span class="comment">// 服务名</span></span><br><span class="line">            boost::scoped_ptr &lt;Acceptor&gt; acceptor_; <span class="comment">// avoid revealing Acceptor</span></span><br><span class="line">            boost::scoped_ptr &lt;EventLoopThreadPool&gt; threadPool_;</span><br><span class="line">            ConnectionCallback connectionCallback_;</span><br><span class="line">            MessageCallback messageCallback_;</span><br><span class="line">            WriteCompleteCallback writeCompleteCallback_;        <span class="comment">// 数据发送完毕，会回调此函数</span></span><br><span class="line">            ThreadInitCallback threadInitCallback_;    <span class="comment">// IO线程池中的线程在进入事件循环前，会回调用此函数</span></span><br><span class="line">            <span class="type">bool</span> started_;</span><br><span class="line">            <span class="comment">// always in loop thread</span></span><br><span class="line">            <span class="type">int</span> nextConnId_;                <span class="comment">// 下一个连接ID,每次增加一个就加1</span></span><br><span class="line">            ConnectionMap connections_;    <span class="comment">// 连接列表</span></span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span>  <span class="comment">// MUDUO_NET_TCPSERVER_H</span></span></span><br></pre></td></tr></table></figure>

<p>TcpServer.cc</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;muduo/net/TcpServer.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;muduo/base/Logging.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;muduo/net/Acceptor.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;muduo/net/EventLoop.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;muduo/net/EventLoopThreadPool.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;muduo/net/SocketsOps.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/bind.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span>  <span class="comment">// snprintf</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> muduo;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> muduo::net;</span><br><span class="line"></span><br><span class="line">TcpServer::<span class="built_in">TcpServer</span>(EventLoop *loop, <span class="type">const</span> InetAddress &amp;listenAddr,</span><br><span class="line">                     <span class="type">const</span> string &amp;nameArg)</span><br><span class="line">        : <span class="built_in">loop_</span>(<span class="built_in">CHECK_NOTNULL</span>(loop)),</span><br><span class="line">          <span class="built_in">hostport_</span>(listenAddr.<span class="built_in">toIpPort</span>()),</span><br><span class="line">          <span class="built_in">name_</span>(nameArg),</span><br><span class="line">          <span class="built_in">acceptor_</span>(<span class="keyword">new</span> <span class="built_in">Acceptor</span>(loop, listenAddr)),</span><br><span class="line">          <span class="built_in">threadPool_</span>(<span class="keyword">new</span> <span class="built_in">EventLoopThreadPool</span>(loop)),</span><br><span class="line">          <span class="built_in">connectionCallback_</span>(defaultConnectionCallback),</span><br><span class="line">          <span class="built_in">messageCallback_</span>(defaultMessageCallback),</span><br><span class="line">          <span class="built_in">started_</span>(<span class="literal">false</span>),</span><br><span class="line">          <span class="built_in">nextConnId_</span>(<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">// Acceptor::handleRead函数中会回调用TcpServer::newConnection</span></span><br><span class="line">    <span class="comment">// _1对应的是socket文件描述符，_2对应的是对等方的地址(InetAddress)</span></span><br><span class="line">    acceptor_-&gt;<span class="built_in">setNewConnectionCallback</span>(</span><br><span class="line">            boost::<span class="built_in">bind</span>(&amp;TcpServer::newConnection, <span class="keyword">this</span>, _1, _2));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">TcpServer::~<span class="built_in">TcpServer</span>() &#123;</span><br><span class="line">    loop_-&gt;<span class="built_in">assertInLoopThread</span>();</span><br><span class="line">    LOG_TRACE &lt;&lt; <span class="string">&quot;TcpServer::~TcpServer [&quot;</span> &lt;&lt; name_ &lt;&lt; <span class="string">&quot;] destructing&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (ConnectionMap::iterator <span class="built_in">it</span>(connections_.<span class="built_in">begin</span>());</span><br><span class="line">         it != connections_.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">        TcpConnectionPtr conn = it-&gt;second;</span><br><span class="line">        it-&gt;second.<span class="built_in">reset</span>();        <span class="comment">// 释放当前所控制的对象，引用计数减一</span></span><br><span class="line">        conn-&gt;<span class="built_in">getLoop</span>()-&gt;<span class="built_in">runInLoop</span>(</span><br><span class="line">                boost::<span class="built_in">bind</span>(&amp;TcpConnection::connectDestroyed, conn));</span><br><span class="line">        conn.<span class="built_in">reset</span>();            <span class="comment">// 释放当前所控制的对象，引用计数减一</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TcpServer::setThreadNum</span><span class="params">(<span class="type">int</span> numThreads)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(<span class="number">0</span> &lt;= numThreads);</span><br><span class="line">    threadPool_-&gt;<span class="built_in">setThreadNum</span>(numThreads);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 该函数多次调用是无害的</span></span><br><span class="line"><span class="comment">// 该函数可以跨线程调用</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TcpServer::start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!started_) &#123;</span><br><span class="line">        started_ = <span class="literal">true</span>;</span><br><span class="line">        threadPool_-&gt;<span class="built_in">start</span>(threadInitCallback_);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!acceptor_-&gt;<span class="built_in">listenning</span>()) &#123;</span><br><span class="line">        <span class="comment">// get_pointer返回原生指针</span></span><br><span class="line">        loop_-&gt;<span class="built_in">runInLoop</span>(</span><br><span class="line">                boost::<span class="built_in">bind</span>(&amp;Acceptor::listen, <span class="built_in">get_pointer</span>(acceptor_)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TcpServer::newConnection</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> InetAddress &amp;peerAddr)</span><span class="comment">//建立新连接以后的回调函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    loop_-&gt;<span class="built_in">assertInLoopThread</span>();</span><br><span class="line">    <span class="comment">// 按照轮叫的方式选择一个EventLoop</span></span><br><span class="line">    EventLoop *ioLoop = threadPool_-&gt;<span class="built_in">getNextLoop</span>();</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">32</span>];</span><br><span class="line">    <span class="built_in">snprintf</span>(buf, <span class="keyword">sizeof</span> buf, <span class="string">&quot;:%s#%d&quot;</span>, hostport_.<span class="built_in">c_str</span>(), nextConnId_);<span class="comment">//buf的内容是 ip:端口#nextConnId_</span></span><br><span class="line">    ++nextConnId_;</span><br><span class="line">    string connName = name_ + buf;</span><br><span class="line"></span><br><span class="line">    LOG_INFO &lt;&lt; <span class="string">&quot;TcpServer::newConnection [&quot;</span> &lt;&lt; name_</span><br><span class="line">             &lt;&lt; <span class="string">&quot;] - new connection [&quot;</span> &lt;&lt; connName</span><br><span class="line">             &lt;&lt; <span class="string">&quot;] from &quot;</span> &lt;&lt; peerAddr.<span class="built_in">toIpPort</span>();</span><br><span class="line">    <span class="function">InetAddress <span class="title">localAddr</span><span class="params">(sockets::getLocalAddr(sockfd))</span></span>;</span><br><span class="line">    <span class="comment">// FIXME poll with zero timeout to double confirm the new connection</span></span><br><span class="line">    <span class="comment">// FIXME use make_shared if necessary</span></span><br><span class="line">    <span class="comment">/*TcpConnectionPtr conn(new TcpConnection(loop_,</span></span><br><span class="line"><span class="comment">                                            connName,</span></span><br><span class="line"><span class="comment">                                            sockfd,</span></span><br><span class="line"><span class="comment">                                            localAddr,</span></span><br><span class="line"><span class="comment">                                            peerAddr));*/</span></span><br><span class="line"></span><br><span class="line">    <span class="function">TcpConnectionPtr <span class="title">conn</span><span class="params">(<span class="keyword">new</span> TcpConnection(ioLoop,</span></span></span><br><span class="line"><span class="params"><span class="function">                                            connName,</span></span></span><br><span class="line"><span class="params"><span class="function">                                            sockfd,</span></span></span><br><span class="line"><span class="params"><span class="function">                                            localAddr,</span></span></span><br><span class="line"><span class="params"><span class="function">                                            peerAddr))</span></span>;</span><br><span class="line"></span><br><span class="line">    LOG_TRACE &lt;&lt; <span class="string">&quot;[1] usecount=&quot;</span> &lt;&lt; conn.<span class="built_in">use_count</span>();</span><br><span class="line">    connections_[connName] = conn;<span class="comment">//将连接名和TCPConnection的指针拷贝进连接列表中，这样就有两个shared_ptr指针指向conn了，</span></span><br><span class="line">    <span class="comment">//如果没有这一句程序，这个conn在newConnection函数执行结束以后就会析构掉，所以真正要删除时，也要把这个列表中的对应元素也删除了。</span></span><br><span class="line">    LOG_TRACE &lt;&lt; <span class="string">&quot;[2] usecount=&quot;</span> &lt;&lt; conn.<span class="built_in">use_count</span>();</span><br><span class="line">    <span class="comment">//设置回调函数</span></span><br><span class="line">    conn-&gt;<span class="built_in">setConnectionCallback</span>(connectionCallback_);</span><br><span class="line">    conn-&gt;<span class="built_in">setMessageCallback</span>(messageCallback_);</span><br><span class="line">    conn-&gt;<span class="built_in">setWriteCompleteCallback</span>(writeCompleteCallback_);<span class="comment">//无论是否非空，都可以先设置，在使用之前会有判断</span></span><br><span class="line"></span><br><span class="line">    conn-&gt;<span class="built_in">setCloseCallback</span>(</span><br><span class="line">            boost::<span class="built_in">bind</span>(&amp;TcpServer::removeConnection, <span class="keyword">this</span>, _1));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// conn-&gt;connectEstablished();</span></span><br><span class="line">    ioLoop-&gt;<span class="built_in">runInLoop</span>(boost::<span class="built_in">bind</span>(&amp;TcpConnection::connectEstablished, conn));</span><br><span class="line">    <span class="comment">//bind在绑定类成员函数时，后面跟的参数一定比输入参数多一个，就是一个类指针，表明这个函数属于那个类变量的，</span></span><br><span class="line">    <span class="comment">//一般都使用this，而这里是用的TcpConnectionPtr</span></span><br><span class="line">    LOG_TRACE &lt;&lt; <span class="string">&quot;[5] usecount=&quot;</span> &lt;&lt; conn.<span class="built_in">use_count</span>();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TcpServer::removeConnection</span><span class="params">(<span class="type">const</span> TcpConnectionPtr &amp;conn)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">  loop_-&gt;assertInLoopThread();</span></span><br><span class="line"><span class="comment">  LOG_INFO &lt;&lt; &quot;TcpServer::removeConnectionInLoop [&quot; &lt;&lt; name_</span></span><br><span class="line"><span class="comment">           &lt;&lt; &quot;] - connection &quot; &lt;&lt; conn-&gt;name();</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  LOG_TRACE &lt;&lt; &quot;[8] usecount=&quot; &lt;&lt; conn.use_count();</span></span><br><span class="line"><span class="comment">  size_t n = connections_.erase(conn-&gt;name());</span></span><br><span class="line"><span class="comment">  LOG_TRACE &lt;&lt; &quot;[9] usecount=&quot; &lt;&lt; conn.use_count();</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  (void)n;</span></span><br><span class="line"><span class="comment">  assert(n == 1);</span></span><br><span class="line"><span class="comment">  </span></span><br><span class="line"><span class="comment">  loop_-&gt;queueInLoop(</span></span><br><span class="line"><span class="comment">      boost::bind(&amp;TcpConnection::connectDestroyed, conn));</span></span><br><span class="line"><span class="comment">  LOG_TRACE &lt;&lt; &quot;[10] usecount=&quot; &lt;&lt; conn.use_count();</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"></span><br><span class="line">    loop_-&gt;<span class="built_in">runInLoop</span>(boost::<span class="built_in">bind</span>(&amp;TcpServer::removeConnectionInLoop, <span class="keyword">this</span>, conn));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TcpServer::removeConnectionInLoop</span><span class="params">(<span class="type">const</span> TcpConnectionPtr &amp;conn)</span><span class="comment">//就是把TcpConnection从Eventloop中移除</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    loop_-&gt;<span class="built_in">assertInLoopThread</span>();</span><br><span class="line">    LOG_INFO &lt;&lt; <span class="string">&quot;TcpServer::removeConnectionInLoop [&quot;</span> &lt;&lt; name_</span><br><span class="line">             &lt;&lt; <span class="string">&quot;] - connection &quot;</span> &lt;&lt; conn-&gt;<span class="built_in">name</span>();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    LOG_TRACE &lt;&lt; <span class="string">&quot;[8] usecount=&quot;</span> &lt;&lt; conn.<span class="built_in">use_count</span>();</span><br><span class="line">    <span class="type">size_t</span> n = connections_.<span class="built_in">erase</span>(conn-&gt;<span class="built_in">name</span>());</span><br><span class="line">    LOG_TRACE &lt;&lt; <span class="string">&quot;[9] usecount=&quot;</span> &lt;&lt; conn.<span class="built_in">use_count</span>();</span><br><span class="line"></span><br><span class="line">    (<span class="type">void</span>) n;</span><br><span class="line">    <span class="built_in">assert</span>(n == <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    EventLoop *ioLoop = conn-&gt;<span class="built_in">getLoop</span>();</span><br><span class="line">    ioLoop-&gt;<span class="built_in">queueInLoop</span>(</span><br><span class="line">            boost::<span class="built_in">bind</span>(&amp;TcpConnection::connectDestroyed, conn));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//loop_-&gt;queueInLoop(</span></span><br><span class="line">    <span class="comment">//    boost::bind(&amp;TcpConnection::connectDestroyed, conn));</span></span><br><span class="line">    LOG_TRACE &lt;&lt; <span class="string">&quot;[10] usecount=&quot;</span> &lt;&lt; conn.<span class="built_in">use_count</span>();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>TcpConnection</strong></p>
<p>TcpConnection类主要负责封装一次TCP连接，向Channel类注册回调函数（可读、可写、可关闭、错误处理），将来当Channel类上的事件发生时，调用相应的回调函数进行数据收发或者错误处理。</p>
<p>TcpConnection是使用shared_ptr来管理的类，因为它的生命周期模糊。TcpConnection表示已经建立或正在建立的连接，建立连接后，用户只需要在上层类如TcpServer中设置连接到来和消息到来的处理函数，继而回调TcpConnection中的 setConnectionCallback和setMessageCallback函数，实现对事件的处理。用户需要关心的事件是有限的，其他都由网络库负责。</p>
<p>TcpConnection中封装了InputBuffer和OutputBuffer，用来表示应用层的缓冲区。在发送数据时，如果不能一次将Buffer中的数据发送完毕，它还会继续关注Channel中的可写事件，当sockfd可写时，会再次发送。</p>
<p>前面提到TcpConnection的生存期模糊，主要是因为我们不能在TcpServer中直接erase掉TcpConnection对象，因为此时有可能Channel中的handleEvent还在执行，如果析构TcpConnection对象，那么他的成员channel_也会被析构，会导致core dump。也就是说我们需要TcpConnection 对象生存期要长于handleEvent() 函数，直到执行完connectDestroyed() 后才会析构。</p>
<p><strong>断开连接：</strong></p>
<p>TcpConnection的断开是采用被动方式，即对方先关闭连接，本地read(2)返回0后，调用顺序如下：</p>
<p>handleClose()-&gt;TcpServer::removeConnection-&gt;TcpConnection::connectDestroyed()。</p>
<p>连接关闭时序图：</p>
<p>​    <img src="https://raw.githubusercontent.com/hufei96/Image/main/muduo_tcp_close.png" alt="img"></p>
<p>当连接到来，创建一个TcpConnection对象，立刻用shared_ptr来管理，引用计数为1，在Channel中维护一个weak_ptr（tie_），将这个shared_ptr对象赋值给_tie，引用计数仍然为1。当连接关闭时，在handleEvent中，将tie_提升，得到一个shard_ptr对象，引用计数就变成了2。当shared_ptr的计数不为0时，TcpConnection不会被销毁。</p>
<p>TcpConnection.h</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*这个类主要用来和buffer类一起作为非阻塞IO的一个读取桥梁，其中主要封装的函数是从文件描述符中读取传输的数据到</span></span><br><span class="line"><span class="comment"> *接受缓冲区中，或者把规定数据，或者触发写事件的输出缓冲区的数据写入对应的文件描述符中。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> MUDUO_NET_TCPCONNECTION_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MUDUO_NET_TCPCONNECTION_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;muduo/base/Mutex.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;muduo/base/StringPiece.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;muduo/base/Types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;muduo/net/Callbacks.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;muduo/net/Buffer.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;muduo/net/InetAddress.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/any.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/enable_shared_from_this.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/noncopyable.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/scoped_ptr.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/shared_ptr.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> muduo &#123;</span><br><span class="line">    <span class="keyword">namespace</span> net &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">class</span> <span class="title class_">Channel</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">class</span> <span class="title class_">EventLoop</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">class</span> <span class="title class_">Socket</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// TCP connection, for both client and server usage.</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// This is an interface class, so don&#x27;t expose too much details.</span></span><br><span class="line">        <span class="keyword">class</span> <span class="title class_">TcpConnection</span> : boost::noncopyable,<span class="keyword">public</span> boost::enable_shared_from_this&lt;TcpConnection&gt; &#123;</span><br><span class="line">        <span class="keyword">public</span>:</span><br><span class="line">            <span class="comment">/// Constructs a TcpConnection with a connected sockfd</span></span><br><span class="line">            <span class="comment">///</span></span><br><span class="line">            <span class="comment">/// User should not create this object.</span></span><br><span class="line">            <span class="built_in">TcpConnection</span>(EventLoop *loop,<span class="type">const</span> string &amp;name,<span class="type">int</span> sockfd,</span><br><span class="line">                          <span class="type">const</span> InetAddress &amp;localAddr,</span><br><span class="line">                          <span class="type">const</span> InetAddress &amp;peerAddr);</span><br><span class="line"></span><br><span class="line">            ~<span class="built_in">TcpConnection</span>();</span><br><span class="line"></span><br><span class="line">            <span class="function">EventLoop *<span class="title">getLoop</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> loop_; &#125;<span class="comment">//获取当前TcpConnection所在的Eventloop</span></span><br><span class="line">            <span class="function"><span class="type">const</span> string &amp;<span class="title">name</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> name_; &#125;<span class="comment">//</span></span><br><span class="line">            <span class="function"><span class="type">const</span> InetAddress &amp;<span class="title">localAddress</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> localAddr_; &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="type">const</span> InetAddress &amp;<span class="title">peerAddress</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> peerAddr_; &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="type">bool</span> <span class="title">connected</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> state_ == kConnected; &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// void send(string&amp;&amp; message); // C++11</span></span><br><span class="line">            <span class="function"><span class="type">void</span> <span class="title">send</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *message, <span class="type">size_t</span> len)</span></span>;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="type">void</span> <span class="title">send</span><span class="params">(<span class="type">const</span> StringPiece &amp;message)</span></span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// void send(Buffer&amp;&amp; message); // C++11</span></span><br><span class="line">            <span class="function"><span class="type">void</span> <span class="title">send</span><span class="params">(Buffer *message)</span></span>;  <span class="comment">// this one will swap data</span></span><br><span class="line">            <span class="function"><span class="type">void</span> <span class="title">shutdown</span><span class="params">()</span></span>; <span class="comment">// NOT thread safe, no simultaneous calling</span></span><br><span class="line">            <span class="function"><span class="type">void</span> <span class="title">setTcpNoDelay</span><span class="params">(<span class="type">bool</span> on)</span></span>;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="type">void</span> <span class="title">setContext</span><span class="params">(<span class="type">const</span> boost::any &amp;context)</span> </span>&#123; context_ = context; &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="type">const</span> boost::any &amp;<span class="title">getContext</span><span class="params">()</span> <span class="type">const</span><span class="comment">//得到常数值的context_</span></span></span><br><span class="line"><span class="function">            </span>&#123; <span class="keyword">return</span> context_; &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function">boost::any *<span class="title">getMutableContext</span><span class="params">()</span><span class="comment">//得到可以改变的context_</span></span></span><br><span class="line"><span class="function">            </span>&#123; <span class="keyword">return</span> &amp;context_; &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="type">void</span> <span class="title">setConnectionCallback</span><span class="params">(<span class="type">const</span> ConnectionCallback &amp;cb)</span> </span>&#123; connectionCallback_ = cb; &#125;</span><br><span class="line">            <span class="comment">//在handleClose，connectEstablished，connectDestroyed中调用，个人理解这个连接回调函数主要起到</span></span><br><span class="line">            <span class="comment">//显示作用，就是在和连接描述符建立连接或者关闭连接前，显示连接状态的，表明还在连接中</span></span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="type">void</span> <span class="title">setMessageCallback</span><span class="params">(<span class="type">const</span> MessageCallback &amp;cb)</span> </span>&#123; messageCallback_ = cb; &#125;</span><br><span class="line">            <span class="comment">//在handleRead函数当中调用了，也可以理解为channel_写函数的一部分</span></span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="type">void</span> <span class="title">setWriteCompleteCallback</span><span class="params">(<span class="type">const</span> WriteCompleteCallback &amp;cb)</span> </span>&#123; writeCompleteCallback_ = cb; &#125;</span><br><span class="line">            <span class="comment">//在handleWrite和sendInLoop写函数中，写完调用的</span></span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="type">void</span> <span class="title">setHighWaterMarkCallback</span><span class="params">(<span class="type">const</span> HighWaterMarkCallback &amp;cb, <span class="type">size_t</span> highWaterMark)</span> </span>&#123;</span><br><span class="line">                highWaterMarkCallback_ = cb;</span><br><span class="line">                highWaterMark_ = highWaterMark;</span><br><span class="line">            &#125;<span class="comment">//都在sendInLoop中调用了</span></span><br><span class="line"></span><br><span class="line">            <span class="function">Buffer *<span class="title">inputBuffer</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> &amp;inputBuffer_; &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/// Internal use only.</span></span><br><span class="line">            <span class="function"><span class="type">void</span> <span class="title">setCloseCallback</span><span class="params">(<span class="type">const</span> CloseCallback &amp;cb)</span> </span>&#123; closeCallback_ = cb; &#125;<span class="comment">//在handleClose函数中调用</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// called when TcpServer accepts a new connection</span></span><br><span class="line">            <span class="function"><span class="type">void</span> <span class="title">connectEstablished</span><span class="params">()</span></span>;   <span class="comment">// should be called only once</span></span><br><span class="line">            <span class="comment">// called when TcpServer has removed me from its map</span></span><br><span class="line">            <span class="function"><span class="type">void</span> <span class="title">connectDestroyed</span><span class="params">()</span></span>;  <span class="comment">// should be called only once</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span>:</span><br><span class="line">            <span class="keyword">enum</span> <span class="title class_">StateE</span> &#123;</span><br><span class="line">                kDisconnected, kConnecting, kConnected, kDisconnecting</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="type">void</span> <span class="title">handleRead</span><span class="params">(Timestamp receiveTime)</span></span>;<span class="comment">//绑定channel_的读函数</span></span><br><span class="line">            <span class="function"><span class="type">void</span> <span class="title">handleWrite</span><span class="params">()</span></span>;<span class="comment">//绑定channel_的写函数</span></span><br><span class="line">            <span class="function"><span class="type">void</span> <span class="title">handleClose</span><span class="params">()</span></span>;<span class="comment">//绑定channel_的关闭函数，同时也在handleRead中调用</span></span><br><span class="line">            <span class="function"><span class="type">void</span> <span class="title">handleError</span><span class="params">()</span></span>;<span class="comment">////绑定channel_的错误函数</span></span><br><span class="line">            <span class="function"><span class="type">void</span> <span class="title">sendInLoop</span><span class="params">(<span class="type">const</span> StringPiece &amp;message)</span></span>;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="type">void</span> <span class="title">sendInLoop</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *message, <span class="type">size_t</span> len)</span></span>;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="type">void</span> <span class="title">shutdownInLoop</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="type">void</span> <span class="title">setState</span><span class="params">(StateE s)</span> </span>&#123; state_ = s; &#125;<span class="comment">//设置状态位</span></span><br><span class="line"></span><br><span class="line">            EventLoop *loop_;            <span class="comment">// 所属EventLoop</span></span><br><span class="line">            string name_;                <span class="comment">// 连接名</span></span><br><span class="line">            StateE state_;  <span class="comment">// <span class="doctag">FIXME:</span> use atomic variable</span></span><br><span class="line">            <span class="comment">// we don&#x27;t expose those classes to client.</span></span><br><span class="line">            <span class="comment">//连接状态</span></span><br><span class="line">            boost::scoped_ptr &lt;Socket&gt; socket_;</span><br><span class="line">            boost::scoped_ptr &lt;Channel&gt; channel_;</span><br><span class="line">            <span class="comment">//channel_在TCPServer中绑定了连接套接字，就是能够实现通信的那个connfd套接字，这个套接字是从Socket::accept函数得到的</span></span><br><span class="line">            <span class="comment">//在Tcpclient绑定的是创建的套接字，因为客户端只需要一个套接字就可以了，这个套接字是从socket()函数中得到的</span></span><br><span class="line">            InetAddress localAddr_;<span class="comment">//当前服务端的地址</span></span><br><span class="line">            InetAddress peerAddr_;<span class="comment">//当前建立连接的客户端地址</span></span><br><span class="line">            ConnectionCallback connectionCallback_;</span><br><span class="line">            MessageCallback messageCallback_;</span><br><span class="line">            WriteCompleteCallback writeCompleteCallback_;        <span class="comment">// 数据发送完毕回调函数，即所有的用户数据都已拷贝到内核缓冲区时回调该函数</span></span><br><span class="line">            <span class="comment">// outputBuffer_被清空也会回调该函数，可以理解为低水位标回调函数</span></span><br><span class="line">            HighWaterMarkCallback highWaterMarkCallback_;        <span class="comment">// 高水位标回调函数</span></span><br><span class="line">            CloseCallback closeCallback_;</span><br><span class="line">            <span class="type">size_t</span> highWaterMark_;        <span class="comment">// 高水位标</span></span><br><span class="line">            Buffer inputBuffer_;            <span class="comment">// 应用层接收缓冲区</span></span><br><span class="line">            Buffer outputBuffer_;            <span class="comment">// 应用层发送缓冲区</span></span><br><span class="line">            boost::any context_;            <span class="comment">// 绑定一个未知类型的上下文对象，一般用来放HttpContext类的</span></span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">typedef</span> boost::shared_ptr &lt;TcpConnection&gt; TcpConnectionPtr;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span>  <span class="comment">// MUDUO_NET_TCPCONNECTION_H</span></span></span><br></pre></td></tr></table></figure>

<p>TcpConnection.cc</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;muduo/net/TcpConnection.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;muduo/base/Logging.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;muduo/net/Channel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;muduo/net/EventLoop.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;muduo/net/Socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;muduo/net/SocketsOps.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/bind.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> muduo;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> muduo::net;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> muduo::net::<span class="built_in">defaultConnectionCallback</span>(<span class="type">const</span> TcpConnectionPtr &amp;conn)<span class="comment">//默认的连接回调函数，输出连接状态</span></span><br><span class="line">&#123;</span><br><span class="line">    LOG_TRACE &lt;&lt; conn-&gt;<span class="built_in">localAddress</span>().<span class="built_in">toIpPort</span>() &lt;&lt; <span class="string">&quot; -&gt; &quot;</span></span><br><span class="line">              &lt;&lt; conn-&gt;<span class="built_in">peerAddress</span>().<span class="built_in">toIpPort</span>() &lt;&lt; <span class="string">&quot; is &quot;</span></span><br><span class="line">              &lt;&lt; (conn-&gt;<span class="built_in">connected</span>() ? <span class="string">&quot;UP&quot;</span> : <span class="string">&quot;DOWN&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> muduo::net::<span class="built_in">defaultMessageCallback</span>(<span class="type">const</span> TcpConnectionPtr &amp;, Buffer *buf, Timestamp)</span><br><span class="line"><span class="comment">//默认的有消息时执行的回调函数，把缓冲区读指针和写指针回到初始化的位置</span></span><br><span class="line"><span class="comment">//可以理解为将缓冲区清零</span></span><br><span class="line">&#123;</span><br><span class="line">    buf-&gt;<span class="built_in">retrieveAll</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">TcpConnection::<span class="built_in">TcpConnection</span>(EventLoop *loop, <span class="type">const</span> string &amp;nameArg, <span class="type">int</span> sockfd,</span><br><span class="line">                             <span class="type">const</span> InetAddress &amp;localAddr,</span><br><span class="line">                             <span class="type">const</span> InetAddress &amp;peerAddr)</span><br><span class="line">        : <span class="built_in">loop_</span>(<span class="built_in">CHECK_NOTNULL</span>(loop)), <span class="comment">// 所属EventLoop</span></span><br><span class="line">          <span class="built_in">name_</span>(nameArg),<span class="comment">// 连接名</span></span><br><span class="line">          <span class="built_in">state_</span>(kConnecting),<span class="comment">//连接状态</span></span><br><span class="line">          <span class="built_in">socket_</span>(<span class="keyword">new</span> <span class="built_in">Socket</span>(sockfd)),<span class="comment">//连接套接字</span></span><br><span class="line">          <span class="built_in">channel_</span>(<span class="keyword">new</span> <span class="built_in">Channel</span>(loop, sockfd)),</span><br><span class="line">          <span class="comment">//channel_在TCPServer中绑定了连接套接字，就是能够实现通信的那个connfd套接字，这个套接字是从Socket::accept函数得到的</span></span><br><span class="line">          <span class="comment">//在Tcpclient绑定的是创建的套接字，因为客户端只需要一个套接字就可以了，这个套接字是从socket()函数中得到的</span></span><br><span class="line">          <span class="built_in">localAddr_</span>(localAddr),<span class="comment">//当前服务端的地址</span></span><br><span class="line">          <span class="built_in">peerAddr_</span>(peerAddr),<span class="comment">//当前建立连接的客户端地址</span></span><br><span class="line">          <span class="built_in">highWaterMark_</span>(<span class="number">64</span> * <span class="number">1024</span> * <span class="number">1024</span>) &#123;</span><br><span class="line">    <span class="comment">// 通道可读事件到来的时候，回调TcpConnection::handleRead，_1是事件发生时间</span></span><br><span class="line">    channel_-&gt;<span class="built_in">setReadCallback</span>(boost::<span class="built_in">bind</span>(&amp;TcpConnection::handleRead, <span class="keyword">this</span>, _1));</span><br><span class="line">    <span class="comment">// 通道可写事件到来的时候，回调TcpConnection::handleWrite</span></span><br><span class="line">    channel_-&gt;<span class="built_in">setWriteCallback</span>(boost::<span class="built_in">bind</span>(&amp;TcpConnection::handleWrite, <span class="keyword">this</span>));</span><br><span class="line">    <span class="comment">// 连接关闭，回调TcpConnection::handleClose</span></span><br><span class="line">    channel_-&gt;<span class="built_in">setCloseCallback</span>(boost::<span class="built_in">bind</span>(&amp;TcpConnection::handleClose, <span class="keyword">this</span>));</span><br><span class="line">    <span class="comment">// 发生错误，回调TcpConnection::handleError</span></span><br><span class="line">    channel_-&gt;<span class="built_in">setErrorCallback</span>(boost::<span class="built_in">bind</span>(&amp;TcpConnection::handleError, <span class="keyword">this</span>));</span><br><span class="line">    LOG_DEBUG &lt;&lt; <span class="string">&quot;TcpConnection::ctor[&quot;</span> &lt;&lt; name_ &lt;&lt; <span class="string">&quot;] at &quot;</span> &lt;&lt; <span class="keyword">this</span>&lt;&lt; <span class="string">&quot; fd=&quot;</span> &lt;&lt; sockfd;</span><br><span class="line">    socket_-&gt;<span class="built_in">setKeepAlive</span>(<span class="literal">true</span>);<span class="comment">//定期探测连接是否存在，类似于心跳包</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">TcpConnection::~<span class="built_in">TcpConnection</span>() &#123;</span><br><span class="line">    LOG_DEBUG &lt;&lt; <span class="string">&quot;TcpConnection::dtor[&quot;</span> &lt;&lt; name_ &lt;&lt; <span class="string">&quot;] at &quot;</span> &lt;&lt; <span class="keyword">this</span></span><br><span class="line">              &lt;&lt; <span class="string">&quot; fd=&quot;</span> &lt;&lt; channel_-&gt;<span class="built_in">fd</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程安全，可以跨线程调用</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TcpConnection::send</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *data, <span class="type">size_t</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (state_ == kConnected) &#123;</span><br><span class="line">        <span class="keyword">if</span> (loop_-&gt;<span class="built_in">isInLoopThread</span>()) &#123;</span><br><span class="line">            <span class="built_in">sendInLoop</span>(data, len);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            string <span class="built_in">message</span>(<span class="built_in">static_cast</span>&lt;<span class="type">const</span> <span class="type">char</span> *&gt;(data), len);</span><br><span class="line">            loop_-&gt;<span class="built_in">runInLoop</span>(boost::<span class="built_in">bind</span>(&amp;TcpConnection::sendInLoop,<span class="keyword">this</span>,message));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程安全，可以跨线程调用</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TcpConnection::send</span><span class="params">(<span class="type">const</span> StringPiece &amp;message)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (state_ == kConnected) &#123;</span><br><span class="line">        <span class="keyword">if</span> (loop_-&gt;<span class="built_in">isInLoopThread</span>()) &#123;</span><br><span class="line">            <span class="built_in">sendInLoop</span>(message);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            loop_-&gt;<span class="built_in">runInLoop</span>(boost::<span class="built_in">bind</span>(&amp;TcpConnection::sendInLoop,<span class="keyword">this</span>,message.<span class="built_in">as_string</span>()));</span><br><span class="line">            <span class="comment">//std::forward&lt;string&gt;(message)));</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程安全，可以跨线程调用</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TcpConnection::send</span><span class="params">(Buffer *buf)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (state_ == kConnected) &#123;</span><br><span class="line">        <span class="keyword">if</span> (loop_-&gt;<span class="built_in">isInLoopThread</span>()) &#123;</span><br><span class="line">            <span class="built_in">sendInLoop</span>(buf-&gt;<span class="built_in">peek</span>(), buf-&gt;<span class="built_in">readableBytes</span>());</span><br><span class="line">            buf-&gt;<span class="built_in">retrieveAll</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            loop_-&gt;<span class="built_in">runInLoop</span>(boost::<span class="built_in">bind</span>(&amp;TcpConnection::sendInLoop,<span class="keyword">this</span>,buf-&gt;<span class="built_in">retrieveAllAsString</span>()));</span><br><span class="line">            <span class="comment">//std::forward&lt;string&gt;(message)));</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TcpConnection::sendInLoop</span><span class="params">(<span class="type">const</span> StringPiece &amp;message)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">sendInLoop</span>(message.<span class="built_in">data</span>(), message.<span class="built_in">size</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TcpConnection::sendInLoop</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *data, <span class="type">size_t</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    loop_-&gt;assertInLoopThread();</span></span><br><span class="line"><span class="comment">    sockets::write(channel_-&gt;fd(), data, len);</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    loop_-&gt;<span class="built_in">assertInLoopThread</span>();</span><br><span class="line">    <span class="type">ssize_t</span> nwrote = <span class="number">0</span>;</span><br><span class="line">    <span class="type">size_t</span> remaining = len;</span><br><span class="line">    <span class="type">bool</span> error = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (state_ == kDisconnected) &#123;</span><br><span class="line">        LOG_WARN &lt;&lt; <span class="string">&quot;disconnected, give up writing&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// if no thing in output queue, try writing directly</span></span><br><span class="line">    <span class="comment">// 通道没有关注可写事件并且发送缓冲区没有数据，直接write</span></span><br><span class="line">    <span class="keyword">if</span> (!channel_-&gt;<span class="built_in">isWriting</span>() &amp;&amp; outputBuffer_.<span class="built_in">readableBytes</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">        nwrote = sockets::<span class="built_in">write</span>(channel_-&gt;<span class="built_in">fd</span>(), data, len);</span><br><span class="line">        <span class="keyword">if</span> (nwrote &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            remaining = len - nwrote;</span><br><span class="line">            <span class="comment">// 写完了，回调writeCompleteCallback_</span></span><br><span class="line">            <span class="keyword">if</span> (remaining == <span class="number">0</span> &amp;&amp; writeCompleteCallback_) &#123;</span><br><span class="line">                loop_-&gt;<span class="built_in">queueInLoop</span>(boost::<span class="built_in">bind</span>(writeCompleteCallback_, <span class="built_in">shared_from_this</span>()));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="comment">// nwrote &lt; 0</span></span><br><span class="line">        &#123;</span><br><span class="line">            nwrote = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (errno != EWOULDBLOCK) &#123;</span><br><span class="line">                LOG_SYSERR &lt;&lt; <span class="string">&quot;TcpConnection::sendInLoop&quot;</span>;</span><br><span class="line">                <span class="keyword">if</span> (errno == EPIPE) <span class="comment">// <span class="doctag">FIXME:</span> any others?</span></span><br><span class="line">                &#123;</span><br><span class="line">                    error = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">assert</span>(remaining &lt;= len);</span><br><span class="line">    <span class="comment">// 没有错误，并且还有未写完的数据（说明内核发送缓冲区满，要将未写完的数据添加到output buffer中）</span></span><br><span class="line">    <span class="keyword">if</span> (!error &amp;&amp; remaining &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        LOG_TRACE &lt;&lt; <span class="string">&quot;I am going to write more data&quot;</span>;</span><br><span class="line">        <span class="type">size_t</span> oldLen = outputBuffer_.<span class="built_in">readableBytes</span>();</span><br><span class="line">        <span class="comment">// 如果超过highWaterMark_（高水位标），回调highWaterMarkCallback_</span></span><br><span class="line">        <span class="keyword">if</span> (oldLen + remaining &gt;= highWaterMark_</span><br><span class="line">            &amp;&amp; oldLen &lt; highWaterMark_</span><br><span class="line">            &amp;&amp; highWaterMarkCallback_) &#123;</span><br><span class="line">            loop_-&gt;<span class="built_in">queueInLoop</span>(boost::<span class="built_in">bind</span>(highWaterMarkCallback_, <span class="built_in">shared_from_this</span>(), oldLen + remaining));</span><br><span class="line">        &#125;</span><br><span class="line">        outputBuffer_.<span class="built_in">append</span>(<span class="built_in">static_cast</span>&lt;<span class="type">const</span> <span class="type">char</span> *&gt;(data) + nwrote, remaining);<span class="comment">//将剩余数据存入应用层发送缓冲区</span></span><br><span class="line">        <span class="keyword">if</span> (!channel_-&gt;<span class="built_in">isWriting</span>()) &#123;</span><br><span class="line">            channel_-&gt;<span class="built_in">enableWriting</span>();        <span class="comment">// 关注POLLOUT事件</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TcpConnection::shutdown</span><span class="params">()</span><span class="comment">//关闭连接</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">FIXME:</span> use compare and swap</span></span><br><span class="line">    <span class="keyword">if</span> (state_ == kConnected) &#123;</span><br><span class="line">        <span class="built_in">setState</span>(kDisconnecting);</span><br><span class="line">        <span class="comment">// <span class="doctag">FIXME:</span> shared_from_this()?</span></span><br><span class="line">        loop_-&gt;<span class="built_in">runInLoop</span>(boost::<span class="built_in">bind</span>(&amp;TcpConnection::shutdownInLoop, <span class="keyword">this</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TcpConnection::shutdownInLoop</span><span class="params">()</span><span class="comment">//在loop中关闭写半边，还是可以读数据</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    loop_-&gt;<span class="built_in">assertInLoopThread</span>();</span><br><span class="line">    <span class="keyword">if</span> (!channel_-&gt;<span class="built_in">isWriting</span>()) &#123;</span><br><span class="line">        <span class="comment">// we are not writing</span></span><br><span class="line">        socket_-&gt;<span class="built_in">shutdownWrite</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TcpConnection::setTcpNoDelay</span><span class="params">(<span class="type">bool</span> on)</span><span class="comment">//设置TCP延迟连接</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    socket_-&gt;<span class="built_in">setTcpNoDelay</span>(on);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TcpConnection::connectEstablished</span><span class="params">()</span><span class="comment">//这个建立连接是TcpConnection类中的channel加入到对应的比如Tcpclient或者Tcpserver类所属的eventloop中</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    loop_-&gt;<span class="built_in">assertInLoopThread</span>();</span><br><span class="line">    <span class="built_in">assert</span>(state_ == kConnecting);<span class="comment">//设置正在连接状态</span></span><br><span class="line">    <span class="built_in">setState</span>(kConnected);</span><br><span class="line">    LOG_TRACE &lt;&lt; <span class="string">&quot;[3] usecount=&quot;</span> &lt;&lt; <span class="built_in">shared_from_this</span>().<span class="built_in">use_count</span>();</span><br><span class="line">    channel_-&gt;<span class="built_in">tie</span>(<span class="built_in">shared_from_this</span>());</span><br><span class="line">    channel_-&gt;<span class="built_in">enableReading</span>();    <span class="comment">// TcpConnection所对应的通道加入到Poller关注</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">connectionCallback_</span>(<span class="built_in">shared_from_this</span>());</span><br><span class="line">    LOG_TRACE &lt;&lt; <span class="string">&quot;[4] usecount=&quot;</span> &lt;&lt; <span class="built_in">shared_from_this</span>().<span class="built_in">use_count</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TcpConnection::connectDestroyed</span><span class="params">()</span><span class="comment">//取消连接，从对应的Eventloop上的epoll队列中去除</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    loop_-&gt;<span class="built_in">assertInLoopThread</span>();</span><br><span class="line">    <span class="keyword">if</span> (state_ == kConnected) &#123;</span><br><span class="line">        <span class="built_in">setState</span>(kDisconnected);</span><br><span class="line">        channel_-&gt;<span class="built_in">disableAll</span>();</span><br><span class="line"></span><br><span class="line">        <span class="built_in">connectionCallback_</span>(<span class="built_in">shared_from_this</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    channel_-&gt;<span class="built_in">remove</span>();<span class="comment">//将channel从epoll队列中移除</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TcpConnection::handleRead</span><span class="params">(Timestamp receiveTime)</span><span class="comment">//处理读事件的函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    loop_-&gt;assertInLoopThread();</span></span><br><span class="line"><span class="comment">    int savedErrno = 0;</span></span><br><span class="line"><span class="comment">    ssize_t n = inputBuffer_.readFd(channel_-&gt;fd(), &amp;savedErrno);</span></span><br><span class="line"><span class="comment">    if (n &gt; 0)</span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">      messageCallback_(shared_from_this(), &amp;inputBuffer_, receiveTime);</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    else if (n == 0)</span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">      handleClose();</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    else</span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">      errno = savedErrno;</span></span><br><span class="line"><span class="comment">      LOG_SYSERR &lt;&lt; &quot;TcpConnection::handleRead&quot;;</span></span><br><span class="line"><span class="comment">      handleError();</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    loop_-&gt;assertInLoopThread();</span></span><br><span class="line"><span class="comment">    int savedErrno = 0;</span></span><br><span class="line"><span class="comment">    char buf[65536];</span></span><br><span class="line"><span class="comment">    ssize_t n = ::read(channel_-&gt;fd(), buf, sizeof buf);</span></span><br><span class="line"><span class="comment">    if (n &gt; 0)</span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">      messageCallback_(shared_from_this(), buf, n);</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    else if (n == 0)</span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">      handleClose();</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    else</span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">      errno = savedErrno;</span></span><br><span class="line"><span class="comment">      LOG_SYSERR &lt;&lt; &quot;TcpConnection::handleRead&quot;;</span></span><br><span class="line"><span class="comment">      handleError();</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    loop_-&gt;<span class="built_in">assertInLoopThread</span>();</span><br><span class="line">    <span class="type">int</span> savedErrno = <span class="number">0</span>;</span><br><span class="line">    <span class="type">ssize_t</span> n = inputBuffer_.<span class="built_in">readFd</span>(channel_-&gt;<span class="built_in">fd</span>(), &amp;savedErrno);<span class="comment">//直接将数据读到inputBuffer_缓冲区</span></span><br><span class="line">    <span class="keyword">if</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">messageCallback_</span>(<span class="built_in">shared_from_this</span>(), &amp;inputBuffer_, receiveTime);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">handleClose</span>();<span class="comment">//如果读到的数据为0，就自动退出</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        errno = savedErrno;</span><br><span class="line">        LOG_SYSERR &lt;&lt; <span class="string">&quot;TcpConnection::handleRead&quot;</span>;</span><br><span class="line">        <span class="built_in">handleError</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听到写事件了，就调用这个函数，此时服务器已经把要写的内容写到outputBuffer_中去了，所以要写的内容从读指针处开始</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TcpConnection::handleWrite</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    loop_-&gt;<span class="built_in">assertInLoopThread</span>();</span><br><span class="line">    <span class="keyword">if</span> (channel_-&gt;<span class="built_in">isWriting</span>())<span class="comment">//查看是否有写事件需要关注</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">ssize_t</span> n = sockets::<span class="built_in">write</span>(channel_-&gt;<span class="built_in">fd</span>(),</span><br><span class="line">                                   outputBuffer_.<span class="built_in">peek</span>(),</span><br><span class="line">                                   outputBuffer_.<span class="built_in">readableBytes</span>());<span class="comment">//写到文件描述符中去</span></span><br><span class="line">        <span class="keyword">if</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            outputBuffer_.<span class="built_in">retrieve</span>(n);<span class="comment">//处理读写指针</span></span><br><span class="line">            <span class="keyword">if</span> (outputBuffer_.<span class="built_in">readableBytes</span>() == <span class="number">0</span>)     <span class="comment">// 发送缓冲区已清空</span></span><br><span class="line">            &#123;</span><br><span class="line">                channel_-&gt;<span class="built_in">disableWriting</span>();        <span class="comment">// 停止关注POLLOUT事件，以免出现busy loop</span></span><br><span class="line">                <span class="keyword">if</span> (writeCompleteCallback_)        <span class="comment">// 回调writeCompleteCallback_</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// 应用层发送缓冲区被清空，就回调用writeCompleteCallback_</span></span><br><span class="line">                    <span class="comment">// 发送给IO线程进行处理</span></span><br><span class="line">                    loop_-&gt;<span class="built_in">queueInLoop</span>(boost::<span class="built_in">bind</span>(writeCompleteCallback_, <span class="built_in">shared_from_this</span>()));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (state_ == kDisconnecting)    <span class="comment">// 发送缓冲区已清空并且连接状态是kDisconnecting, 要关闭连接</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">shutdownInLoop</span>();        <span class="comment">// 关闭写连接</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                LOG_TRACE &lt;&lt; <span class="string">&quot;I am going to write more data&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            LOG_SYSERR &lt;&lt; <span class="string">&quot;TcpConnection::handleWrite&quot;</span>;</span><br><span class="line">            <span class="comment">// if (state_ == kDisconnecting)</span></span><br><span class="line">            <span class="comment">// &#123;</span></span><br><span class="line">            <span class="comment">//   shutdownInLoop();</span></span><br><span class="line">            <span class="comment">// &#125;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        LOG_TRACE &lt;&lt; <span class="string">&quot;Connection fd = &quot;</span> &lt;&lt; channel_-&gt;<span class="built_in">fd</span>()</span><br><span class="line">                  &lt;&lt; <span class="string">&quot; is down, no more writing&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TcpConnection::handleClose</span><span class="params">()</span><span class="comment">//关闭事件处理，也是epoll如果发生关闭事件的回调函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    loop_-&gt;<span class="built_in">assertInLoopThread</span>();</span><br><span class="line">    LOG_TRACE &lt;&lt; <span class="string">&quot;fd = &quot;</span> &lt;&lt; channel_-&gt;<span class="built_in">fd</span>() &lt;&lt; <span class="string">&quot; state = &quot;</span> &lt;&lt; state_;</span><br><span class="line">    <span class="built_in">assert</span>(state_ == kConnected || state_ == kDisconnecting);</span><br><span class="line">    <span class="comment">// we don&#x27;t close fd, leave it to dtor, so we can find leaks easily.</span></span><br><span class="line">    <span class="built_in">setState</span>(kDisconnected);</span><br><span class="line">    channel_-&gt;<span class="built_in">disableAll</span>();</span><br><span class="line"></span><br><span class="line">    <span class="function">TcpConnectionPtr <span class="title">guardThis</span><span class="params">(shared_from_this())</span></span>;</span><br><span class="line">    <span class="built_in">connectionCallback_</span>(guardThis);        <span class="comment">// 在结束前，最后一次处理一下，这一行，可以不调用</span></span><br><span class="line">    LOG_TRACE &lt;&lt; <span class="string">&quot;[7] usecount=&quot;</span> &lt;&lt; guardThis.<span class="built_in">use_count</span>();</span><br><span class="line">    <span class="comment">// must be the last line</span></span><br><span class="line">    <span class="built_in">closeCallback_</span>(guardThis);    <span class="comment">// 调用TcpServer::removeConnection</span></span><br><span class="line">    LOG_TRACE &lt;&lt; <span class="string">&quot;[11] usecount=&quot;</span> &lt;&lt; guardThis.<span class="built_in">use_count</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TcpConnection::handleError</span><span class="params">()</span><span class="comment">//处理错误的函数，也是epoll如果发生错误事件的回调函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> err = sockets::<span class="built_in">getSocketError</span>(channel_-&gt;<span class="built_in">fd</span>());</span><br><span class="line">    LOG_ERROR &lt;&lt; <span class="string">&quot;TcpConnection::handleError [&quot;</span> &lt;&lt; name_</span><br><span class="line">              &lt;&lt; <span class="string">&quot;] - SO_ERROR = &quot;</span> &lt;&lt; err &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; <span class="built_in">strerror_tl</span>(err);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="timer"><a href="#timer" class="headerlink" title="timer"></a>timer</h3><p>Muduo的定时器功能主要由三个class实现，TimerId，Timer，TimerQueue，TimerQueue的接口只有两个addTimer()和cancel()，addTimer()是提供给EventLoop使用的， EventLoop会把它封装成更好用的三个函数：runAt()、runAfter()、runEvery()。</p>
<p><strong>大体实现</strong></p>
<p>muduo 定时器封装了 Timer.h 里面保存的是超时时间和回调函数, TimerQueue.h 使用set容器保存多个定时器, 然后在TimerQueue中使用timerfd_create创建一个timerfd句柄, 插入定时器A后先比较A的触发时间和TimerQueue的触发时间, 如果A的触发时间比其小就使用timerfd_settime重置TimerQueue的timerfd的触发时间, TimerQueue中的timerfd的触发时间永远与保存的定时器中触发时间最小的那个相同, 然后timerfd触发可读后, 遍历保存的多个定时器, 看看有没有同时到期的, 有执行回调函数</p>
<p>TimerQueue的封装是为了让未到期的时间Timer有序的排列起来，这样，能够更具当前时间找到已经到期的Timer也能高效的添加和删除Timer。</p>
<p>所谓的到期与未到期，与当前在当前时间之前表示已经到期，之后则是未到期。为了方便计算，muduo重载了operator&lt;主要是用来比较微秒大小。</p>
<p>到期的时间应该被清除去执行相应的回调，未到期的时间则应该有序的排列起来。</p>
<p> 对于TimerQueue的数据结构，作者提出了几个方案。</p>
<p>1.传统线性表，查找复杂度为O(n)</p>
<p>2.二叉堆实现优先级队列，不过C++标准的make_heap()不能高效地完成删除操作。</p>
<p> 最终，为了防止时间相同所导致的Key相同的情况，使用set和pair</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">typedef std::pair&lt;Timestamp, Timer*&gt;Entry;</span><br><span class="line"></span><br><span class="line">typedef std::set&lt;Entry&gt;TimerList;</span><br><span class="line"></span><br><span class="line">TimerList timers_;</span><br></pre></td></tr></table></figure>

<p><strong>timerfd介绍</strong></p>
<p>这节介绍muduo中定时器的实现。先看一个2.6内核新增的有关定时的系统调用，基于这几个系统调用可以实现基于文件描述符的定时器。使文件描述符在某一特定时间可读。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/timerfd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">timerfd_create</span><span class="params">(<span class="type">int</span> clockid, <span class="type">int</span> flags)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">timerfd_settime</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span> flags,</span></span></span><br><span class="line"><span class="params"><span class="function">           <span class="type">const</span> <span class="keyword">struct</span> itimerspec * new_value,</span></span></span><br><span class="line"><span class="params"><span class="function">           <span class="keyword">struct</span> itimerspec * old_value)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">timerfd_gettime</span><span class="params">(<span class="type">int</span> fd, <span class="keyword">struct</span> itimerspec *curr_value)</span></span>;</span><br></pre></td></tr></table></figure>

<p>1、timerfd_create用于创建一个定时器文件，函数返回值是一个文件句柄fd。</p>
<p>2、timerfd_settime用于设置新的超时时间，并开始计时。flag为0表示相对时间，为1表示绝对时间。new_value为这次设置的新时间，old_value为上次设置的时间。返回0表示设置成功。</p>
<p>3、timerfd_gettime用于获得定时器距离下次超时还剩下的时间。如果调用时定时器已经到期，并且该定时器处于循环模式（设置超时时间时struct itimerspec::it_interval不为0），那么调用此函数之后定时器重新开始计时。</p>
<p><strong>TimerId介绍</strong></p>
<p>TimerId非常简单，它被设计用来取消Timer的，它的结构很简单，只有一个Timer指针和其序列号。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*封装了timer类到构造和析构函数中，我的理解就是RAII的思想</span></span><br><span class="line"><span class="comment"> * TimerId非常简单，它被设计用来取消Timer的，它的结构很简单，只有一个Timer指针和其序列号。*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> MUDUO_NET_TIMERID_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MUDUO_NET_TIMERID_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;muduo/base/copyable.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> muduo &#123;</span><br><span class="line">    <span class="keyword">namespace</span> net &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">class</span> <span class="title class_">Timer</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// An opaque identifier, for canceling Timer.</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line">        <span class="keyword">class</span> <span class="title class_">TimerId</span> : <span class="keyword">public</span> muduo::copyable &#123;</span><br><span class="line">        <span class="keyword">public</span>:</span><br><span class="line">            <span class="built_in">TimerId</span>()</span><br><span class="line">                    : <span class="built_in">timer_</span>(<span class="literal">NULL</span>),</span><br><span class="line">                      <span class="built_in">sequence_</span>(<span class="number">0</span>) &#123;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">TimerId</span>(Timer *timer, <span class="type">int64_t</span> seq)</span><br><span class="line">                    : <span class="built_in">timer_</span>(timer),</span><br><span class="line">                      <span class="built_in">sequence_</span>(seq) &#123;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// default copy-ctor, dtor and assignment are okay</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">TimerQueue</span>;<span class="comment">//友元，就是可以访问类的私有成员变量，但不是类中的成员</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span>:</span><br><span class="line">            Timer *timer_;</span><br><span class="line">            <span class="type">int64_t</span> sequence_;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span>  <span class="comment">// MUDUO_NET_TIMERID_H</span></span></span><br></pre></td></tr></table></figure>

<p><strong>Timer</strong></p>
<p>Timer封装了定时器的一些参数，例如超时回调函数、超时时间、定时器是否重复、重复间隔时间、定时器的序列号。其函数大都是设置这些参数，run()用来调用回调函数，restart()用来重启定时器（如果设置为重复）。其源码相对简单</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*计时器类*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> MUDUO_NET_TIMER_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MUDUO_NET_TIMER_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/noncopyable.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;muduo/base/Atomic.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;muduo/base/Timestamp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;muduo/net/Callbacks.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> muduo &#123;</span><br><span class="line">    <span class="keyword">namespace</span> net &#123;</span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// Internal class for timer event.</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line">        <span class="keyword">class</span> <span class="title class_">Timer</span> : boost::noncopyable &#123;</span><br><span class="line">        <span class="keyword">public</span>:</span><br><span class="line">            <span class="built_in">Timer</span>(<span class="type">const</span> TimerCallback &amp;cb, Timestamp when, <span class="type">double</span> interval)</span><br><span class="line">                    : <span class="built_in">callback_</span>(cb),<span class="comment">//回调函数</span></span><br><span class="line">                      <span class="built_in">expiration_</span>(when),<span class="comment">//超时时间</span></span><br><span class="line">                      <span class="built_in">interval_</span>(interval),<span class="comment">//如果重复，间隔时间</span></span><br><span class="line">                      <span class="built_in">repeat_</span>(interval &gt; <span class="number">0.0</span>),<span class="comment">//如果间隔大于0，就重复</span></span><br><span class="line">                      <span class="built_in">sequence_</span>(s_numCreated_.<span class="built_in">incrementAndGet</span>()) &#123;&#125;<span class="comment">//当前定时器的序列号</span></span><br><span class="line">            <span class="comment">//调用回调函数.</span></span><br><span class="line">            <span class="function"><span class="type">void</span> <span class="title">run</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">                <span class="built_in">callback_</span>();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function">Timestamp <span class="title">expiration</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> expiration_; &#125;<span class="comment">//返回超时时刻</span></span><br><span class="line">            <span class="function"><span class="type">bool</span> <span class="title">repeat</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> repeat_; &#125;<span class="comment">//返回是否重复</span></span><br><span class="line">            <span class="function"><span class="type">int64_t</span> <span class="title">sequence</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> sequence_; &#125;<span class="comment">//返回定时器序号</span></span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="type">void</span> <span class="title">restart</span><span class="params">(Timestamp now)</span></span>;<span class="comment">//重新开始</span></span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="type">static</span> <span class="type">int64_t</span> <span class="title">numCreated</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> s_numCreated_.<span class="built_in">get</span>(); &#125;<span class="comment">//返回最新的序号值</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span>:</span><br><span class="line">            <span class="type">const</span> TimerCallback callback_;        <span class="comment">// 定时器回调函数</span></span><br><span class="line">            Timestamp expiration_;                <span class="comment">// 下一次的超时时间戳类</span></span><br><span class="line">            <span class="type">const</span> <span class="type">double</span> interval_;                <span class="comment">// 超时时间间隔，如果是一次性定时器，该值为0</span></span><br><span class="line">            <span class="type">const</span> <span class="type">bool</span> repeat_;                    <span class="comment">// 是否重复</span></span><br><span class="line">            <span class="type">const</span> <span class="type">int64_t</span> sequence_;                <span class="comment">// 定时器序号，不会重复</span></span><br><span class="line"></span><br><span class="line">            <span class="type">static</span> AtomicInt64 s_numCreated_;        <span class="comment">// 定时器计数，当前已经创建的定时器数量</span></span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span>  <span class="comment">// MUDUO_NET_TIMER_H</span></span></span><br></pre></td></tr></table></figure>

<p><strong>TimerQueue</strong></p>
<p>虽然TimerQueue中有Queue，但是其实现时基于Set的，而不是Queue。这样可以高效地插入、删除定时器，且找到当前已经超时的定时器。TimerQueue的public接口只有两个，添加和删除。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">void addTimerInLoop(Timer* timer);</span><br><span class="line"></span><br><span class="line">void cancelInLoop(TimerId timerId);</span><br></pre></td></tr></table></figure>

<p>定时器管理类，其中timer类就是TimerQueue需要管理的元素，而timerId就是一个简单的timer封装，避免销毁和创建操作</p>
<p>但是要注意的是timer并没有自己计时的功能，所以需要依靠timerfd这个系统函数统一计时timerfd是一个系统计时函数，当所设置的时间到了，会通过timerfd这个文件描述符进行提示通信，而其他计时函数可能是通过信号量，或者其他方式，但是都没有文件描述符好，并且也可以用timerfd监听。</p>
<p>如何使用timerfd来为所有的计时器计时：timerfd每次都设置在计时器列表中到期时间最近的那个到期时间，这样timerfd到期以后，也就是最近的那个计时器到期，所以每次都是手动重置timerfd的计时时间，为最近的计时器到期时间</p>
<p>内部有channel，和timerfd关联。添加新的Timer后，在超时后，timerfd可读，会处理channel事件，之后调用Timer的回调函数；在timerfd的事件处理后，还有检查一遍超时定时器，如果其属性为重复还有再次添加到定时器集合中。</p>
<p>内部有两种类型的Set</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">typedef std::pair&lt;Timestamp, Timer*&gt; Entry;</span><br><span class="line"></span><br><span class="line">typedef std::set&lt;Entry&gt; TimerList;</span><br><span class="line"></span><br><span class="line">typedef std::pair&lt;Timer*, int64_t&gt; ActiveTimer;</span><br><span class="line"></span><br><span class="line">typedef std::set&lt;ActiveTimer&gt; ActiveTimerSet;</span><br></pre></td></tr></table></figure>

<p>TimerQueue.h</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> MUDUO_NET_TIMERQUEUE_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MUDUO_NET_TIMERQUEUE_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/noncopyable.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;muduo/base/Mutex.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;muduo/base/Timestamp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;muduo/net/Callbacks.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;muduo/net/Channel.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> muduo &#123;</span><br><span class="line">    <span class="keyword">namespace</span> net &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">class</span> <span class="title class_">EventLoop</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">class</span> <span class="title class_">Timer</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">class</span> <span class="title class_">TimerId</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// A best efforts timer queue.</span></span><br><span class="line"><span class="comment">/// No guarantee that the callback will be on time.</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line">        <span class="keyword">class</span> <span class="title class_">TimerQueue</span> : boost::noncopyable &#123;</span><br><span class="line">        <span class="keyword">public</span>:</span><br><span class="line">            <span class="built_in">TimerQueue</span>(EventLoop *loop);</span><br><span class="line"></span><br><span class="line">            ~<span class="built_in">TimerQueue</span>();</span><br><span class="line"></span><br><span class="line">            <span class="comment">///</span></span><br><span class="line">            <span class="comment">/// Schedules the callback to be run at given time,</span></span><br><span class="line">            <span class="comment">/// repeats if @c interval &gt; 0.0.</span></span><br><span class="line">            <span class="comment">///</span></span><br><span class="line">            <span class="comment">/// Must be thread safe. Usually be called from other threads.</span></span><br><span class="line">            <span class="comment">// 一定是线程安全的，可以跨线程调用。通常情况下被其它线程调用。</span></span><br><span class="line">            <span class="function">TimerId <span class="title">addTimer</span><span class="params">(<span class="type">const</span> TimerCallback &amp;cb,</span></span></span><br><span class="line"><span class="params"><span class="function">                             Timestamp when,</span></span></span><br><span class="line"><span class="params"><span class="function">                             <span class="type">double</span> interval)</span></span>;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="type">void</span> <span class="title">cancel</span><span class="params">(TimerId timerId)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line">            <span class="comment">// <span class="doctag">FIXME:</span> use unique_ptr&lt;Timer&gt; instead of raw pointers.</span></span><br><span class="line">            <span class="comment">// unique_ptr是C++ 11标准的一个独享所有权的智能指针</span></span><br><span class="line">            <span class="comment">// 无法得到指向同一对象的两个unique_ptr指针</span></span><br><span class="line">            <span class="comment">// 但可以进行移动构造与移动赋值操作，即所有权可以移动到另一个对象（而非拷贝构造）</span></span><br><span class="line">            <span class="keyword">typedef</span> std::pair&lt;Timestamp, Timer *&gt; Entry;</span><br><span class="line">            <span class="keyword">typedef</span> std::set &lt;Entry&gt; TimerList;</span><br><span class="line">            <span class="keyword">typedef</span> std::pair&lt;Timer *, <span class="type">int64_t</span>&gt; ActiveTimer;</span><br><span class="line">            <span class="keyword">typedef</span> std::set &lt;ActiveTimer&gt; ActiveTimerSet;</span><br><span class="line">            <span class="comment">//set中存储的是pair类型，那么默认先按照pair的第一个元素排序，如果相同，再按照第二个元素排序。</span></span><br><span class="line">            <span class="comment">//所以这两种set都是存放定时器的列表，但是一个根据定时器的到时时间来存储，</span></span><br><span class="line">            <span class="comment">//一个根据定时器地址来存储，但是存储的定时器都是同一个，目的是为了区分同一到期时间的定时器？？？</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 以下成员函数只可能在其所属的I/O线程中调用，因而不必加锁。</span></span><br><span class="line">            <span class="comment">// 服务器性能杀手之一是锁竞争，所以要尽可能少用锁</span></span><br><span class="line">            <span class="function"><span class="type">void</span> <span class="title">addTimerInLoop</span><span class="params">(Timer *timer)</span></span>;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="type">void</span> <span class="title">cancelInLoop</span><span class="params">(TimerId timerId)</span></span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// called when timerfd alarms</span></span><br><span class="line">            <span class="function"><span class="type">void</span> <span class="title">handleRead</span><span class="params">()</span></span>;<span class="comment">//timerfdChannel_的读函数</span></span><br><span class="line">            <span class="comment">// move out all expired timers</span></span><br><span class="line">            <span class="comment">// 返回超时的定时器列表</span></span><br><span class="line">            std::vector &lt;Entry&gt; <span class="built_in">getExpired</span>(Timestamp now);</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="type">void</span> <span class="title">reset</span><span class="params">(<span class="type">const</span> std::vector &lt;Entry&gt; &amp;expired, Timestamp now)</span></span>;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="type">bool</span> <span class="title">insert</span><span class="params">(Timer *timer)</span></span>;</span><br><span class="line"></span><br><span class="line">            EventLoop *loop_;        <span class="comment">// 所属EventLoop</span></span><br><span class="line">            <span class="type">const</span> <span class="type">int</span> timerfd_;</span><br><span class="line">            <span class="comment">//过一段事件，就筛选一次，看看TimerList中有多少定时器到时间了，就处理一下，但是这样延迟很高，不太理解</span></span><br><span class="line">            Channel timerfdChannel_;<span class="comment">//与timefd绑定</span></span><br><span class="line">            <span class="comment">// Timer list sorted by expiration</span></span><br><span class="line">            TimerList timers_;    <span class="comment">// timers_是按到期时间排序，也是存放未到时间的定时器</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// for cancel()</span></span><br><span class="line">            <span class="comment">// timers_与activeTimers_保存的是相同的数据</span></span><br><span class="line">            <span class="comment">// timers_是按到期时间排序，activeTimers_是按对象地址排序</span></span><br><span class="line">            ActiveTimerSet activeTimers_;<span class="comment">//还未到时间的定时器,这里面存放的定时器是和timers_一样的，只是顺序不同</span></span><br><span class="line">            <span class="type">bool</span> callingExpiredTimers_; <span class="comment">/* atomic */</span><span class="comment">//是否在处理过期定时器的标志</span></span><br><span class="line">            ActiveTimerSet cancelingTimers_;    <span class="comment">// 保存的是被取消的定时器</span></span><br><span class="line">            <span class="comment">// 用这个列表的作用是，当出现一个循环的计时器被取消时，就要通过reset函数中对</span></span><br><span class="line">            <span class="comment">//ActiveTimerSet列表来暂停对这个计时器的重置</span></span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span>  <span class="comment">// MUDUO_NET_TIMERQUEUE_H</span></span></span><br></pre></td></tr></table></figure>

<p>TimerQueue.cc</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> __STDC_LIMIT_MACROS</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;muduo/net/TimerQueue.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;muduo/base/Logging.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;muduo/net/EventLoop.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;muduo/net/Timer.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;muduo/net/TimerId.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/bind.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/timerfd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> muduo &#123;</span><br><span class="line">    <span class="keyword">namespace</span> net &#123;</span><br><span class="line">        <span class="keyword">namespace</span> detail &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 创建定时器</span></span><br><span class="line">            <span class="function"><span class="type">int</span> <span class="title">createTimerfd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="type">int</span> timerfd = ::<span class="built_in">timerfd_create</span>(CLOCK_MONOTONIC,</span><br><span class="line">                                               TFD_NONBLOCK | TFD_CLOEXEC);<span class="comment">//CLOCK_MONOTONIC参数表明计时器的时间是从系统打开开始计时的</span></span><br><span class="line">                <span class="comment">//CLOCK_MONOTONIC表示的是时间类型</span></span><br><span class="line">                <span class="keyword">if</span> (timerfd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    LOG_SYSFATAL &lt;&lt; <span class="string">&quot;Failed in timerfd_create&quot;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> timerfd;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 计算超时时刻与当前时间的时间差</span></span><br><span class="line">            <span class="keyword">struct</span> <span class="title class_">timespec</span> <span class="built_in">howMuchTimeFromNow</span>(Timestamp when) &#123;</span><br><span class="line">                <span class="type">int64_t</span> microseconds = when.<span class="built_in">microSecondsSinceEpoch</span>()</span><br><span class="line">                                       - Timestamp::<span class="built_in">now</span>().<span class="built_in">microSecondsSinceEpoch</span>();</span><br><span class="line">                <span class="keyword">if</span> (microseconds &lt; <span class="number">100</span>) &#123;</span><br><span class="line">                    microseconds = <span class="number">100</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">struct</span> <span class="title class_">timespec</span> ts;</span><br><span class="line">                ts.tv_sec = <span class="built_in">static_cast</span>&lt;<span class="type">time_t</span>&gt;(</span><br><span class="line">                        microseconds / Timestamp::kMicroSecondsPerSecond);</span><br><span class="line">                ts.tv_nsec = <span class="built_in">static_cast</span>&lt;<span class="type">long</span>&gt;(</span><br><span class="line">                        (microseconds % Timestamp::kMicroSecondsPerSecond) * <span class="number">1000</span>);</span><br><span class="line">                <span class="keyword">return</span> ts;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 清除定时器，避免一直触发//处理超时事件。超时后，timerfd变为可读</span></span><br><span class="line">            <span class="function"><span class="type">void</span> <span class="title">readTimerfd</span><span class="params">(<span class="type">int</span> timerfd, Timestamp now)</span> </span>&#123;</span><br><span class="line">                <span class="type">uint64_t</span> howmany;</span><br><span class="line">                <span class="type">ssize_t</span> n = ::<span class="built_in">read</span>(timerfd, &amp;howmany, <span class="keyword">sizeof</span> howmany);</span><br><span class="line">                LOG_TRACE &lt;&lt; <span class="string">&quot;TimerQueue::handleRead() &quot;</span> &lt;&lt; howmany &lt;&lt; <span class="string">&quot; at &quot;</span> &lt;&lt; now.<span class="built_in">toString</span>();</span><br><span class="line">                <span class="keyword">if</span> (n != <span class="keyword">sizeof</span> howmany) &#123;</span><br><span class="line">                    LOG_ERROR &lt;&lt; <span class="string">&quot;TimerQueue::handleRead() reads &quot;</span> &lt;&lt; n &lt;&lt; <span class="string">&quot; bytes instead of 8&quot;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 重置定时器的超时时间（不是周期性的定时器，时间到expiration就结束了）</span></span><br><span class="line">            <span class="comment">// 在这里面itimerspec.it_interval都是设置的0，每次都是计时结束以后手动重新设置，然后再计时的。</span></span><br><span class="line">            <span class="function"><span class="type">void</span> <span class="title">resetTimerfd</span><span class="params">(<span class="type">int</span> timerfd, Timestamp expiration)</span> </span>&#123;</span><br><span class="line">                <span class="comment">// wake up loop by timerfd_settime()</span></span><br><span class="line">                <span class="keyword">struct</span> <span class="title class_">itimerspec</span> newValue;</span><br><span class="line">                <span class="keyword">struct</span> <span class="title class_">itimerspec</span> oldValue;</span><br><span class="line">                <span class="built_in">bzero</span>(&amp;newValue, <span class="keyword">sizeof</span> newValue);</span><br><span class="line">                <span class="built_in">bzero</span>(&amp;oldValue, <span class="keyword">sizeof</span> oldValue);</span><br><span class="line">                newValue.it_value = <span class="built_in">howMuchTimeFromNow</span>(expiration);</span><br><span class="line">                <span class="type">int</span> ret = ::<span class="built_in">timerfd_settime</span>(timerfd, <span class="number">0</span>, &amp;newValue, &amp;oldValue);</span><br><span class="line">                <span class="keyword">if</span> (ret) &#123;</span><br><span class="line">                    LOG_SYSERR &lt;&lt; <span class="string">&quot;timerfd_settime()&quot;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> muduo;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> muduo::net;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> muduo::net::detail;</span><br><span class="line"></span><br><span class="line">TimerQueue::<span class="built_in">TimerQueue</span>(EventLoop *loop)</span><br><span class="line">        : <span class="built_in">loop_</span>(loop),</span><br><span class="line">          <span class="built_in">timerfd_</span>(<span class="built_in">createTimerfd</span>()),</span><br><span class="line">          <span class="built_in">timerfdChannel_</span>(loop, timerfd_),<span class="comment">//timerfd相关的channel</span></span><br><span class="line">          <span class="built_in">timers_</span>(),</span><br><span class="line">          <span class="built_in">callingExpiredTimers_</span>(<span class="literal">false</span>) &#123;</span><br><span class="line">    timerfdChannel_.<span class="built_in">setReadCallback</span>(</span><br><span class="line">            boost::<span class="built_in">bind</span>(&amp;TimerQueue::handleRead, <span class="keyword">this</span>));</span><br><span class="line">    <span class="comment">// we are always reading the timerfd, we disarm it with timerfd_settime.</span></span><br><span class="line">    timerfdChannel_.<span class="built_in">enableReading</span>();<span class="comment">//设置关注读事件，并且加入epoll队列</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">TimerQueue::~<span class="built_in">TimerQueue</span>() &#123;</span><br><span class="line">    ::<span class="built_in">close</span>(timerfd_);</span><br><span class="line">    <span class="comment">// do not remove channel, since we&#x27;re in EventLoop::dtor();</span></span><br><span class="line">    <span class="keyword">for</span> (TimerList::iterator it = timers_.<span class="built_in">begin</span>();</span><br><span class="line">         it != timers_.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">        <span class="keyword">delete</span> it-&gt;second;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">TimerId <span class="title">TimerQueue::addTimer</span><span class="params">(<span class="type">const</span> TimerCallback &amp;cb,</span></span></span><br><span class="line"><span class="params"><span class="function">                             Timestamp when,</span></span></span><br><span class="line"><span class="params"><span class="function">                             <span class="type">double</span> interval)</span><span class="comment">//创建并增加Timer进队列中</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Timer *timer = <span class="keyword">new</span> <span class="built_in">Timer</span>(cb, when, interval);</span><br><span class="line"></span><br><span class="line">    loop_-&gt;<span class="built_in">runInLoop</span>(</span><br><span class="line">            boost::<span class="built_in">bind</span>(&amp;TimerQueue::addTimerInLoop, <span class="keyword">this</span>, timer));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//addTimerInLoop(timer);</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">TimerId</span>(timer, timer-&gt;<span class="built_in">sequence</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TimerQueue::cancel</span><span class="params">(TimerId timerId)</span><span class="comment">//取消</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    loop_-&gt;<span class="built_in">runInLoop</span>(</span><br><span class="line">            boost::<span class="built_in">bind</span>(&amp;TimerQueue::cancelInLoop, <span class="keyword">this</span>, timerId));</span><br><span class="line">    <span class="comment">//cancelInLoop(timerId);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TimerQueue::addTimerInLoop</span><span class="params">(Timer *timer)</span> </span>&#123;</span><br><span class="line">    loop_-&gt;<span class="built_in">assertInLoopThread</span>();</span><br><span class="line">    <span class="comment">// 插入一个定时器，有可能会使得最早到期的定时器发生改变</span></span><br><span class="line">    <span class="type">bool</span> earliestChanged = <span class="built_in">insert</span>(timer);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (earliestChanged) &#123;</span><br><span class="line">        <span class="comment">// 重置timefd定时器的超时时刻(timerfd_settime)</span></span><br><span class="line">        <span class="built_in">resetTimerfd</span>(timerfd_, timer-&gt;<span class="built_in">expiration</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TimerQueue::cancelInLoop</span><span class="params">(TimerId timerId)</span><span class="comment">//取消的回调函数</span></span></span><br><span class="line"><span class="function"><span class="comment">//取消计时器，就是把该计时器从两个队列中删除，</span></span></span><br><span class="line"><span class="function"><span class="comment">//现在有一种特殊情况，就是如果刚好在处理定时器的过程中，并且这个要取消的定时器就是在被处理的，并且是循环定时器，那么如果不加入cancelingTimers_列表</span></span></span><br><span class="line"><span class="function"><span class="comment">//就会出现，在重置时又把这个定时器重启了，但是这个定时器应该是要被取消的</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    loop_-&gt;<span class="built_in">assertInLoopThread</span>();</span><br><span class="line">    <span class="built_in">assert</span>(timers_.<span class="built_in">size</span>() == activeTimers_.<span class="built_in">size</span>());</span><br><span class="line">    <span class="function">ActiveTimer <span class="title">timer</span><span class="params">(timerId.timer_, timerId.sequence_)</span></span>;</span><br><span class="line">    <span class="comment">// 查找该定时器</span></span><br><span class="line">    ActiveTimerSet::iterator it = activeTimers_.<span class="built_in">find</span>(timer);</span><br><span class="line">    <span class="keyword">if</span> (it != activeTimers_.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        <span class="type">size_t</span> n = timers_.<span class="built_in">erase</span>(<span class="built_in">Entry</span>(it-&gt;first-&gt;<span class="built_in">expiration</span>(), it-&gt;first));</span><br><span class="line">        <span class="built_in">assert</span>(n == <span class="number">1</span>);</span><br><span class="line">        (<span class="type">void</span>) n;</span><br><span class="line">        <span class="keyword">delete</span> it-&gt;first; <span class="comment">// <span class="doctag">FIXME:</span> no delete please,如果用了unique_ptr,这里就不需要手动删除了</span></span><br><span class="line">        activeTimers_.<span class="built_in">erase</span>(it);</span><br><span class="line">    &#125;<span class="comment">//用activeTimers_列表来搜索，然后找到先删除timers_，再删除activeTimers_</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (callingExpiredTimers_)</span><br><span class="line">        <span class="comment">//如果在未到时间的定时器中没有找到，并且线程正在处理过期的定时器，那么可能这个定时器正在被处理，就将这些定时器放到cancelingTimers_数组中</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 已经到期，并且正在调用回调函数的定时器，为了在重置时，避免被重置，而是被忽略</span></span><br><span class="line">        cancelingTimers_.<span class="built_in">insert</span>(timer);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">assert</span>(timers_.<span class="built_in">size</span>() == activeTimers_.<span class="built_in">size</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TimerQueue::handleRead</span><span class="params">()</span><span class="comment">//TimerChannel的回调函数，也就是当timefd定时器到时的时候，就会调用这个函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    loop_-&gt;<span class="built_in">assertInLoopThread</span>();</span><br><span class="line">    <span class="function">Timestamp <span class="title">now</span><span class="params">(Timestamp::now())</span></span>;</span><br><span class="line">    <span class="built_in">readTimerfd</span>(timerfd_, now);        <span class="comment">// 清除该事件，避免一直触发</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取该时刻之前所有的定时器列表(即超时定时器列表)</span></span><br><span class="line">    std::vector &lt;Entry&gt; expired = <span class="built_in">getExpired</span>(now);</span><br><span class="line"></span><br><span class="line">    callingExpiredTimers_ = <span class="literal">true</span>;<span class="comment">//处理到期的定时器</span></span><br><span class="line">    cancelingTimers_.<span class="built_in">clear</span>();<span class="comment">//每次处理前，把要取消的定时器列表清空</span></span><br><span class="line">    <span class="comment">// safe to callback outside critical section</span></span><br><span class="line">    <span class="keyword">for</span> (std::vector&lt;Entry&gt;::iterator it = expired.<span class="built_in">begin</span>();</span><br><span class="line">         it != expired.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">        <span class="comment">// 这里回调定时器timer处理函数</span></span><br><span class="line">        it-&gt;second-&gt;<span class="built_in">run</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    callingExpiredTimers_ = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不是一次性定时器，需要重启</span></span><br><span class="line">    <span class="built_in">reset</span>(expired, now);<span class="comment">//如果之前处理定时器回调函数时间较长，那么在这段时间中，已经有定时器到期了，轻则产生延迟，重则</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// rvo</span></span><br><span class="line">std::vector &lt;TimerQueue::Entry&gt; TimerQueue::<span class="built_in">getExpired</span>(Timestamp now)<span class="comment">//得到已经过期的计时器</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">assert</span>(timers_.<span class="built_in">size</span>() == activeTimers_.<span class="built_in">size</span>());</span><br><span class="line">    std::vector &lt;Entry&gt; expired;<span class="comment">//存放已经过期的定时器</span></span><br><span class="line">    <span class="function">Entry <span class="title">sentry</span><span class="params">(now, <span class="keyword">reinterpret_cast</span>&lt;Timer *&gt;(UINTPTR_MAX))</span></span>;<span class="comment">//我理解是找了一个指针可以取到的最大数，为了避免和其他指针冲突，</span></span><br><span class="line">    <span class="comment">//因为这个指针没有什么意义，仅仅是为了构成一个Entry结构体，有意义的是第一个元素now</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回第一个未到期的Timer的迭代器</span></span><br><span class="line">    <span class="comment">// lower_bound的含义是返回第一个值&gt;=sentry的元素的iterator</span></span><br><span class="line">    <span class="comment">// 即*end &gt;= sentry，从而end-&gt;first &gt; now</span></span><br><span class="line">    TimerList::iterator end = timers_.<span class="built_in">lower_bound</span>(sentry);</span><br><span class="line">    <span class="built_in">assert</span>(end == timers_.<span class="built_in">end</span>() || now &lt; end-&gt;first);</span><br><span class="line">    <span class="comment">// 将到期的定时器插入到expired中</span></span><br><span class="line">    std::<span class="built_in">copy</span>(timers_.<span class="built_in">begin</span>(), end, <span class="built_in">back_inserter</span>(expired));<span class="comment">//back_inserter是迭代器的一种操作，效果和expired.push_back()一样</span></span><br><span class="line">    <span class="comment">// 从timers_中移除到期的定时器</span></span><br><span class="line">    timers_.<span class="built_in">erase</span>(timers_.<span class="built_in">begin</span>(), end);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从activeTimers_中移除到期的定时器</span></span><br><span class="line">    <span class="keyword">for</span> (std::vector&lt;Entry&gt;::iterator it = expired.<span class="built_in">begin</span>();</span><br><span class="line">         it != expired.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">        <span class="function">ActiveTimer <span class="title">timer</span><span class="params">(it-&gt;second, it-&gt;second-&gt;sequence())</span></span>;</span><br><span class="line">        <span class="type">size_t</span> n = activeTimers_.<span class="built_in">erase</span>(timer);</span><br><span class="line">        <span class="built_in">assert</span>(n == <span class="number">1</span>);</span><br><span class="line">        (<span class="type">void</span>) n;<span class="comment">//避免编译器出现变量n未使用的警告？？？</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">assert</span>(timers_.<span class="built_in">size</span>() == activeTimers_.<span class="built_in">size</span>());</span><br><span class="line">    <span class="keyword">return</span> expired;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TimerQueue::reset</span><span class="params">(<span class="type">const</span> std::vector &lt;Entry&gt; &amp;expired, Timestamp now)</span><span class="comment">//重启两种定时器，一种是timefd，另外一种是定时器列表中需要重复的定时器</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Timestamp nextExpire;</span><br><span class="line">    <span class="comment">//重启定时器列表中过期的定时器，如果需要重复的话</span></span><br><span class="line">    <span class="keyword">for</span> (std::vector&lt;Entry&gt;::const_iterator it = expired.<span class="built_in">begin</span>();</span><br><span class="line">         it != expired.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">        <span class="function">ActiveTimer <span class="title">timer</span><span class="params">(it-&gt;second, it-&gt;second-&gt;sequence())</span></span>;</span><br><span class="line">        <span class="comment">// 如果是重复的定时器并且是未取消定时器，则重启该定时器</span></span><br><span class="line">        <span class="keyword">if</span> (it-&gt;second-&gt;<span class="built_in">repeat</span>()</span><br><span class="line">            &amp;&amp; cancelingTimers_.<span class="built_in">find</span>(timer) == cancelingTimers_.<span class="built_in">end</span>()) &#123;</span><br><span class="line">            it-&gt;second-&gt;<span class="built_in">restart</span>(now);</span><br><span class="line">            <span class="built_in">insert</span>(it-&gt;second);</span><br><span class="line">        &#125; <span class="keyword">else</span><span class="comment">//不需要重复就删除这个定时器</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 一次性定时器或者已被取消的定时器是不能重置的，因此删除该定时器</span></span><br><span class="line">            <span class="comment">// FIXME move to a free list</span></span><br><span class="line">            <span class="keyword">delete</span> it-&gt;second; <span class="comment">// <span class="doctag">FIXME:</span> no delete please</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//重启timefd，设置的时间就是定时器列表中最快到期的时间</span></span><br><span class="line">    <span class="keyword">if</span> (!timers_.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="comment">// 获取最早到期的定时器超时时间</span></span><br><span class="line">        nextExpire = timers_.<span class="built_in">begin</span>()-&gt;second-&gt;<span class="built_in">expiration</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (nextExpire.<span class="built_in">valid</span>()) &#123;</span><br><span class="line">        <span class="comment">// 重置定时器的超时时刻(timerfd_settime)</span></span><br><span class="line">        <span class="built_in">resetTimerfd</span>(timerfd_, nextExpire);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">TimerQueue::insert</span><span class="params">(Timer *timer)</span><span class="comment">//把定时器插入到timers_和activeTimers_队列中去</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    loop_-&gt;<span class="built_in">assertInLoopThread</span>();</span><br><span class="line">    <span class="built_in">assert</span>(timers_.<span class="built_in">size</span>() == activeTimers_.<span class="built_in">size</span>());</span><br><span class="line">    <span class="comment">// 最早到期时间是否改变</span></span><br><span class="line">    <span class="type">bool</span> earliestChanged = <span class="literal">false</span>;<span class="comment">//这个变量的意义是显示最早到期时间是否改变，通俗点说就是这个插入的定时器的位置在timers_的</span></span><br><span class="line">    <span class="comment">//首位，也就是这个插入的定时器的到期时间是timers_中已经存储的定时器中最早的，那么这个标志位就会置true</span></span><br><span class="line">    Timestamp when = timer-&gt;<span class="built_in">expiration</span>();<span class="comment">//超时时刻</span></span><br><span class="line">    TimerList::iterator it = timers_.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="comment">// 如果timers_为空或者when小于timers_中的最早到期时间</span></span><br><span class="line">    <span class="keyword">if</span> (it == timers_.<span class="built_in">end</span>() || when &lt; it-&gt;first) &#123;</span><br><span class="line">        earliestChanged = <span class="literal">true</span>;<span class="comment">//表示定时器最早，所以置true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//要分别插入到两个set中</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 插入到timers_中</span></span><br><span class="line">        std::pair&lt;TimerList::iterator, <span class="type">bool</span>&gt; result</span><br><span class="line">                = timers_.<span class="built_in">insert</span>(<span class="built_in">Entry</span>(when, timer));</span><br><span class="line">        <span class="built_in">assert</span>(result.second);</span><br><span class="line">        (<span class="type">void</span>) result;</span><br><span class="line">    &#125;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 插入到activeTimers_中</span></span><br><span class="line">        std::pair&lt;ActiveTimerSet::iterator, <span class="type">bool</span>&gt; result</span><br><span class="line">                = activeTimers_.<span class="built_in">insert</span>(<span class="built_in">ActiveTimer</span>(timer, timer-&gt;<span class="built_in">sequence</span>()));</span><br><span class="line">        <span class="built_in">assert</span>(result.second);</span><br><span class="line">        (<span class="type">void</span>) result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">assert</span>(timers_.<span class="built_in">size</span>() == activeTimers_.<span class="built_in">size</span>());</span><br><span class="line">    <span class="keyword">return</span> earliestChanged;<span class="comment">//返回最早到期的时间有没有改变</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="EventLoop"><a href="#EventLoop" class="headerlink" title="EventLoop"></a>EventLoop</h3><p><code>EventLoop</code> 整合了 <code>Channel</code> 和 <code>Poller</code> 提供更方便的接口来使用，主要功能为：处理 <code>Channel</code>、处理定时事件、处理任务事件。主要接口如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">EventLoop</span> : noncopyable</span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">// EventLoop</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">loop</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">quit</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 任务事件</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">wakeup</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">runInLoop</span><span class="params">(Functor cb)</span></span>;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">queueInLoop</span><span class="params">(Functor cb)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 定时器</span></span><br><span class="line">  <span class="function">TimerId <span class="title">runAt</span><span class="params">(Timestamp time, TimerCallback cb)</span></span>;</span><br><span class="line">  <span class="function">TimerId <span class="title">runAfter</span><span class="params">(<span class="type">double</span> delay, TimerCallback cb)</span></span>;</span><br><span class="line">  <span class="function">TimerId <span class="title">runEvery</span><span class="params">(<span class="type">double</span> interval, TimerCallback cb)</span></span>;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">cancel</span><span class="params">(TimerId timerId)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 处理 Channel</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">updateChannel</span><span class="params">(Channel* channel)</span></span>;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">removeChannel</span><span class="params">(Channel* channel)</span></span>;</span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">hasChannel</span><span class="params">(Channel* channel)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>EventLoop</code> 的用法是先注册 <code>Channel</code>，如 <code>listening fd</code>，然后调用 <code>loop()</code> 一直循环处理各种任务，在 <code>loop</code> 中可以注册新的 <code>Channel</code>、定时事件和任务事件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">void EventLoop::loop()</span><br><span class="line">&#123;</span><br><span class="line">  while (!quit_)</span><br><span class="line">  &#123;</span><br><span class="line">    activeChannels_.clear();</span><br><span class="line">    pollReturnTime_ = poller_-&gt;poll(kPollTimeMs, &amp;activeChannels_);</span><br><span class="line">    for (Channel* channel : activeChannels_)</span><br><span class="line">    &#123;</span><br><span class="line">      currentActiveChannel_ = channel;</span><br><span class="line">      currentActiveChannel_-&gt;handleEvent(pollReturnTime_);</span><br><span class="line">    &#125;</span><br><span class="line">    doPendingFunctors();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先来说任务事件，使用场景主要是其他线程想要在 <code>EventLoop</code> 线程做些工作，比如 <code>EventLoop</code> 线程把耗时的任务放到 <code>threadpool</code> 中执行，完成后通知 <code>EventLoop</code> 线程获取结果。 最常见的实现方式是用 <code>pipe(2)</code>：<code>EventLoop</code> 注册读事件，其他线程把结果保存在队列中，然后写 <code>pipe</code>，<code>EventLoop</code> 线程就会唤醒处理。<code>Muduo</code> 也是类似实现，只是用 <code>eventfd(2)</code> 来唤醒。</p>
<h2 id="一个简单的例子"><a href="#一个简单的例子" class="headerlink" title="一个简单的例子"></a>一个简单的例子</h2><p>首先从最简单的 echo server 入手，来介绍 muduo 的基本使用，同时也方便后面概念的理解。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">onMessage</span><span class="params">(<span class="type">const</span> muduo::net::TcpConnectionPtr&amp; conn,</span></span></span><br><span class="line"><span class="params"><span class="function">                           muduo::net::Buffer* buf,</span></span></span><br><span class="line"><span class="params"><span class="function">                           muduo::Timestamp time)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  conn-&gt;<span class="built_in">send</span>(buf);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    muduo::net::EventLoop loop;</span><br><span class="line">    muduo::<span class="function">net::InetAddress <span class="title">listenAddr</span><span class="params">(<span class="number">2007</span>)</span></span>;</span><br><span class="line">    <span class="function">TcpServer <span class="title">server</span><span class="params">(&amp;loop, listenAddr)</span></span>;</span><br><span class="line">    server.<span class="built_in">setMessageCallback</span>(onMessage);</span><br><span class="line">    server.<span class="built_in">start</span>();</span><br><span class="line">    loop.<span class="built_in">loop</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>echo-server 的代码量非常简洁。一个典型的 muduo 的 TcpServer 工作流程如下：</p>
<ol>
<li>建立一个事件循环器 EventLoop(reactor)</li>
<li>建立对应的业务服务器 TcpServer，并指定它的reactor和地址</li>
<li>设置 TcpServer 的 Callback</li>
<li>启动 server</li>
<li>开启事件循环</li>
</ol>
<p>陈硕认为，TCP 网络编程的本质是处理三个半事件，即：</p>
<ol>
<li>连接的建立</li>
<li>连接的断开：包括主动断开和被动断开</li>
<li>消息到达，文件描述符可读。</li>
<li>消息发送完毕。这个算半个事件。</li>
</ol>
<p>我们接下来分析下 muduo 是怎么处理和实现这三个半事件的</p>
<h2 id="连接的建立"><a href="#连接的建立" class="headerlink" title="连接的建立"></a>连接的建立</h2><p>在我们单纯使用 linux 的 API，编写一个简单的 Tcp 服务器时，建立一个新的连接通常需要四步：</p>
<blockquote>
<p>步骤 1. socket() &#x2F;&#x2F; 调用 socket 函数建立监听 socket<br>步骤 2. bind() &#x2F;&#x2F; 绑定地址和端口<br>步骤 3. listen() &#x2F;&#x2F; 开始监听端口<br>步骤 4. accept() &#x2F;&#x2F; 返回新建立连接的 fd</p>
</blockquote>
<p>我们接下来分析下，这四个步骤在 muduo 中都是何时进行的：</p>
<p>首先在 TcpServer 对象构建时，TcpServer 的属性 acceptor 同时也被建立。<br>在 Acceptor 的构造函数中分别调用了 socket 函数和 bind 函数完成了 <strong>步骤 1</strong>和<strong>步骤 2</strong>。<br>即，当 <code>TcpServer server(&amp;loop, listenAddr)</code> 执行结束时，监听 socket 已经建立好，并已绑定到对应地址和端口了。</p>
<p>而当执行 <code>server.start()</code> 时，主要做了两个工作：</p>
<ol>
<li>在监听 socket 上启动 listen 函数，也就是 <strong>步骤 3</strong>；</li>
<li>将监听 socket 的可读事件注册到 EventLoop 中。</li>
</ol>
<p>此时，程序已完成对socket的监听，但还不够，因为此时程序的主角 <code>EventLoop</code> 尚未启动。<br>当调用 <code>loop.loop()</code> 时，程序开始循环监听该 socket 的可读事件。</p>
<p>当新连接请求建立时，可读事件触发，此时该事件对应的 callback 在 EventLoop::loop() 中被调用。<br>该事件的 callback 实际上就是 Acceptor::handleRead() 方法。</p>
<p>在 Acceptor::handleRead() 方法中，做了三件事：</p>
<ol>
<li>调用了 accept 函数，完成了 <strong>步骤 4</strong>，实现了连接的建立。得到一个已连接 socket 的 fd。</li>
<li>创建 TcpConnection 对象。</li>
<li>将已连接 socket 的可读事件注册到 EventLoop 中。</li>
</ol>
<p>这里还有一个需要注意的点，创建的 TcpConnnection 对象是个 shared_ptr，该对象会被保存在 TcpServer 的 connections 中。这样才能保证引用计数大于 0，对象不被释放。</p>
<p>至此，一个新的连接已完全建立好，该连接的socket可读事件也已注册到 EventLoop 中了。</p>
<h2 id="消息的读取"><a href="#消息的读取" class="headerlink" title="消息的读取"></a>消息的读取</h2><p>上节讲到，在新连接建立的时候，会将新连接的 socket 的可读事件注册到 EventLoop 中。<br>假如客户端发送消息，导致已连接 socket 的可读事件触发，该事件对应的 callback 同样也会在 EventLoop::loop() 中被调用。</p>
<p>该事件的 callback 实际上就是 TcpConnection::handleRead 方法。<br>在 TcpConnection::handleRead 方法中，主要做了两件事：</p>
<ol>
<li>从 socket 中读取数据，并将其放入 inputbuffer 中</li>
<li>调用 messageCallback，执行业务逻辑。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ssize_t</span> n = inputBuffer_.<span class="built_in">readFd</span>(channel_-&gt;<span class="built_in">fd</span>(), &amp;savedErrno);</span><br><span class="line"><span class="keyword">if</span> (n&gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">messageCallback_</span>(<span class="built_in">shared_from_this</span>(), &amp;inputBuffer_, receiveTime);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>messageCallback 是在建立新连接时，将 <code>TcpServer::messageCallback</code> 方法 bind 到了 <code>TcpConnection::messageCallback</code> 的方法。</p>
<p><code>TcpServer::messageCallback</code> 就是业务逻辑的主要实现函数。通常情况下，我们可以在里面实现消息的编解码、消息的分发等工作，这里就不再深入探讨了。</p>
<p>在我们上面给出的示例代码中，echo-server 的 messageCallback 非常简单，就是直接将得到的数据，重新 send 回去。在实际的业务处理中，一般都会调用 TcpConnection::send() 方法，给客户端回复消息。</p>
<p>这里需要注意的是，在 messageCallback 中，用户会有可能会把任务抛给自定义的 Worker 线程池处理。<br>但是这个在 Worker 线程池中任务，<strong>切忌直接对 Buffer 的操作</strong>。因为 Buffer 并不是线程安全的。</p>
<p>我们需要记住一个准则:</p>
<blockquote>
<p><strong>所有对 IO 和 buffer 的读写，都应该在 IO 线程中完成。</strong></p>
</blockquote>
<p>一般情况下，先在交给 Worker 线程池之前，应该现在 IO 线程中把 Buffer 进行切分解包等动作。将解包后的消息交由线程池处理，避免多个线程操作同一个资源。</p>
<h2 id="消息的发送"><a href="#消息的发送" class="headerlink" title="消息的发送"></a>消息的发送</h2><p>用户通过调用 TcpConnection::send() 向客户端回复消息。由于 muduo 中使用了 OutputBuffer，因此消息的发送过程比较复杂。</p>
<p>首先需要注意的是线程安全问题, 上文说到对于消息的读写必须都在 EventLoop 的同一个线程 (通常称为 IO 线程) 中进行：<br>因此，TcpConnection::send 必须要保证线程安全性，它是这么做的：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">TcpConnection::send</span><span class="params">(<span class="type">const</span> StringPiece&amp; message)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (state_ == kConnected)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> (loop_-&gt;<span class="built_in">isInLoopThread</span>())</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">sendInLoop</span>(message);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      loop_-&gt;<span class="built_in">runInLoop</span>(</span><br><span class="line">          boost::<span class="built_in">bind</span>(&amp;TcpConnection::sendInLoop,</span><br><span class="line">                      <span class="keyword">this</span>,     <span class="comment">// FIXME</span></span><br><span class="line">                      message.<span class="built_in">as_string</span>()));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>检测 send 的时候，是否在当前 IO 线程，如果是的话，直接进行写相关操作 <code>sendInLoop</code>。<br>如果不在一个线程的话，需要将该任务抛给 IO 线程执行 <code>runInloop</code>, 以保证 write 动作是在 IO 线程中执行的。我们后面会讲解 <code>runInloop</code> 的具体实现。</p>
<p>在 sendInloop 中，做了下面几件事：</p>
<ol>
<li>假如 OutputBuffer 为空，则直接向 socket 写数据</li>
<li>如果向 socket 写数据没有写完，则统计剩余的字节个数，并进行下一步。没有写完可能是因为此时 socket 的 TCP 缓冲区已满了。</li>
<li>如果此时 OutputBuffer 中的旧数据的个数和未写完字节个数之和大于 highWaterMark，则将 highWaterMarkCallback 放入待执行队列中</li>
<li><strong>将对应 socket 的可写事件注册到 EventLoop 中</strong></li>
</ol>
<p>注意：直到发送消息的时候，muduo 才会把 socket 的可写事件注册到了 EventLoop 中。在此之前只注册了可读事件。</p>
<p>连接 socket 的可写事件对应的 callback 是 TcpConnection::handleWrite()<br>当某个 socket 的可写事件触发时，TcpConnection::handleWrite 会做两个工作：</p>
<ol>
<li>尽可能将数据从 OutputBuffer 中向 socket 中 write 数据</li>
<li>如果 OutputBuffer 没有剩余的，则 <strong>将该 socket 的可写事件移除</strong>，并调用 writeCompleteCallback</li>
</ol>
<p><strong>为什么要移除可写事件</strong></p>
<p>因为当 OutputBuffer 中没数据时，我们不需要向 socket 中写入数据。但是此时 socket 一直是处于可写状态的， 这将会导致 TcpConnection::handleWrite() 一直被触发。然而这个触发毫无意义，因为并没有什么可以写的。</p>
<p>所以 muduo 的处理方式是，当 OutputBuffer 还有数据时，socket 可写事件是注册状态。当 OutputBuffer 为空时，则将 socket 的可写事件移除。</p>
<p>此外，highWaterMarkCallback 和 writeCompleteCallback 一般配合使用，起到限流的作用。在《linux 多线程服务器端编程》一书的 8.9.3 一节中有详细讲解。这里就不再赘述了</p>
<h2 id="连接的断开"><a href="#连接的断开" class="headerlink" title="连接的断开"></a>连接的断开</h2><p>我们看下 muduo 对于连接的断开是怎么处理的。<br>连接的断开分为被动断开和主动断开。主动断开和被动断开的处理方式基本一致，因此本文只讲下被动断开的部分。</p>
<p>被动断开即客户端断开了连接，server 端需要感知到这个断开的过程，然后进行的相关的处理。</p>
<p>其中感知远程断开这一步是在 Tcp 连接的可读事件处理函数 <code>handleRead</code> 中进行的：当对 socket 进行 read 操作时，返回值为 0，则说明此时连接已断开。</p>
<p>接下来会做四件事情：</p>
<ol>
<li>将该 TCP 连接对应的事件从 EventLoop 移除</li>
<li>调用用户的 ConnectionCallback</li>
<li>将对应的 TcpConnection 对象从 Server 移除。</li>
<li>close 对应的 fd。此步骤是在析构函数中自动触发的，当 TcpConnection 对象被移除后，引用计数为 0，对象析构时会调用 close。</li>
</ol>
<h2 id="runInLoop-的实现"><a href="#runInLoop-的实现" class="headerlink" title="runInLoop 的实现"></a>runInLoop 的实现</h2><p>在讲解消息的发送过程时候，我们讲到为了保证对 buffer 和 socket 的写动作是在 IO 线程中进行，使用了一个 <code>runInLoop</code> 函数，将该写任务抛给了 IO 线程处理。</p>
<p>我们接下来看下 <code>runInLoop</code> 的实现：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">EventLoop::runInLoop</span><span class="params">(<span class="type">const</span> Functor&amp; cb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">isInLoopThread</span>())</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">cb</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">queueInLoop</span>(cb);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里可以看到，做了一层判断。如果调用时是此 EventLoop 的运行线程，则直接执行此函数。<br>否则调用 <code>queueInLoop</code> 函数。我们看下 <code>queueInLoop</code> 的实现。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">EventLoop::queueInLoop</span><span class="params">(<span class="type">const</span> Functor&amp; cb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  &#123;</span><br><span class="line">  <span class="function">MutexLockGuard <span class="title">lock</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">  pendingFunctors_.<span class="built_in">push_back</span>(cb);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">isInLoopThread</span>() || callingPendingFunctors_)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">wakeup</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里有两个动作：</p>
<ol>
<li>加锁，然后将该函数放到该 EventLoop 的 pendingFunctors_队列中。</li>
<li>判断是否要唤醒 EventLoop，如果是则调用 wakeup() 唤醒该 EventLoop。</li>
</ol>
<p>这里有几个问题：</p>
<ul>
<li>为什么要唤醒 EventLoop？</li>
<li>wakeup 是怎么实现的?</li>
<li>pendingFunctors_是如何被消费的?</li>
</ul>
<h3 id="为什么要唤醒-EventLoop"><a href="#为什么要唤醒-EventLoop" class="headerlink" title="为什么要唤醒 EventLoop"></a>为什么要唤醒 EventLoop</h3><p>我们首先调用了 <code>pendingFunctors_.push_back(cb)</code>, 将该函数放在 pendingFunctors_中。EventLoop 的每一轮循环在最后会调用 doPendingFunctors 依次执行这些函数。</p>
<p>而 EventLoop 的唤醒是通过 epoll_wait 实现的，如果此时该 EventLoop 中迟迟没有事件触发，那么 epoll_wait 一直就会阻塞。 这样会导致，pendingFunctors_中的任务迟迟不能被执行了。</p>
<p>所以必须要唤醒 EventLoop ，从而让pendingFunctors_中的任务尽快被执行。</p>
<h3 id="wakeup-是怎么实现的"><a href="#wakeup-是怎么实现的" class="headerlink" title="wakeup 是怎么实现的"></a>wakeup 是怎么实现的</h3><p>muduo 这里采用了对 eventfd 的读写来实现对 EventLoop 的唤醒。</p>
<p>在 EventLoop 建立之后，就创建一个 eventfd，并将其可读事件注册到 EventLoop 中。</p>
<p><code>wakeup()</code> 的过程本质上是对这个 eventfd 进行写操作，以触发该 eventfd 的可读事件。这样就起到了唤醒 EventLoop 的作用。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">EventLoop::wakeup</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">uint64_t</span> one = <span class="number">1</span>;</span><br><span class="line">  sockets::<span class="built_in">write</span>(wakeupFd_, &amp;one, <span class="keyword">sizeof</span> one);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>很多库为了兼容 macOS，往往使用 pipe 来实现这个功能。muduo 采用了 eventfd，性能更好些，但代价是不能支持 macOS 了。不过 muduo 似乎从一开始的定位就不打算支持？</p>
<h3 id="doPendingFunctors-的实现"><a href="#doPendingFunctors-的实现" class="headerlink" title="doPendingFunctors 的实现"></a>doPendingFunctors 的实现</h3><p>本部分讲下 <code>doPendingFunctors</code> 的实现，muduo 是如何处理这些待处理的函数的，以及中间用了哪些优化操作。<br>代码如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">EventLoop::doPendingFunctors</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  std::vector&lt;Functor&gt; functors;</span><br><span class="line"></span><br><span class="line">  callingPendingFunctors_ = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">  &#123;</span><br><span class="line">  <span class="function">MutexLockGuard <span class="title">lock</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">  functors.<span class="built_in">swap</span>(pendingFunctors_);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; functors.<span class="built_in">size</span>(); ++i)</span><br><span class="line">  &#123;</span><br><span class="line">    functors[i]();</span><br><span class="line">  &#125;</span><br><span class="line">  callingPendingFunctors_ = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从代码可以看到，函数非常简单。大概只有十行代码，但是这十行代码中却有两个非常巧妙的地方。</p>
<ol>
<li><strong>callingPendingFunctors_的作用</strong></li>
</ol>
<p>从代码可以看出，如果 callingPendingFunctors_为 false，则说明此时尚未开始执行 doPendingFunctors 函数。<br>这个有什么作用呢，我们需要结合下 queueInLoop 中，对是否执行 wakeup() 的判断</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if (!isInLoopThread() || callingPendingFunctors_)</span><br><span class="line">&#123;</span><br><span class="line">  wakeup();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里还需要结合下 EventLoop 循环的实现，其中 <code>doPendingFunctors()</code> 是 <strong>每轮循环的最后一步处理</strong>。<br>如果调用 queueInLoop 和 EventLoop 在同一个线程，且 callingPendingFunctors_为 false 时，则说明：<strong>此时尚未执行到 doPendingFunctors()。</strong><br>那么此时即使不用 wakeup，也可以在之后照旧执行 doPendingFunctors() 了。</p>
<p>这么做的好处非常明显，可以减少对 eventfd 的 IO 读写。</p>
<ol>
<li><strong>锁范围的减少</strong><br>在此函数中，有一段特别的代码：</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;Functor&gt; functors;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="function">MutexLockGuard <span class="title">lock</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">  functors.<span class="built_in">swap</span>(pendingFunctors_);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个作用是 pendingFunctors_和 functors 的内容进行交换，实际上就是此时 functors 持有了 pendingFunctors_的内容，而 pendingFunctors_被清空了。</p>
<p>这个好处是什么呢？<br>如果不这么做，直接遍历 pendingFunctors_, 然后处理对应的函数。这样的话，锁会一直等到所有函数处理完才会被释放。在此期间，queueInLoop 将不可用。</p>
<p>而以上的写法，可以极大减小锁范围，整个锁的持有时间就是 swap 那一下的时间。待处理函数执行的时候，其他线程还是可以继续调用 queueInLoop。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="http://example.com">John Doe</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="http://example.com/2023/01/22/muduo%E7%BD%91%E7%BB%9C%E6%BA%90%E7%A0%81/">http://example.com/2023/01/22/muduo%E7%BD%91%E7%BB%9C%E6%BA%90%E7%A0%81/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/01/22/mysql/" title=""><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">Previous Post</div><div class="prev_info"></div></div></a></div><div class="next-post pull-right"><a href="/2023/01/22/muduo%E6%97%A5%E5%BF%97/" title=""><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">Next Post</div><div class="next_info"></div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">John Doe</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">40</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>Announcement</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Catalog</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#muduo%E7%BD%91%E7%BB%9C%E6%BA%90%E7%A0%81"><span class="toc-number">1.</span> <span class="toc-text">muduo网络源码</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%84%E4%B8%AA%E7%B1%BB%E8%AF%A6%E8%A7%A3"><span class="toc-number">1.1.</span> <span class="toc-text">各个类详解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#channel"><span class="toc-number">1.1.1.</span> <span class="toc-text">channel</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#poller"><span class="toc-number">1.1.2.</span> <span class="toc-text">poller</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#acceptor"><span class="toc-number">1.1.3.</span> <span class="toc-text">acceptor</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#tcp-server%E5%92%8Ctcp-connection"><span class="toc-number">1.1.4.</span> <span class="toc-text">tcp server和tcp connection</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#timer"><span class="toc-number">1.1.5.</span> <span class="toc-text">timer</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#EventLoop"><span class="toc-number">1.1.6.</span> <span class="toc-text">EventLoop</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E4%BE%8B%E5%AD%90"><span class="toc-number">1.2.</span> <span class="toc-text">一个简单的例子</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9E%E6%8E%A5%E7%9A%84%E5%BB%BA%E7%AB%8B"><span class="toc-number">1.3.</span> <span class="toc-text">连接的建立</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E7%9A%84%E8%AF%BB%E5%8F%96"><span class="toc-number">1.4.</span> <span class="toc-text">消息的读取</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E7%9A%84%E5%8F%91%E9%80%81"><span class="toc-number">1.5.</span> <span class="toc-text">消息的发送</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9E%E6%8E%A5%E7%9A%84%E6%96%AD%E5%BC%80"><span class="toc-number">1.6.</span> <span class="toc-text">连接的断开</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#runInLoop-%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.7.</span> <span class="toc-text">runInLoop 的实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%94%A4%E9%86%92-EventLoop"><span class="toc-number">1.7.1.</span> <span class="toc-text">为什么要唤醒 EventLoop</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#wakeup-%E6%98%AF%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E7%9A%84"><span class="toc-number">1.7.2.</span> <span class="toc-text">wakeup 是怎么实现的</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#doPendingFunctors-%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.7.3.</span> <span class="toc-text">doPendingFunctors 的实现</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Post</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/01/22/%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B/" title="No title">No title</a><time datetime="2023-01-22T03:54:02.008Z" title="Created 2023-01-22 11:54:02">2023-01-22</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/01/22/%E7%BD%91%E7%BB%9Cio%E6%A8%A1%E5%9E%8B/" title="No title">No title</a><time datetime="2023-01-22T03:54:02.006Z" title="Created 2023-01-22 11:54:02">2023-01-22</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/01/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/" title="No title">No title</a><time datetime="2023-01-22T03:54:02.003Z" title="Created 2023-01-22 11:54:02">2023-01-22</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/01/22/%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E5%AE%9A%E6%97%B6%E5%99%A8/" title="No title">No title</a><time datetime="2023-01-22T03:54:02.001Z" title="Created 2023-01-22 11:54:02">2023-01-22</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/01/22/%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%E9%9D%9E%E6%B3%95%E8%BE%93%E5%85%A5%E4%BB%A5%E5%8F%8A%E6%9E%84%E9%80%A0%E5%BC%82%E5%B8%B8%E6%83%85%E5%86%B5/" title="No title">No title</a><time datetime="2023-01-22T03:54:01.998Z" title="Created 2023-01-22 11:54:01">2023-01-22</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By John Doe</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Switch Between Light And Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle between single-column and double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="Setting"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back To Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>