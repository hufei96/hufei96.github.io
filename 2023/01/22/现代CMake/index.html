<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>Hexo</title>
  <meta name="keywords" content="">
  <meta name="description" content="Hexo">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="description" content="网络模型方案均以粗糙的 Python 玩具代码为例 方案 1（Accept + Read&#x2F;Write）1234567891011121314151617181920212223242526import socketdef handle(client_socket, client_address):    &#x2F;&#x2F; L6    while True:        data &#x3D; client_">
<meta property="og:type" content="article">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/2023/01/22/%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="网络模型方案均以粗糙的 Python 玩具代码为例 方案 1（Accept + Read&#x2F;Write）1234567891011121314151617181920212223242526import socketdef handle(client_socket, client_address):    &#x2F;&#x2F; L6    while True:        data &#x3D; client_">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://sleepy-1256633542.cos.ap-beijing.myqcloud.com/20181222103157.png">
<meta property="og:image" content="https://sleepy-1256633542.cos.ap-beijing.myqcloud.com/20181222102937.png">
<meta property="og:image" content="https://sleepy-1256633542.cos.ap-beijing.myqcloud.com/20181222102957.png">
<meta property="og:image" content="https://sleepy-1256633542.cos.ap-beijing.myqcloud.com/20181222103019.png">
<meta property="og:image" content="https://sleepy-1256633542.cos.ap-beijing.myqcloud.com/20181222103040.png">
<meta property="og:image" content="https://sleepy-1256633542.cos.ap-beijing.myqcloud.com/20181222103102.png">
<meta property="article:published_time" content="2023-01-22T03:54:02.008Z">
<meta property="article:modified_time" content="2022-12-29T10:29:19.779Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://sleepy-1256633542.cos.ap-beijing.myqcloud.com/20181222103157.png">


<link rel="icon" href="/img/avatar.jpg">

<link href="/css/style.css?v=1.1.0" rel="stylesheet">

<link href="/css/hl_theme/atom-light.css?v=1.1.0" rel="stylesheet">

<link href="//cdn.jsdelivr.net/npm/animate.css@4.1.0/animate.min.css" rel="stylesheet">

<script src="//cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js"></script>
<script src="/js/titleTip.js?v=1.1.0" ></script>

<script src="//cdn.jsdelivr.net/npm/highlightjs@9.16.2/highlight.pack.min.js"></script>
<script>
    hljs.initHighlightingOnLoad();
</script>

<script src="//cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js"></script>



<script src="//cdn.jsdelivr.net/npm/jquery.cookie@1.4.1/jquery.cookie.min.js" ></script>

<script src="/js/iconfont.js?v=1.1.0" ></script>

<meta name="generator" content="Hexo 6.3.0"></head>
<div style="display: none">
  <input class="theme_disqus_on" value="false">
  <input class="theme_preload_comment" value="">
  <input class="theme_blog_path" value="">
  <input id="theme_shortcut" value="true" />
  <input id="theme_highlight_on" value="true" />
  <input id="theme_code_copy" value="true" />
</div>



<body>
<aside class="nav">
    <div class="nav-left">
        <a href="/"
   class="avatar_target">
    <img class="avatar"
         src="/img/avatar.jpg"/>
</a>
<div class="author">
    <span>John Doe</span>
</div>

<div class="icon">
    
        
            <a title="rss"
               href="/atom.xml"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-rss"></use>
                    </svg>
                
            </a>
        
    
        
            <a title="github"
               href="https://github.com/yelog"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-github"></use>
                    </svg>
                
            </a>
        
    
        
            <a title="facebook"
               href="https://www.facebook.com/faker.tops"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-facebook"></use>
                    </svg>
                
            </a>
        
    
        
    
        
    
        
            <a title="instagram"
               href="https://www.facebook.com/faker.tops"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-instagram"></use>
                    </svg>
                
            </a>
        
    
        
            <a title="reddit"
               href="https://www.reddit.com/user/yelog/"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-reddit"></use>
                    </svg>
                
            </a>
        
    
        
            <a title="weibo"
               href="http://weibo.com/u/2307534817"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-weibo"></use>
                    </svg>
                
            </a>
        
    
        
            <a title="jianshu"
               href="https://www.jianshu.com/u/ff56736de7cf"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-jianshu"></use>
                    </svg>
                
            </a>
        
    
        
            <a title="zhihu"
               href="https://www.zhihu.com/people/jaytp/activities"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-zhihu"></use>
                    </svg>
                
            </a>
        
    
        
    
        
            <a title="oschina"
               href="https://my.oschina.net/yelog"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-oschina"></use>
                    </svg>
                
            </a>
        
    
        
    
        
            <a title="email"
               href="mailto:jaytp@qq.com"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-email"></use>
                    </svg>
                
            </a>
        
    
        
            <a title="qq"
               href="http://wpa.qq.com/msgrd?v=3&uin=872336115&site=qq&menu=yes"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-qq"></use>
                    </svg>
                
            </a>
        
    
        
            <a title="kugou"
               href="https://www.kugou.com/"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-kugou"></use>
                    </svg>
                
            </a>
        
    
        
            <a title="neteasemusic"
               href="https://music.163.com/#/user/home?id=88151013"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-neteasemusic"></use>
                    </svg>
                
            </a>
        
    
</div>




<ul>
    <li>
        <div class="all active" data-rel="All">All
            
                <small>(40)</small>
            
        </div>
    </li>
    
</ul>
<div class="left-bottom">
    <div class="menus">
        
            
            
            
    </div>
    <div>
        
            <a class="about  hasFriend  site_url"
               
               href="/about">About</a>
        
        <a style="width: 50%"
                
                                           class="friends">Friends</a>
        
    </div>
</div>
<input type="hidden" id="yelog_site_posts_number" value="40">

<div style="display: none">
    <span id="busuanzi_value_site_uv"></span>
    <span id="busuanzi_value_site_pv"></span>
</div>

    </div>
    <div class="nav-right">
        <div class="friends-area">
    <div class="friends-title">
        Links
        <i class="iconfont icon-left"></i>
    </div>
    <div class="friends-content">
        <ul>
            
            <li><a target="_blank" href="http://yelog.org/">叶落阁</a></li>
            
        </ul>
    </div>
</div>
        <div class="title-list">
    <div class="right-top">
        <div id="default-panel">
            <i class="iconfont icon-search" data-title="搜索 快捷键 i"></i>
            <div class="right-title">All</div>
            <i class="iconfont icon-file-tree" data-title="切换到大纲视图 快捷键 w"></i>
        </div>
        <div id="search-panel">
            <i class="iconfont icon-left" data-title="返回"></i>
            <input id="local-search-input" autocomplete="off"/>
            <label class="border-line" for="input"></label>
            <i class="iconfont icon-case-sensitive" data-title="大小写敏感"></i>
            <i class="iconfont icon-tag" data-title="标签"></i>
        </div>
        <div id="outline-panel" style="display: none">
            <div class="right-title">大纲</div>
            <i class="iconfont icon-list" data-title="切换到文章列表"></i>
        </div>
    </div>

    <div class="tags-list">
    <input id="tag-search" />
    <div class="tag-wrapper">
        
    </div>

</div>

    
    <nav id="title-list-nav">
        
        
        <a  class="All "
           href="/2023/01/22/%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B/"
           data-tag=""
           data-author="" >
            <span class="post-title" title=""></span>
            <span class="post-date" title="2023-01-22 11:54:02">2023/01/22</span>
        </a>
        
        
        <a  class="All "
           href="/2023/01/22/%E7%BD%91%E7%BB%9Cio%E6%A8%A1%E5%9E%8B/"
           data-tag=""
           data-author="" >
            <span class="post-title" title=""></span>
            <span class="post-date" title="2023-01-22 11:54:02">2023/01/22</span>
        </a>
        
        
        <a  class="All "
           href="/2023/01/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"
           data-tag=""
           data-author="" >
            <span class="post-title" title=""></span>
            <span class="post-date" title="2023-01-22 11:54:02">2023/01/22</span>
        </a>
        
        
        <a  class="All "
           href="/2023/01/22/%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E5%AE%9A%E6%97%B6%E5%99%A8/"
           data-tag=""
           data-author="" >
            <span class="post-title" title=""></span>
            <span class="post-date" title="2023-01-22 11:54:02">2023/01/22</span>
        </a>
        
        
        <a  class="All "
           href="/2023/01/22/%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%E9%9D%9E%E6%B3%95%E8%BE%93%E5%85%A5%E4%BB%A5%E5%8F%8A%E6%9E%84%E9%80%A0%E5%BC%82%E5%B8%B8%E6%83%85%E5%86%B5/"
           data-tag=""
           data-author="" >
            <span class="post-title" title=""></span>
            <span class="post-date" title="2023-01-22 11:54:01">2023/01/22</span>
        </a>
        
        
        <a  class="All "
           href="/2023/01/22/%E5%86%85%E7%BD%AE%E7%B1%BB%E5%9E%8B%E5%92%8CPOD%E7%B1%BB%E5%9E%8B/"
           data-tag=""
           data-author="" >
            <span class="post-title" title=""></span>
            <span class="post-date" title="2023-01-22 11:54:01">2023/01/22</span>
        </a>
        
        
        <a  class="All "
           href="/2023/01/22/%E7%B1%BB%E5%9E%8B%E5%AE%89%E5%85%A8/"
           data-tag=""
           data-author="" >
            <span class="post-title" title=""></span>
            <span class="post-date" title="2023-01-22 11:54:01">2023/01/22</span>
        </a>
        
        
        <a  class="All "
           href="/2023/01/22/%E9%9D%99%E6%80%81%E9%93%BE%E6%8E%A5%E5%92%8C%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5/"
           data-tag=""
           data-author="" >
            <span class="post-title" title=""></span>
            <span class="post-date" title="2023-01-22 11:54:01">2023/01/22</span>
        </a>
        
        
        <a  class="All "
           href="/2023/01/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"
           data-tag=""
           data-author="" >
            <span class="post-title" title=""></span>
            <span class="post-date" title="2023-01-22 11:54:01">2023/01/22</span>
        </a>
        
        
        <a  class="All "
           href="/2023/01/22/%E8%B0%B7%E6%AD%8Cc++%E9%A3%8E%E6%A0%BC/"
           data-tag=""
           data-author="" >
            <span class="post-title" title=""></span>
            <span class="post-date" title="2023-01-22 11:54:01">2023/01/22</span>
        </a>
        
        
        <a  class="All "
           href="/2023/01/22/%E9%98%B2%E5%BE%A1%E5%BC%8F%E7%BC%96%E7%A8%8B%E5%92%8C%E5%A5%91%E7%BA%A6%E5%BC%8F%E7%BC%96%E7%A8%8B%EF%BC%8C%E6%96%AD%E8%A8%80%E5%92%8C%E5%BC%82%E5%B8%B8/"
           data-tag=""
           data-author="" >
            <span class="post-title" title=""></span>
            <span class="post-date" title="2023-01-22 11:54:01">2023/01/22</span>
        </a>
        
        
        <a  class="All "
           href="/2023/01/22/%E5%A4%9A%E7%BB%B4%E6%95%B0%E7%BB%84/"
           data-tag=""
           data-author="" >
            <span class="post-title" title=""></span>
            <span class="post-date" title="2023-01-22 11:54:01">2023/01/22</span>
        </a>
        
        
        <a  class="All "
           href="/2023/01/22/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB%E7%AC%94%E8%AE%B0%EF%BC%88%E7%B1%BB%E4%BC%BCcsapp%E7%9A%84%E4%B9%A6%EF%BC%89/"
           data-tag=""
           data-author="" >
            <span class="post-title" title=""></span>
            <span class="post-date" title="2023-01-22 11:54:01">2023/01/22</span>
        </a>
        
        
        <a  class="All "
           href="/2023/01/22/%E5%B8%B8%E7%94%A8api%E5%92%8C%E5%A4%B4%E6%96%87%E4%BB%B6/"
           data-tag=""
           data-author="" >
            <span class="post-title" title=""></span>
            <span class="post-date" title="2023-01-22 11:54:01">2023/01/22</span>
        </a>
        
        
        <a  class="All "
           href="/2023/01/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"
           data-tag=""
           data-author="" >
            <span class="post-title" title=""></span>
            <span class="post-date" title="2023-01-22 11:54:01">2023/01/22</span>
        </a>
        
        
        <a  class="All "
           href="/2023/01/22/%E7%BC%96%E8%AF%91%E6%9C%9F%E5%B8%B8%E9%87%8F%E5%92%8Cconstexpr/"
           data-tag=""
           data-author="" >
            <span class="post-title" title=""></span>
            <span class="post-date" title="2023-01-22 11:54:01">2023/01/22</span>
        </a>
        
        
        <a  class="All "
           href="/2023/01/22/vscode%20c++%E8%BF%90%E8%A1%8C%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"
           data-tag=""
           data-author="" >
            <span class="post-title" title=""></span>
            <span class="post-date" title="2023-01-22 11:54:01">2023/01/22</span>
        </a>
        
        
        <a  class="All "
           href="/2023/01/22/stdref/"
           data-tag=""
           data-author="" >
            <span class="post-title" title=""></span>
            <span class="post-date" title="2023-01-22 11:54:01">2023/01/22</span>
        </a>
        
        
        <a  class="All "
           href="/2023/01/22/stdaccumulate%E5%92%8Cstdtransform/"
           data-tag=""
           data-author="" >
            <span class="post-title" title=""></span>
            <span class="post-date" title="2023-01-22 11:54:01">2023/01/22</span>
        </a>
        
        
        <a  class="All "
           href="/2023/01/22/socket%20api/"
           data-tag=""
           data-author="" >
            <span class="post-title" title=""></span>
            <span class="post-date" title="2023-01-22 11:54:01">2023/01/22</span>
        </a>
        
        
        <a  class="All "
           href="/2023/01/22/mysql/"
           data-tag=""
           data-author="" >
            <span class="post-title" title=""></span>
            <span class="post-date" title="2023-01-22 11:54:01">2023/01/22</span>
        </a>
        
        
        <a  class="All "
           href="/2023/01/22/muduo%E7%BD%91%E7%BB%9C%E6%BA%90%E7%A0%81/"
           data-tag=""
           data-author="" >
            <span class="post-title" title=""></span>
            <span class="post-date" title="2023-01-22 11:54:01">2023/01/22</span>
        </a>
        
        
        <a  class="All "
           href="/2023/01/22/muduo%E6%97%A5%E5%BF%97/"
           data-tag=""
           data-author="" >
            <span class="post-title" title=""></span>
            <span class="post-date" title="2023-01-22 11:54:01">2023/01/22</span>
        </a>
        
        
        <a  class="All "
           href="/2023/01/22/Linux%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%9C%8D%E5%8A%A1%E7%AB%AF%E7%BC%96%E7%A8%8B%EF%BC%9A%E4%BD%BF%E7%94%A8muduo%20C++%E7%BD%91%E7%BB%9C%E5%BA%93/"
           data-tag=""
           data-author="" >
            <span class="post-title" title=""></span>
            <span class="post-date" title="2023-01-22 11:54:01">2023/01/22</span>
        </a>
        
        
        <a  class="All "
           href="/2023/01/22/linux/"
           data-tag=""
           data-author="" >
            <span class="post-title" title=""></span>
            <span class="post-date" title="2023-01-22 11:54:01">2023/01/22</span>
        </a>
        
        
        <a  class="All "
           href="/2023/01/22/IO%E5%AF%86%E9%9B%86%E5%9E%8B%E4%BB%BB%E5%8A%A1%E5%92%8C%E8%AE%A1%E7%AE%97%E5%AF%86%E9%9B%86%E5%9E%8B%E4%BB%BB%E5%8A%A1/"
           data-tag=""
           data-author="" >
            <span class="post-title" title=""></span>
            <span class="post-date" title="2023-01-22 11:54:01">2023/01/22</span>
        </a>
        
        
        <a  class="All "
           href="/2023/01/22/io%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E5%8E%9F%E7%90%86/"
           data-tag=""
           data-author="" >
            <span class="post-title" title=""></span>
            <span class="post-date" title="2023-01-22 11:54:01">2023/01/22</span>
        </a>
        
        
        <a  class="All "
           href="/2023/01/22/csapp/"
           data-tag=""
           data-author="" >
            <span class="post-title" title=""></span>
            <span class="post-date" title="2023-01-22 11:54:01">2023/01/22</span>
        </a>
        
        
        <a  class="All "
           href="/2023/01/22/CMake%20%E6%A8%A1%E5%9D%97%E5%8C%96%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/"
           data-tag=""
           data-author="" >
            <span class="post-title" title=""></span>
            <span class="post-date" title="2023-01-22 11:54:01">2023/01/22</span>
        </a>
        
        
        <a  class="All "
           href="/2023/01/22/c++%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/"
           data-tag=""
           data-author="" >
            <span class="post-title" title=""></span>
            <span class="post-date" title="2023-01-22 11:54:01">2023/01/22</span>
        </a>
        
        
        <a  class="All "
           href="/2023/01/22/c++%E7%B1%BB%E7%9A%84%E9%BB%98%E8%AE%A4%E5%87%BD%E6%95%B0/"
           data-tag=""
           data-author="" >
            <span class="post-title" title=""></span>
            <span class="post-date" title="2023-01-22 11:54:01">2023/01/22</span>
        </a>
        
        
        <a  class="All "
           href="/2023/01/22/%E8%87%AA%E5%8A%A8%E9%A9%BE%E9%A9%B6/"
           data-tag=""
           data-author="" >
            <span class="post-title" title=""></span>
            <span class="post-date" title="2023-01-22 11:54:01">2023/01/22</span>
        </a>
        
        
        <a  class="All "
           href="/2023/01/22/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E6%80%A7/"
           data-tag=""
           data-author="" >
            <span class="post-title" title=""></span>
            <span class="post-date" title="2023-01-22 11:54:01">2023/01/22</span>
        </a>
        
        
        <a  class="All "
           href="/2023/01/22/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/"
           data-tag=""
           data-author="" >
            <span class="post-title" title=""></span>
            <span class="post-date" title="2023-01-22 11:54:01">2023/01/22</span>
        </a>
        
        
        <a  class="All "
           href="/2023/01/22/%E5%BC%82%E5%B8%B8/"
           data-tag=""
           data-author="" >
            <span class="post-title" title=""></span>
            <span class="post-date" title="2023-01-22 11:54:01">2023/01/22</span>
        </a>
        
        
        <a  class="All "
           href="/2023/01/22/%E7%BA%BF%E7%A8%8B%E6%B1%A0/"
           data-tag=""
           data-author="" >
            <span class="post-title" title=""></span>
            <span class="post-date" title="2023-01-22 11:54:01">2023/01/22</span>
        </a>
        
        
        <a  class="All "
           href="/2023/01/22/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%98%9F%E5%88%97/"
           data-tag=""
           data-author="" >
            <span class="post-title" title=""></span>
            <span class="post-date" title="2023-01-22 11:54:01">2023/01/22</span>
        </a>
        
        
        <a  class="All "
           href="/2023/01/22/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/"
           data-tag=""
           data-author="" >
            <span class="post-title" title=""></span>
            <span class="post-date" title="2023-01-22 11:54:01">2023/01/22</span>
        </a>
        
        
        <a  class="All "
           href="/2023/01/22/%E7%8E%B0%E4%BB%A3CMake/"
           data-tag=""
           data-author="" >
            <span class="post-title" title=""></span>
            <span class="post-date" title="2023-01-22 11:54:01">2023/01/22</span>
        </a>
        
        
        <a  class="All "
           href="/2023/01/21/hello-world/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Hello World">Hello World</span>
            <span class="post-date" title="2023-01-21 23:44:22">2023/01/21</span>
        </a>
        
        <div id="no-item-tips">

        </div>
    </nav>
    <div id="outline-list">
    </div>
</div>

    </div>
    <div class="hide-list">
        <div class="semicircle" data-title="切换全屏 快捷键 s">
            <div class="brackets first"><</div>
            <div class="brackets">&gt;</div>
        </div>
    </div>
</aside>
<div id="post">
    <div class="pjax">
        <article id="post-现代CMake" class="article article-type-post" itemscope itemprop="blogPost">
    
    <div class="article-meta">
        
        
        
        
    </div>
    <div class="article-meta">
        
            Created At : <time class="date" title='Updated At: 2022-12-15 17:35:46'>2023-01-22 11:54</time>
        
    </div>
    <div class="article-meta">
        
        
        <span id="busuanzi_container_page_pv">
            Views 👀 :<span id="busuanzi_value_page_pv">
                <span class="count-comment">
                    <span class="spinner">
                      <div class="cube1"></div>
                      <div class="cube2"></div>
                    </span>
                </span>
            </span>
        </span>
        
        
    </div>
    
    <div class="toc-ref">
    
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%8E%B0%E4%BB%A3CMake"><span class="toc-text">现代CMake</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8%E7%8E%B0%E4%BB%A3CMake"><span class="toc-text">为什么要使用现代CMake</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CMake%E5%91%BD%E4%BB%A4%E8%A1%8C%E9%80%89%E9%A1%B9"><span class="toc-text">CMake命令行选项</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B7%BB%E5%8A%A0%E6%BA%90%E6%96%87%E4%BB%B6"><span class="toc-text">添加源文件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E4%B8%AA%E6%BA%90%E6%96%87%E4%BB%B6%E5%A4%84%E7%90%86"><span class="toc-text">单个源文件处理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E4%B8%AA%E6%BA%90%E6%96%87%E4%BB%B6%E5%A4%84%E7%90%86"><span class="toc-text">多个源文件处理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#GLOB%E6%89%B9%E9%87%8F%E6%B7%BB%E5%8A%A0%E6%BA%90%E6%96%87%E4%BB%B6"><span class="toc-text">GLOB批量添加源文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B7%BB%E5%8A%A0%E5%AD%90%E7%9B%AE%E5%BD%95%E6%BA%90%E6%96%87%E4%BB%B6"><span class="toc-text">添加子目录源文件</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A1%B9%E7%9B%AE%E9%85%8D%E7%BD%AE%E5%8F%98%E9%87%8F"><span class="toc-text">项目配置变量</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#CMAKE-BUILD-TYPE"><span class="toc-text">CMAKE_BUILD_TYPE</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#project"><span class="toc-text">project</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CMAKE-CXX-STANDARD"><span class="toc-text">CMAKE_CXX_STANDARD</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#cmake-minimum-required"><span class="toc-text">cmake_minimum_required</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E5%8F%98%E9%87%8F"><span class="toc-text">其他变量</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B7%BB%E5%8A%A0%E5%AD%90%E6%A8%A1%E5%9D%97"><span class="toc-text">添加子模块</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%90%E9%A1%B9%E7%9B%AE%E7%9A%84%E5%A4%B4%E6%96%87%E4%BB%B6%E6%80%8E%E4%B9%88%E5%A4%84%E7%90%86"><span class="toc-text">子项目的头文件怎么处理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%B9%E9%A1%B9%E7%9B%AE%E5%92%8C%E5%AD%90%E9%A1%B9%E7%9B%AE%E7%9A%84CMakeLists-txt%E9%85%8D%E7%BD%AE"><span class="toc-text">根项目和子项目的CMakeLists.txt配置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BE%9D%E8%B5%96%E5%AD%90%E9%A1%B9%E7%9B%AE"><span class="toc-text">依赖子项目</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%93%BE%E6%8E%A5%E5%BA%93"><span class="toc-text">链接库</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%9F%E6%88%90%E5%92%8C%E9%93%BE%E6%8E%A5%E9%9D%99%E6%80%81%E5%BA%93"><span class="toc-text">生成和链接静态库</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%9F%E6%88%90%E5%92%8C%E9%93%BE%E6%8E%A5%E5%8A%A8%E6%80%81%E5%BA%93"><span class="toc-text">生成和链接动态库</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%9F%E6%88%90%E5%92%8C%E9%93%BE%E6%8E%A5%E5%AF%B9%E8%B1%A1%E5%BA%93"><span class="toc-text">生成和链接对象库</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E5%BA%93%E7%9A%84%E9%BA%BB%E7%83%A6"><span class="toc-text">静态库的麻烦</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#add-library%E6%97%A0%E5%8F%82%E6%95%B0%E6%97%B6%EF%BC%8C%E6%98%AF%E9%9D%99%E6%80%81%E5%BA%93%E8%BF%98%E6%98%AF%E5%8A%A8%E6%80%81%E5%BA%93"><span class="toc-text">add_library无参数时，是静态库还是动态库</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E5%BA%93%E6%97%A0%E6%B3%95%E9%93%BE%E6%8E%A5%E9%9D%99%E6%80%81%E5%BA%93%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95"><span class="toc-text">动态库无法链接静态库解决方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%BE%E4%B8%8D%E5%88%B0dll%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95"><span class="toc-text">找不到dll解决办法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%B1%9E%E6%80%A7"><span class="toc-text">对象的属性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%AE%E6%A0%87%E7%9A%84%E4%B8%80%E4%BA%9B%E9%80%89%E9%A1%B9"><span class="toc-text">目标的一些选项</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8set-property%E8%AE%BE%E7%BD%AE%E5%B1%9E%E6%80%A7"><span class="toc-text">使用set_property设置属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%B9%E9%87%8F%E8%AE%BE%E7%BD%AE%E5%A4%9A%E4%B8%AA%E5%B1%9E%E6%80%A7"><span class="toc-text">批量设置多个属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E7%BD%AE%E5%8F%98%E9%87%8F%E5%92%8C%E8%AE%BE%E7%BD%AE%E5%B1%9E%E6%80%A7%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">设置变量和设置属性的区别</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%93%BE%E6%8E%A5%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93"><span class="toc-text">链接第三方库</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%B4%E6%8E%A5%E9%93%BE%E6%8E%A5"><span class="toc-text">直接链接</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%99%E5%87%BA%E5%AE%8C%E6%95%B4%E8%B7%AF%E5%BE%84"><span class="toc-text">写出完整路径</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8find-package"><span class="toc-text">使用find_package</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%87%E5%AE%9Afind-package%E7%9A%84%E7%BB%84%E4%BB%B6"><span class="toc-text">指定find_package的组件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%A8windows%E4%B8%8A%E6%89%BE%E5%8C%85"><span class="toc-text">在windows上找包</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BE%93%E5%87%BA%E5%92%8C%E5%8F%98%E9%87%8F"><span class="toc-text">输出和变量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%98%E9%87%8F%E5%92%8C%E7%BC%93%E5%AD%98"><span class="toc-text">变量和缓存</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B8%85%E9%99%A4%E7%BC%93%E5%AD%98%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-text">清除缓存的方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E7%BD%AE%E7%BC%93%E5%AD%98%E5%8F%98%E9%87%8F"><span class="toc-text">设置缓存变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9B%B4%E6%96%B0%E7%BC%93%E5%AD%98%E5%8F%98%E9%87%8F"><span class="toc-text">更新缓存变量</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B7%A8%E5%B9%B3%E5%8F%B0%E4%B8%8E%E7%BC%96%E8%AF%91%E5%99%A8"><span class="toc-text">跨平台与编译器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A3%80%E6%B5%8B%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%92%8C%E7%BC%96%E8%AF%91%E5%99%A8"><span class="toc-text">检测操作系统和编译器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E7%94%9F%E6%88%90%E5%99%A8%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%AE%80%E5%8C%96%E6%93%8D%E4%BD%9C"><span class="toc-text">使用生成器表达式简化操作</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E6%94%AF%E5%92%8C%E5%88%A4%E6%96%AD"><span class="toc-text">分支和判断</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%98%E9%87%8F%E4%B8%8E%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-text">变量与作用域</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%98%E9%87%8F%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-text">变量的作用域</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE%E5%8F%98%E9%87%8F"><span class="toc-text">访问变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A4%E6%96%AD%E5%8F%98%E9%87%8F%E6%98%AF%E5%90%A6%E5%AD%98%E5%9C%A8"><span class="toc-text">判断变量是否存在</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E5%BB%BA%E8%AE%AE"><span class="toc-text">其他建议</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#CCache%EF%BC%9A%E7%BC%96%E8%AF%91%E5%8A%A0%E9%80%9F%E7%BC%93%E5%AD%98"><span class="toc-text">CCache：编译加速缓存</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BF%AB%E9%80%9F%E5%90%AF%E5%8A%A8%E4%B8%BB%E7%A8%8B%E5%BA%8F"><span class="toc-text">快速启动主程序</span></a></li></ol></li></ol></li></ol>
    
<style>
    .left-col .switch-btn,
    .left-col .switch-area {
        display: none;
    }
    .toc-level-3 i,
    .toc-level-3 ol {
        display: none !important;
    }
</style>
</div>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="现代CMake"><a href="#现代CMake" class="headerlink" title="现代CMake"></a>现代CMake</h1><h2 id="为什么要使用现代CMake"><a href="#为什么要使用现代CMake" class="headerlink" title="为什么要使用现代CMake"></a>为什么要使用现代CMake</h2><p>现代 CMake 指的是 CMake 3.x，古代 CMake 指的是 CMake 2.x。许多人认识的 CMake 都是古代 CMake，现代 CMake 和古代 CMake 相比，使用更方便，功能更强大。</p>
<p>例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//古代CMake构建步骤复杂</span></span><br><span class="line">mkdir build	<span class="comment">//需要先创建 build 目录      </span></span><br><span class="line">cd build	<span class="comment">//切换到 build 目录	</span></span><br><span class="line">cmake ..	<span class="comment">//在 build 目录运行 cmake &lt;源码目录&gt; 生成 Makefile</span></span><br><span class="line">make -j4	<span class="comment">//执行本地的构建系统 make 真正开始构建（4进程并行）</span></span><br><span class="line">sudo make install	<span class="comment">//让本地的构建系统执行安装步骤</span></span><br><span class="line">cd ..	<span class="comment">//回到源码目录</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//现代CMake提供了更方便的 -B 和 --build 指令，不同平台，统一命令</span></span><br><span class="line">cmake -B build	<span class="comment">// 在源码目录用 -B 直接创建 build 目录并生成 build/Makefile</span></span><br><span class="line">cmake --build build -j4	<span class="comment">// 自动调用本地的构建系统在 build 里构建，即：make -C build -j4</span></span><br><span class="line">sudo cmake --build build --target install	<span class="comment">// 调用本地的构建系统执行 install 这个目标，即安装</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//cmake -B build 免去了先创建 build 目录再切换进去再指定源码目录的麻烦。</span></span><br><span class="line"><span class="comment">//cmake --build build 统一了不同平台（Linux 上会调用 make，Windows 上调用 devenv.exe）</span></span><br><span class="line"><span class="comment">//结论：从现在开始，如果在命令行操作 cmake，请使用更方便的 -B 和 --build 命令。</span></span><br></pre></td></tr></table></figure>

<h2 id="CMake命令行选项"><a href="#CMake命令行选项" class="headerlink" title="CMake命令行选项"></a>CMake命令行选项</h2><p>CMake 项目的构建分为两步：</p>
<ul>
<li>第一步是 cmake -B build，称为配置阶段（configure），这时只检测环境并生成构建规则，会在 build 目录下生成本地构建系统能识别的项目文件（Makefile 或是 .sln）</li>
<li>第二步是 cmake –build build，称为构建阶段（build），这时才实际调用编译器来编译代码，生成可执行文件</li>
</ul>
<p><strong>-B和–build</strong></p>
<p>-B用来生成构建系统文件(makefile,ninja)，而–build则用来调用本地的构建系统生成可执行文件。</p>
<p>-B免去了先创建 build 目录再切换进去再指定源码目录的麻烦。–build统一了不同平台，<strong>如果没有–build这条命令，就需要根据底层构建系统的不同调用不同的构建命令</strong>，比如make或者ninja。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cmake -B build	<span class="comment">// 在源码目录用 -B 直接创建 build 目录并生成 build/Makefile</span></span><br><span class="line">cmake --build build -j4	<span class="comment">// 自动调用本地的构建系统在 build 里构建，即：make -C build -j4</span></span><br></pre></td></tr></table></figure>

<p><strong>-D</strong></p>
<p>-D用于指定配置变量（又称缓存变量）。</p>
<p>在配置阶段(生成makefile的阶段)可以通过 -D 设置缓存变量。第二次配置时，之前的 -D 添加仍然会被保留。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设置安装路径为 /opt/openvdb-8.0（会安装到 /opt/openvdb-8.0/lib/libopenvdb.so）</span></span><br><span class="line">make -B build -DCMAKE_INSTALL_PREFIX=/opt/openvdb<span class="number">-8.0</span></span><br><span class="line"><span class="comment">//设置构建模式为Release（编译期会开启全部优化，区别于Debug模式）</span></span><br><span class="line">cmake -B build -DCMAKE_BUILD_TYPE=Release</span><br><span class="line"></span><br><span class="line"><span class="comment">//第二次配置时没有 -D 参数，但是之前的 -D 设置的变量都会被保留</span></span><br><span class="line">cmake -B build	<span class="comment">//（此时缓存里仍有你之前定义的 CMAKE_BUILD_TYPE 和 CMAKE_INSTALL_PREFIX）</span></span><br></pre></td></tr></table></figure>

<p><strong>-G</strong></p>
<p>-G用于指定要用的生成器。</p>
<p><strong>CMake 是一个跨平台的构建系统，可以从 CMakeLists.txt 生成不同类型的构建系统</strong>（比如 Linux 的 make，Windows 的 MSBuild），从而让构建规则可以只写一份，跨平台使用。过去的软件（例如 TBB）要跨平台，只好 Makefile 的构建规则写一份，MSBuild 也写一份。</p>
<p>现在只需要写一次 CMakeLists.txt，他会视不同的操作系统，生成不同构建系统的规则文件。那个和操作系统绑定的构建系统（make、MSBuild）称为本地构建系统（native buildsystem）。负责从 CMakeLists.txt 生成本地构建系统构建规则文件的，称为生成器（generator）。</p>
<p>Linux 系统上的 CMake 默认用是 Unix Makefiles 生成器；Windows 系统默认是 Visual Studio 2019 生成器；MacOS 系统默认是 Xcode 生成器。可以用 -G 参数改用别的生成器，例如 cmake -GNinja 会生成 Ninja 这个构建系统的构建规则。Ninja 是一个高性能，跨平台的构建系统，Linux、Windows、MacOS 上都可以用。</p>
<p>事实上，MSBuild 是单核心的构建系统，Makefile 虽然多核心但因历史兼容原因效率一般。而 Ninja 则是专为性能优化的构建系统，他和 CMake 结合都是行业标准了。</p>
<p>性能上：Ninja &gt; Makefile &gt; MSBuild。Makefile 启动时会把每个文件都检测一遍，浪费很多时间。特别是有很多文件，但是实际需要构建的只有一小部分，从而是 I&#x2F;O Bound 的时候，Ninja 的速度提升就很明显。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//指定生成ninja的构建规则</span></span><br><span class="line">cmake -Gninja -B build</span><br></pre></td></tr></table></figure>

<h2 id="添加源文件"><a href="#添加源文件" class="headerlink" title="添加源文件"></a>添加源文件</h2><h3 id="单个源文件处理"><a href="#单个源文件处理" class="headerlink" title="单个源文件处理"></a>单个源文件处理</h3><p>1.<strong>add_executable添加源文件</strong></p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_executable</span>(main main.cpp)</span><br></pre></td></tr></table></figure>

<p>2.<strong>先创建目标，稍后再添加源文件</strong></p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_executable</span>(main)</span><br><span class="line"><span class="keyword">target_sources</span>(main PUBLIC main.cpp)</span><br></pre></td></tr></table></figure>

<h3 id="多个源文件处理"><a href="#多个源文件处理" class="headerlink" title="多个源文件处理"></a>多个源文件处理</h3><p>1.<strong>逐个文件添加即可</strong></p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_executable</span>(main)</span><br><span class="line"><span class="keyword">target_sources</span>(main PUBLIC main.cpp other.cpp)</span><br></pre></td></tr></table></figure>

<p>2.<strong>使用变量存储文件名</strong></p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#set设置变量，$&#123;var&#125;引用</span></span><br><span class="line"><span class="keyword">add_executable</span>(main)</span><br><span class="line"><span class="keyword">set</span>(sources main.cpp other.cpp)</span><br><span class="line"><span class="keyword">target_sources</span>(main PUBLIC <span class="variable">$&#123;sources&#125;</span>)</span><br></pre></td></tr></table></figure>

<p><strong>TIP</strong>:可以在添加时加上.h头文件，这样在 VS 里可以出现在“Header Files”一栏</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_executable</span>(main)</span><br><span class="line"><span class="keyword">set</span>(sources main.cpp other.cpp other.h)</span><br><span class="line"><span class="keyword">target_sources</span>(main PUBLIC <span class="variable">$&#123;sources&#125;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="GLOB批量添加源文件"><a href="#GLOB批量添加源文件" class="headerlink" title="GLOB批量添加源文件"></a>GLOB批量添加源文件</h3><p>使用 <strong>GLOB</strong> 自动查找当前目录下指定扩展名的文件，实现批量添加源文件</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_executable</span>(main)</span><br><span class="line"><span class="keyword">file</span>(GLOB sources *.cpp *.h)</span><br><span class="line"><span class="keyword">target_sources</span>(main PUBLIC <span class="variable">$&#123;sources&#125;</span>)</span><br></pre></td></tr></table></figure>

<p><strong>缺陷和改进</strong>：set设置的变量在第一次配置后会缓存在文件中，后续多次构建不会更新。启用 <strong>CONFIGURE_DEPENDS</strong> 选项，当添加新文件时，自动更新变量(<strong>推荐</strong>)</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_executable</span>(main)</span><br><span class="line"><span class="keyword">file</span>(GLOB sources CONFIGURE_DEPENDS *.cpp *.h)</span><br><span class="line"><span class="keyword">target_sources</span>(main PUBLIC <span class="variable">$&#123;sources&#125;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="添加子目录源文件"><a href="#添加子目录源文件" class="headerlink" title="添加子目录源文件"></a>添加子目录源文件</h3><p>上述方法添加子目录源文件必须把路径名和后缀名的排列组合全部写出来，过于麻烦。</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_executable</span>(main)</span><br><span class="line"><span class="keyword">file</span>(GLOB sources CONFIGURE_DEPENDS *.cpp *.h mylib/*.cpp mylib/*.h)</span><br><span class="line"><span class="keyword">target_sources</span>(main PUBLIC <span class="variable">$&#123;sources&#125;</span>)</span><br></pre></td></tr></table></figure>

<p><strong>改进</strong>：</p>
<p>1.用 <strong>aux_source_directory</strong>，自动搜集需要的文件后缀名</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_executable</span>(main)</span><br><span class="line"><span class="keyword">aux_source_directory</span>(. sources) <span class="comment">#搜索当前目录</span></span><br><span class="line"><span class="keyword">aux_source_directory</span>(mylib sources) <span class="comment">#搜索mylib目录</span></span><br><span class="line"><span class="keyword">target_sources</span>(main PUBLIC <span class="variable">$&#123;sources&#125;</span>)</span><br></pre></td></tr></table></figure>

<p>2.使用 <strong>GLOB_RECURSE</strong> 自动包含所有子文件夹下的文件</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_executable</span>(main)</span><br><span class="line"><span class="keyword">file</span>(GLOB_RECURSE sources CONFIGURE_DEPENDS *.cpp *.h)</span><br><span class="line"><span class="keyword">target_sources</span>(main PUBLIC <span class="variable">$&#123;sources&#125;</span>)</span><br></pre></td></tr></table></figure>

<p><strong>缺陷</strong>：因为<strong>GLOB_RECURSE</strong>自动包含所有子文件夹的文件，所以它会把 <strong>build</strong> 目录里生成的临时 .cpp 文件也加进来</p>
<p><strong>解决方案</strong>：要么把源码统一放到 src 目录下，要么要求使用者不要把 build 放到和源码同一个目录里，建议把源码放到 src 目录下，然后在文件名前面添加src路径(<strong>推荐</strong>)</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_executable</span>(main)</span><br><span class="line"><span class="keyword">file</span>(GLOB_RECURSE sources CONFIGURE_DEPENDS src/*.cpp src/*.h)</span><br><span class="line"><span class="keyword">target_sources</span>(main PUBLIC <span class="variable">$&#123;sources&#125;</span>)</span><br></pre></td></tr></table></figure>

<h2 id="项目配置变量"><a href="#项目配置变量" class="headerlink" title="项目配置变量"></a>项目配置变量</h2><h3 id="CMAKE-BUILD-TYPE"><a href="#CMAKE-BUILD-TYPE" class="headerlink" title="CMAKE_BUILD_TYPE"></a><strong>CMAKE_BUILD_TYPE</strong></h3><p>CMAKE_BUILD_TYPE 是 CMake 中一个特殊的变量，用于控制构建类型，他的值可以是：</p>
<ul>
<li>Debug 调试模式，完全不优化，生成调试信息，方便调试程序</li>
<li>Release 发布模式，优化程度最高，性能最佳，但是编译比 Debug 慢</li>
<li>MinSizeRel 最小体积发布，生成的文件比 Release 更小，不完全优化，减少二进制体积</li>
<li>RelWithDebInfo 带调试信息发布，生成的文件比 Release 更大，因为带有调试的符号信息</li>
</ul>
<p>默认情况下 CMAKE_BUILD_TYPE 为空字符串，这时相当于 Debug</p>
<p><strong>各种构建模式在编译器选项上的区别</strong></p>
<ul>
<li>Debug: <code>-O0 -g</code></li>
<li>Release: <code>-O3 -DNDEBUG</code></li>
<li>MinSizeRel: <code>-Os -DNDEBUG</code></li>
<li>RelWithDebInfo: <code>-O2 -g -DNDEBUG</code></li>
</ul>
<p>注意定义了 NDEBUG 宏会使 assert 被去除掉。</p>
<p><strong>修改变量的默认值</strong></p>
<p>如何让 CMAKE_BUILD_TYPE 在用户没有指定的时候为 Release，指定的时候保持用户指定的值不变呢。通过 if (NOT CMAKE_BUILD_TYPE) 判断是否为空，如果空则自动设为 Release 模式。</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="keyword">NOT</span> CMAKE_BUILD_TYPE)</span><br><span class="line">	<span class="keyword">set</span>(CMAKE_BUILD_TYPE Release)</span><br><span class="line"><span class="keyword">endif</span>()</span><br></pre></td></tr></table></figure>

<h3 id="project"><a href="#project" class="headerlink" title="project"></a>project</h3><p>project会初始化项目信息，并把当前 <strong>CMakeLists.txt</strong>所在位置作为根目录，设置了project后会初始化一系列跟project相关的变量。</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.15</span>)</span><br><span class="line"><span class="keyword">project</span>(hellocmake)</span><br><span class="line"></span><br><span class="line"><span class="keyword">message</span>(<span class="string">&quot;PROJECT_NAME: $&#123;PROJECT_NAME&#125;&quot;</span>)</span><br><span class="line"><span class="keyword">message</span>(<span class="string">&quot;PROJECT_SOURCE_DIR: $&#123;PROJECT_SOURCE_DIR&#125;&quot;</span>)</span><br><span class="line"><span class="keyword">message</span>(<span class="string">&quot;PROJECT_BINARY_DIR: $&#123;PROJECT_BINARY_DIR&#125;&quot;</span>)</span><br><span class="line"><span class="keyword">message</span>(<span class="string">&quot;CMAKE_CURRENT_SOURCE_DIR: $&#123;CMAKE_CURRENT_SOURCE_DIR&#125;&quot;</span>) <span class="comment">#表示当前源码目录的位置，如~/hellocmake</span></span><br><span class="line"><span class="keyword">message</span>(<span class="string">&quot;CMAKE_CURRENT_BINARY_DIR: $&#123;CMAKE_CURRENT_BINARY_DIR&#125;&quot;</span>) <span class="comment">#表示当前输出目录的位置，如~/hellocmake/build</span></span><br><span class="line"><span class="keyword">add_executable</span>(main main.cpp)</span><br></pre></td></tr></table></figure>

<p><strong>PROJECT_x_DIR</strong> <strong>和</strong> <strong>CMAKE_CURRENT_x_DIR</strong> <strong>的区别</strong></p>
<ul>
<li>PROJECT_SOURCE_DIR 表示最近一次调用 project 的 CMakeLists.txt 所在的源码目录。</li>
<li>CMAKE_CURRENT_SOURCE_DIR 表示当前 CMakeLists.txt 所在的源码目录。</li>
<li>CMAKE_SOURCE_DIR 表示最为外层 CMakeLists.txt 的源码根目录。</li>
</ul>
<p>利用 PROJECT_SOURCE_DIR 可以实现从子模块里直接获得项目最外层目录的路径。<strong>不建议用</strong> CMAKE_SOURCE_DIR，那样会让你的项目无法被人作为子模块使用。</p>
<p><strong>其他相关变量</strong></p>
<ul>
<li>PROJECT_SOURCE_DIR：当前项目源码路径（存放main.cpp的地方）</li>
<li>PROJECT_BINARY_DIR：当前项目输出路径（存放main.exe的地方）</li>
<li>CMAKE_SOURCE_DIR：根项目源码路径（存放main.cpp的地方）</li>
<li>CMAKE_BINARY_DIR：根项目输出路径（存放main.exe的地方）</li>
<li>PROJECT_IS_TOP_LEVEL：BOOL类型，表示当前项目是否是（最顶层的）根项目</li>
<li>PROJECT_NAME：当前项目名</li>
<li>CMAKE_PROJECT_NAME：根项目的项目名</li>
</ul>
<p><strong>用项目名代替PROJECT_NAME</strong></p>
<p>可以用项目名代替PROJECT_NAME。除此之外CMake 的 <strong>${}</strong> 表达式还可以嵌套使用</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.15</span>)</span><br><span class="line"><span class="keyword">project</span>(hellocmake VERSION <span class="number">0.2</span>.<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">message</span>(<span class="string">&quot;PROJECT_NAME: $&#123;PROJECT_NAME&#125;&quot;</span>)</span><br><span class="line"><span class="keyword">message</span>(<span class="string">&quot;PROJECT_VERSION: $&#123;PROJECT_VERSION&#125;&quot;</span>)</span><br><span class="line"><span class="keyword">message</span>(<span class="string">&quot;PROJECT_SOURCE_DIR: $&#123;PROJECT_SOURCE_DIR&#125;&quot;</span>)</span><br><span class="line"><span class="keyword">message</span>(<span class="string">&quot;PROJECT_BINARY_DIR: $&#123;PROJECT_BINARY_DIR&#125;&quot;</span>)</span><br><span class="line"><span class="keyword">message</span>(<span class="string">&quot;hellocmake_VERSION: $&#123;hellocmake_VERSION&#125;&quot;</span>) <span class="comment">#直接用hellocmake拼接_VERSION也可以使用</span></span><br><span class="line"><span class="keyword">message</span>(<span class="string">&quot;hellocmake_SOURCE_DIR: $&#123;hellocmake_SOURCE_DIR&#125;&quot;</span>)</span><br><span class="line"><span class="keyword">message</span>(<span class="string">&quot;hellocmake_BINARY_DIR: $&#123;hellocmake_BINARY_DIR&#125;&quot;</span>)</span><br><span class="line"><span class="keyword">message</span>(<span class="string">&quot;hellocmake_SOURCE_DIR: $&#123;$&#123;PROJECT_NAME&#125;_SOURCE_DIR&#125;&quot;</span>) <span class="comment">#在表达式内嵌套project_name，效果一样</span></span><br><span class="line"><span class="keyword">add_executable</span>(main main.cpp)</span><br></pre></td></tr></table></figure>

<p><strong>设置子模块为project</strong></p>
<p>子模块里也可以用 <strong>project</strong>命令，将当前目录作为一个独立的子项目。</p>
<p>这样一来 PROJECT_SOURCE_DIR <strong>就会是子模块的源码目录而不是外层了</strong>。这时候 CMake 会认为这个子模块是个独立的项目，会额外做一些初始化。他的构建目录 PROJECT_BINARY_DIR 也会变成 build&#x2F;&lt;源码相对路径&gt;。这样在 MSVC 上也会看见子项目的生成。</p>
<p><strong>project的LANGUAGES字段</strong></p>
<p>project(项目名 LANGUAGES 使用的语言列表…) 指定了该项目使用了哪些编程语言。</p>
<p>目前支持的语言包括：</p>
<ul>
<li>C：C语言</li>
<li>CXX：C++语言</li>
<li>ASM：汇编语言</li>
<li>Fortran：老年人的编程语言</li>
<li>CUDA：英伟达的 CUDA（3.8 版本新增）</li>
<li>OBJC：苹果的 Objective-C（3.16 版本新增）</li>
<li>OBJCXX：苹果的 Objective-C++（3.16 版本新增）</li>
<li>ISPC：一种因特尔的自动 SIMD 编程语言（3.18 版本新增）</li>
</ul>
<p>如果不指定 LANGUAGES，默认为 C 和 CXX。</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.15</span>)</span><br><span class="line"><span class="keyword">project</span>(hellocmake LANGUAGES CXX)</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>(CMAKE_BUILD_TYPE Release)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_executable</span>(main main.cpp)</span><br></pre></td></tr></table></figure>

<p>也可以先设置 <strong>LANGUAGES NONE</strong>，之后再调用 **enable_language(CXX)**。这样可以把 enable_language 放到 if 语句里，从而只有某些选项开启才启用某语言之类的</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.15</span>)</span><br><span class="line"><span class="keyword">project</span>(hellocmake LANGUAGES NONE)</span><br><span class="line"><span class="keyword">enable_language</span>(CXX)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_executable</span>(main main.cpp)</span><br></pre></td></tr></table></figure>

<p><strong>project的version字段</strong></p>
<p>project(项目名 VERSION x.y.z) 可以把当前项目的版本号设定为 x.y.z。之后可以通过 PROJECT_VERSION 来获取当前项目的版本号。</p>
<ul>
<li>PROJECT_VERSION_MAJOR 获取 x（主版本号）。</li>
<li>PROJECT_VERSION_MINOR 获取 y（次版本号）。</li>
<li>PROJECT_VERSION_PATCH 获取 z（补丁版本号）。</li>
</ul>
<p><strong>其他的一些项目字段</strong></p>
<p>CMake 官方还提供了一些project字段，但用的较少。</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.15</span>)</span><br><span class="line"><span class="keyword">project</span>(hellocmake</span><br><span class="line">    DESCRIPTION <span class="string">&quot;A free, open-source, online modern C++ course&quot;</span></span><br><span class="line">    HOMEPAGE_URL https://github.com/parallel101/course</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line"><span class="keyword">message</span>(<span class="string">&quot;PROJECT_NAME: $&#123;PROJECT_NAME&#125;&quot;</span>)</span><br><span class="line"><span class="keyword">message</span>(<span class="string">&quot;PROJECT_DESCRIPTION: $&#123;PROJECT_DESCRIPTION&#125;&quot;</span>)</span><br><span class="line"><span class="keyword">message</span>(<span class="string">&quot;PROJECT_HOMEPAGE_URL: $&#123;PROJECT_HOMEPAGE_URL&#125;&quot;</span>)</span><br><span class="line"><span class="keyword">add_executable</span>(main main.cpp)</span><br></pre></td></tr></table></figure>

<h3 id="CMAKE-CXX-STANDARD"><a href="#CMAKE-CXX-STANDARD" class="headerlink" title="CMAKE_CXX_STANDARD"></a>CMAKE_CXX_STANDARD</h3><p>CMAKE_CXX_STANDARD 是一个整数，表示要用的 C++ 标准。比如需要 C++17 那就设为 17，需要 C++23 就设为 23。</p>
<p>CMAKE_CXX_STANDARD_REQUIRED 是 BOOL 类型，可以为 ON 或 OFF，默认 OFF。他表示是否一定要支持你指定的 C++ 标准：如果为 OFF 则 CMake 检测到编译器不支持 C++17 时不报错，而是默默调低到 C++14 给你用；为 ON 则发现不支持报错，更安全。</p>
<p>CMAKE_CXX_EXTENSIONS 也是 BOOL 类型，默认为 ON。设为 ON 表示启用 GCC 特有的一些扩展功能；OFF 则关闭 GCC 的扩展功能，只使用标准的 C++。<strong>要兼容其他编译器（如 MSVC）的项目，都会设为 OFF 防止不小心用了 GCC 才有的特性。</strong></p>
<p>此外，<strong>最好是在 project 指令前设置 CMAKE_CXX_STANDARD 这一系列变量</strong>，这样 CMake 可以在 project 函数里对编译器进行一些检测，看看他能不能支持 C++17 的特性。</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.15</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD <span class="number">17</span>)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD_REQUIRED <span class="keyword">ON</span>)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_EXTENSIONS <span class="keyword">ON</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">project</span>(hellocmake LANGUAGES CXX)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_executable</span>(main main.cpp)</span><br></pre></td></tr></table></figure>

<p><strong>TIP</strong>:请勿直接修改 CMAKE_CXX_FLAGS 来添加 -std&#x3D;c++17，因为这并不能兼容所有的编译器(如MSVC)；此外如果 CMake 已经自动根据 CMAKE_CXX_STANDARD 的默认值 11 添加 -std&#x3D;c++11 选项了，手动添加 -std&#x3D;c++17 选项会造成冲突。</p>
<h3 id="cmake-minimum-required"><a href="#cmake-minimum-required" class="headerlink" title="cmake_minimum_required"></a><strong>cmake_minimum_required</strong></h3><p><strong>cmake_minimum_required</strong> 指定最低所需的 CMake 版本。</p>
<p>假如你写的 CMakeLists.txt 包含了 3.15 版本才有的特性，如果用户在老版本上使用，就会出现各种奇怪的错误。因此最好在第一行加个 cmake_minimum_required(VERSION 3.15)，表示本 CMakeLists.txt 至少需要 CMake 版本 3.15 以上才能运行。如果用户的 CMake 版本小于 3.15，会正常报错提示版本过低，而不是等到某处用到 3.15 版本才有的特性时才出错。</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.15</span>...<span class="number">3.20</span>)</span><br><span class="line"><span class="keyword">project</span>(hellocmake LANGUAGES CXX)</span><br><span class="line"></span><br><span class="line"><span class="keyword">message</span>(<span class="string">&quot;CMAKE_VERSION: $&#123;CMAKE_VERSION&#125;&quot;</span>)</span><br><span class="line"><span class="keyword">message</span>(<span class="string">&quot;CMAKE_MINIMUM_REQUIRED_VERSION: $&#123;CMAKE_MINIMUM_REQUIRED_VERSION&#125;&quot;</span>)</span><br><span class="line"><span class="keyword">add_executable</span>(main main.cpp)</span><br></pre></td></tr></table></figure>

<p><strong>TIP</strong>:虽然名字叫 minimum_required，实际上不光是 &gt;&#x3D; 3.15 就不出错这么简单。根据你指定的不同的版本号，还会决定接下来一系列 CMake 指令的行为。此外，你还可以通过 3.15…3.20 来表示最高版本不超过 3.20。这会对 cmake_policy 有所影响，稍后再提。</p>
<h3 id="其他变量"><a href="#其他变量" class="headerlink" title="其他变量"></a>其他变量</h3><ul>
<li>CMAKE_BUILD_TOOL: 执行构建过程的工具。该变量设置为CMake构建时输出所需的程序。对于VS 6， CMAKE_BUILD_TOOL设置为msdev， 对于Unix，它被设置为make 或 gmake。 对于 VS 7， 它被设置为devenv. 对于Nmake构建文件，它的值为nmake。</li>
<li>CMAKE_DL_LIBS: 包含dlopen和dlclose的库的名称。</li>
<li>CMAKE_COMMAND: 指向cmake可执行程序的全路径。</li>
<li>CMAKE_CTEST_COMMAND: 指向ctest可执行程序的全路径。</li>
<li>CMAKE_EDIT_COMMAND: cmake-gui或ccmake的全路径。</li>
<li>CMAKE_EXECUTABLE_SUFFIX: 该平台上可执行程序的后缀。</li>
<li>CMAKE_SIZEOF_VOID_P: void指针的大小。</li>
<li>CMAKE_SKIP_RPATH: 如果为真，将不添加运行时路径信息。默认情况下是如果平台支持运行时信息，将会添加运行时信息到可执行程序当中。这样从构建树中运行程序将很容易。为了在安装过程中忽略掉RPATH，使用CMAKE_SKIP_INSTALL_RPATH。</li>
<li>CMAKE_GENERATOR: 构建工程的产生器。它将产生构建文件 (e.g. “Unix Makefiles”, “Visual Studio 2019”, etc.)</li>
</ul>
<h2 id="添加子模块"><a href="#添加子模块" class="headerlink" title="添加子模块"></a>添加子模块</h2><p>大型的项目，往往会划分为几个子项目。即使你只有一个子项目，也建议你先创建一个子目录，方便以后追加新的子项目。</p>
<img src="https://raw.githubusercontent.com/hufei96/Image/main/project_dirctory.png" alt="image-20221215015212928" style="zoom: 33%;" />

<p>上图的案例中，我们在根目录下，创建了两个子项目 biology 和 pybmain，他们分别在各自的目录下有自己的 CMakeLists.txt。</p>
<h3 id="子项目的头文件怎么处理"><a href="#子项目的头文件怎么处理" class="headerlink" title="子项目的头文件怎么处理"></a>子项目的头文件怎么处理</h3><p>可以通过 target_include_directories 指定目标文件的头文件搜索目录，将搜索目录指定为子项目的include文件夹，这样甚至可以用 &lt;xx.h&gt; 来引用子项目的头文件了，因为<strong>通过 target_include_directories 指定的路径会被视为与系统路径等价</strong>，</p>
<blockquote>
<p>TIP:&lt;cstdio&gt; 这种形式表示<strong>不要在当前目录下搜索</strong>，只在系统目录里搜索，”hello.h” 这种形式则<strong>优先搜索当前目录</strong>下有没有这个文件，找不到再搜索系统目录。</p>
</blockquote>
<p>难道每个目标文件用到子项目的库时都得再指定一遍搜索路径吗？</p>
<p>不需要，<strong>我们只需要在子项目的CMakeLists.txt中指定自身的头文件搜索路径</strong>，链接他的可执行文件会<strong>自动添加这个路径作为头文件目录</strong>：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#biology下的CMakeLists.txt</span></span><br><span class="line"><span class="keyword">file</span>(GLOB_RECURSE srcs CONFIGURE_DEPENDS src/*.cpp <span class="keyword">include</span>/*.h)</span><br><span class="line"><span class="keyword">add_library</span>(biology STATIC <span class="variable">$&#123;srcs&#125;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#这条语句让链接 biology 的目标文件也能够共享/biology/include 这个头文件搜索路径</span></span><br><span class="line"><span class="keyword">target_include_directories</span>(biology PUBLIC <span class="keyword">include</span>)</span><br></pre></td></tr></table></figure>

<p>此外，如果不希望让引用biology的可执行文件自动添加这个路径，把 <strong>PUBLIC</strong> 改成 <strong>PRIVATE</strong> 即可。这就是他们的用途：决定一个属性要不要在被 link 的时候传播。</p>
<h3 id="根项目和子项目的CMakeLists-txt配置"><a href="#根项目和子项目的CMakeLists-txt配置" class="headerlink" title="根项目和子项目的CMakeLists.txt配置"></a>根项目和子项目的CMakeLists.txt配置</h3><p>根项目的 CMakeLists.txt 负责处理全局有效的设定。而子项目的 CMakeLists.txt 则仅考虑该子项目自身的设定，比如他的头文件目录，要链接的库等等。</p>
<p><strong>根项目的CMakeLists.txt配置</strong></p>
<p>在根项目的 CMakeLists.txt 中，设置了默认的构建模式，设置了统一的 C++ 版本等各种选项。然后通过 project 命令初始化了根项目。(<strong>这些设置应该放在project命令之前</strong>)</p>
<p>随后通过 add_subdirectory 把两个子项目 pybmain 和 biology 添加进来（顺序无关紧要），这会调用 pybmain&#x2F;CMakeLists.txt 和 biology&#x2F;CMakeLists.txt。</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.18</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">NOT</span> CMAKE_BUILD_TYPE)</span><br><span class="line">    <span class="keyword">set</span>(CMAKE_BUILD_TYPE Release)</span><br><span class="line"><span class="keyword">endif</span>()</span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD <span class="number">20</span>)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD_REQUIRED <span class="keyword">ON</span>)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_EXTENSIONS <span class="keyword">OFF</span>)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_MODULE_PATH <span class="string">&quot;$&#123;CMAKE_CURRENT_LIST_DIR&#125;/cmake;$&#123;CMAKE_MODULE_PATH&#125;&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">project</span>(CppCMakeDemo LANGUAGES CXX)</span><br><span class="line"></span><br><span class="line"><span class="keyword">include</span>(MyUsefulFuncs)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_subdirectory</span>(pybmain)</span><br><span class="line"><span class="keyword">add_subdirectory</span>(biology)</span><br></pre></td></tr></table></figure>

<p><strong>子项目的CMakeLists.txt配置</strong></p>
<p>子项目的 CMakeLists.txt 就干净许多，只是创建了 biology 这个静态库对象，并通过 GLOB_RECRUSE 为他批量添加了所有位于 src 和 include 下源码和头文件。</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">file</span>(GLOB_RECURSE srcs CONFIGURE_DEPENDS src/*.cpp <span class="keyword">include</span>/*.h)</span><br><span class="line"><span class="keyword">add_library</span>(biology STATIC <span class="variable">$&#123;srcs&#125;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#这条语句让链接 biology 的目标文件也能够共享/biology/include 这个头文件搜索路径</span></span><br><span class="line"><span class="keyword">target_include_directories</span>(biology PUBLIC <span class="keyword">include</span>)</span><br></pre></td></tr></table></figure>

<h3 id="依赖子项目"><a href="#依赖子项目" class="headerlink" title="依赖子项目"></a>依赖子项目</h3><p>依赖另一个子项目，则需要链接他</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">file</span>(GLOB_RECURSE srcs CONFIGURE_DEPENDS src/*.cpp <span class="keyword">include</span>/*.h)</span><br><span class="line"><span class="keyword">add_executable</span>(pybmain <span class="variable">$&#123;srcs&#125;</span>)</span><br><span class="line"><span class="keyword">target_include_directories</span>(pybmain PUBLIC <span class="keyword">include</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">target_link_libraries</span>(pybmain PUBLIC biology)</span><br></pre></td></tr></table></figure>

<p>由于 PUBLIC 属性具有传染性，根&#x2F;biology&#x2F;include 现在也加入 pybmain 的头文件搜索路径了，因此 pybmain 里可以 #include 到 biology 的头文件。</p>
<p>同理如果又有一个 target_link_libraries(zxxpig PUBLIC pybmain) 那么 zxxpig 也有 pybmain 和 biology 的所有头文件搜索路径了。</p>
<h2 id="链接库"><a href="#链接库" class="headerlink" title="链接库"></a>链接库</h2><h3 id="生成和链接静态库"><a href="#生成和链接静态库" class="headerlink" title="生成和链接静态库"></a><strong>生成和链接静态库</strong></h3><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_library</span>(mylib STATIC mylib.cpp) <span class="comment"># mylib.cpp编译为静态库libmylib.a</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">add_executable</span>(main main.cpp)</span><br><span class="line"></span><br><span class="line"><span class="keyword">target_link_libraries</span>(main PUBLIC mylib) <span class="comment"># 链接mylib</span></span><br></pre></td></tr></table></figure>

<h3 id="生成和链接动态库"><a href="#生成和链接动态库" class="headerlink" title="生成和链接动态库"></a><strong>生成和链接动态库</strong></h3><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_library</span>(mylib SHARED mylib.cpp) <span class="comment"># mylib.cpp编译成动态库 libmylib.so文件</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">add_executable</span>(main main.cpp)</span><br><span class="line"></span><br><span class="line"><span class="keyword">target_link_libraries</span>(main PUBLIC mylib)</span><br></pre></td></tr></table></figure>

<p>windows对动态库很不友好，如果一定要使用的话，需要在实现处加上__declspec(dllexport)用于导出符号，也就是定义该函数的dll；在声明处加上__declspec(dllimport)用于导入，也就是使用该函数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//mylib.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _MSC_VER</span></span><br><span class="line">__declspec(dllexport)</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">say_hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//mylib.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _MSC_VER</span></span><br><span class="line">__declspec(dllimport)</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">say_hello</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="生成和链接对象库"><a href="#生成和链接对象库" class="headerlink" title="生成和链接对象库"></a><strong>生成和链接对象库</strong></h3><p>大型项目经常将源文件分为组，可能在单独的子目录中，分别需要不同的包含目录和预处理器定义。为此CMake 开发了对象库的概念。</p>
<p>对象库类似于静态库，但不生成 .a 文件，只由 CMake 记住该库生成了哪些对象文件, <strong>对象库是 CMake 自创的，绕开了编译器和操作系统的各种繁琐规则，保证了跨平台统一性。</strong>在自己的项目中，<strong>推荐全部用对象库(OBJECT)替代静态库(STATIC)避免跨平台的麻烦。</strong>对象库仅仅作为组织代码的方式，而实际生成的可执行文件只有一个，减轻了部署的困难。</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_library</span>(mylib OBJECT mylib.cpp)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_executable</span>(main main.cpp)</span><br><span class="line"></span><br><span class="line"><span class="keyword">target_link_libraries</span>(main PUBLIC mylib)</span><br></pre></td></tr></table></figure>

<h3 id="静态库的麻烦"><a href="#静态库的麻烦" class="headerlink" title="静态库的麻烦"></a><strong>静态库的麻烦</strong></h3><p><strong>GCC</strong> 编译器自作聪明，会自动剔除没有引用符号的那些对象。也就是说如果没有用到引用的库，那么这个库可能不会进行链接，在库中定义的全局变量也会失效，如果我们想用静态库在执行main函数之前做一些全局初始化的操作，那么很可能会失败。</p>
<p>使用对象库或动态库可以避免这个问题。也可以设置对象属性告诉编译器不要自动剔除没有引用符号的链接库。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//mylib.cpp</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> unused = <span class="built_in">printf</span>(<span class="string">&quot;mylib initialized&quot;</span>); <span class="comment">//未执行</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//main.cpp</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;main function&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="add-library无参数时，是静态库还是动态库"><a href="#add-library无参数时，是静态库还是动态库" class="headerlink" title="add_library无参数时，是静态库还是动态库"></a><strong>add_library无参数时，是静态库还是动态库</strong></h3><p>会根据 <strong>BUILD_SHARED_LIBS 这个变量的值决定是动态库还是静态库</strong>。ON 则相当于 SHARED，OFF 则相当于 STATIC。</p>
<p>如果未指定 BUILD_SHARED_LIBS 变量，则<strong>默认为 STATIC。</strong>因此，如果发现一个项目里的 add_library 都是无参数的，意味着你可以用：cmake -B build -DBUILD_SHARED_LIBS:BOOL&#x3D;ON 来让他全部生成为动态库。</p>
<p>要让 BUILD_SHARED_LIBS 默认为 ON，可以用下图这个方法：如果该变量没有定义，则设为 ON，否则保持用户指定的值不变。这样当用户没有指定 BUILD_SHARED_LIBS 这个变量时，会默认变成 ON。也就是说除非用户指定了 -DBUILD_SHARED_LIBS:BOOL&#x3D;OFF 才会生成静态库，否则默认是生成动态库。</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">NOT</span> <span class="keyword">DEFINED</span> BUILD_SHARED_LIBS)</span><br><span class="line">    <span class="keyword">set</span>(BUILD_SHARED_LIBS <span class="keyword">ON</span>)</span><br><span class="line"><span class="keyword">endif</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_library</span>(mylib mylib.cpp)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_executable</span>(main main.cpp)</span><br><span class="line"></span><br><span class="line"><span class="keyword">target_link_libraries</span>(main PUBLIC mylib)</span><br></pre></td></tr></table></figure>

<h3 id="动态库无法链接静态库解决方法"><a href="#动态库无法链接静态库解决方法" class="headerlink" title="动态库无法链接静态库解决方法"></a><strong>动态库无法链接静态库解决方法</strong></h3><p>我们一般使用动态库链接动态库时，可以这样处理:</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_library</span>(otherlib STATIC otherlib.cpp)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_library</span>(mylib SHARED mylib.cpp)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(mylib PUBLIC otherlib)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_executable</span>(main main.cpp)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(main PUBLIC mylib)</span><br></pre></td></tr></table></figure>

<p>但是会报错，解决: <strong>让静态库编译时也生成位置无关的代码(PIC)，这样才能装在动态库里</strong></p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_library</span>(otherlib STATIC otherlib.cpp)</span><br><span class="line"><span class="keyword">set_property</span>(<span class="keyword">TARGET</span> otherlib PROPERTY POSITION_INDEPENDENT_CODE <span class="keyword">ON</span>) <span class="comment"># 只针对otherlib库</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">add_library</span>(mylib SHARED mylib.cpp)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(mylib PUBLIC otherlib)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_executable</span>(main main.cpp)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(main PUBLIC mylib)</span><br></pre></td></tr></table></figure>

<p>或者全局设置</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span>(CMAKE_POSITION_INDEPENDENT_CODE <span class="keyword">ON</span>)</span><br><span class="line"><span class="keyword">add_library</span>(otherlib STATIC otherlib.cpp)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_library</span>(mylib SHARED mylib.cpp)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(mylib PUBLIC otherlib)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_executable</span>(main main.cpp)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(main PUBLIC mylib)</span><br></pre></td></tr></table></figure>

<h3 id="找不到dll解决办法"><a href="#找不到dll解决办法" class="headerlink" title="找不到dll解决办法"></a>找不到dll解决办法</h3><p>这是因为你的 dll 和 exe 不在同一目录。Windows 比较蠢，他只会找当前 exe 所在目录，然后查找 PATH，找不到就报错。而你的 dll 在其他目录，因此 Windows 会找不到 dll。</p>
<ul>
<li><p>解决1：把 dll 所在位置加到你的 PATH 环境变量里去，一劳永逸。</p>
</li>
<li><p>解决2：把这个 dll，以及这个 dll 所依赖的其他 dll，全部拷贝到和 exe 文件同一目录下。</p>
</li>
<li><p>解决3：设置CMake让 CMake 把 dll 自动生成在 exe 同一目录</p>
<p>归根到底还是因为 CMake 把定义在顶层模块里的 main 放在 build&#x2F;main.exe。而 mylib 因为是定义在 mylib 这个子模块里的，因此被放到了 build&#x2F;mylib&#x2F;mylib.dll。所以，可以设置 mylib 的这些属性，让 mylib.dll 文件输出到 PROJECT_BINARY_DIR，也就是项目根目录（main 所在的位置）。这样 main.exe 在运行时就能找到 mylib.dll 了。</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_library</span>(mylib SHARED mylib.h mylib.cpp)</span><br><span class="line"><span class="keyword">set_property</span>(<span class="keyword">TARGET</span> mylib PROPERTY LIBRARY_OUTPUT_DIRECTORY <span class="variable">$&#123;PROJECT_BINARY_DIR&#125;</span>)</span><br><span class="line"><span class="keyword">set_property</span>(<span class="keyword">TARGET</span> mylib PROPERTY ARCHIVE_OUTPUT_DIRECTORY <span class="variable">$&#123;PROJECT_BINARY_DIR&#125;</span>)</span><br><span class="line"><span class="keyword">set_property</span>(<span class="keyword">TARGET</span> mylib PROPERTY RUNTIME_OUTPUT_DIRECTORY <span class="variable">$&#123;PROJECT_BINARY_DIR&#125;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">set_property</span>(<span class="keyword">TARGET</span> mylib PROPERTY LIBRARY_OUTPUT_DIRECTORY_DEBUG <span class="variable">$&#123;PROJECT_BINARY_DIR&#125;</span>)</span><br><span class="line"><span class="keyword">set_property</span>(<span class="keyword">TARGET</span> mylib PROPERTY ARCHIVE_OUTPUT_DIRECTORY_DEBUG <span class="variable">$&#123;PROJECT_BINARY_DIR&#125;</span>)</span><br><span class="line"><span class="keyword">set_property</span>(<span class="keyword">TARGET</span> mylib PROPERTY RUNTIME_OUTPUT_DIRECTORY_DEBUG <span class="variable">$&#123;PROJECT_BINARY_DIR&#125;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">set_property</span>(<span class="keyword">TARGET</span> mylib PROPERTY LIBRARY_OUTPUT_DIRECTORY_RELEASE <span class="variable">$&#123;PROJECT_BINARY_DIR&#125;</span>)</span><br><span class="line"><span class="keyword">set_property</span>(<span class="keyword">TARGET</span> mylib PROPERTY ARCHIVE_OUTPUT_DIRECTORY_RELEASE <span class="variable">$&#123;PROJECT_BINARY_DIR&#125;</span>)</span><br><span class="line"><span class="keyword">set_property</span>(<span class="keyword">TARGET</span> mylib PROPERTY RUNTIME_OUTPUT_DIRECTORY_RELEASE <span class="variable">$&#123;PROJECT_BINARY_DIR&#125;</span>)</span><br></pre></td></tr></table></figure></li>
</ul>
<p>所以在windows下使用动态链接库要设置6个属性，非常麻烦。而 Linux 系统支持 RPATH，CMake 会让生成出来可执行文件的 RPATH 字段指向他链接了的 .so 文件所在目录，运行时会优先从 RPATH 里找链接库，所以即使不在同目录也能找到。</p>
<p>需要手动修改或查看一个 ELF 文件的 RPATH，可以用 chrpath 或 patchelf 命令。</p>
<h2 id="对象的属性"><a href="#对象的属性" class="headerlink" title="对象的属性"></a>对象的属性</h2><p>许多 CMake 中的对象比如目标，目录和源文件都拥有属性。属性是一个特定对象所拥有的的键值对。访问属性最通用的方法是通过 <code>set_property</code>和 <code>get_property</code>命令。这些命令可以让你设置和获取一个 CMake 对象的属性。你可以查看 <code>cmake-properties</code>手册，其中列出了所有支持的属性。</p>
<h3 id="目标的一些选项"><a href="#目标的一些选项" class="headerlink" title="目标的一些选项"></a>目标的一些选项</h3><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#除了头文件搜索目录以外，还有这些选项，PUBLIC 和 PRIVATE 对他们同理：</span></span><br><span class="line"><span class="keyword">target_include_directories</span>(myapp PUBLIC /usr/<span class="keyword">include</span>/eigen3)  <span class="comment"># 添加头文件搜索目录</span></span><br><span class="line"><span class="keyword">target_link_libraries</span>(myapp PUBLIC hellolib)                               <span class="comment"># 添加要链接的库</span></span><br><span class="line">target_add_definitions(myapp PUBLIC MY_MACRO=<span class="number">1</span>)             <span class="comment"># 添加一个宏定义</span></span><br><span class="line">target_add_definitions(myapp PUBLIC -DMY_MACRO=<span class="number">1</span>)         <span class="comment"># 与 MY_MACRO=1 等价</span></span><br><span class="line"><span class="keyword">target_compile_options</span>(myapp PUBLIC -fopenmp)                     <span class="comment"># 添加编译器命令行选项</span></span><br><span class="line"><span class="keyword">target_sources</span>(myapp PUBLIC hello.cpp other.cpp)                    <span class="comment"># 添加要编译的源文件</span></span><br><span class="line"><span class="comment">#以及可以通过下列指令（不推荐使用），把选项加到所有接下来的目标去：</span></span><br><span class="line"><span class="keyword">include_directories</span>(/opt/cuda/<span class="keyword">include</span>)     <span class="comment"># 添加头文件搜索目录</span></span><br><span class="line"><span class="keyword">link_directories</span>(/opt/cuda)                       <span class="comment"># 添加库文件的搜索路径</span></span><br><span class="line"><span class="keyword">add_definitions</span>(MY_MACRO=<span class="number">1</span>)             <span class="comment"># 添加一个宏定义</span></span><br><span class="line"><span class="keyword">add_compile_options</span>(-fopenmp)             <span class="comment"># 添加编译器命令行选项</span></span><br></pre></td></tr></table></figure>

<h3 id="使用set-property设置属性"><a href="#使用set-property设置属性" class="headerlink" title="使用set_property设置属性"></a>使用set_property设置属性</h3><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#采用 C++17 标准进行编译（默认 11）</span></span><br><span class="line"><span class="keyword">set_property</span>(<span class="keyword">TARGET</span> main PROPERTY CXX_STANDARD <span class="number">17</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#如果编译器不支持 C++17，则直接报错（默认 OFF）</span></span><br><span class="line"><span class="keyword">set_property</span>(<span class="keyword">TARGET</span> main PROPERTY CXX_STANDARD_REQUIRED <span class="keyword">ON</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#在 Windows 系统中，运行时不启动控制台窗口，只有 GUI 界面（默认 OFF）</span></span><br><span class="line"><span class="keyword">set_property</span>(<span class="keyword">TARGET</span> main PROPERTY WIN32_EXECUTABLE <span class="keyword">ON</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#告诉编译器不要自动剔除没有引用符号的链接库（默认 OFF）</span></span><br><span class="line"><span class="keyword">set_property</span>(<span class="keyword">TARGET</span> main PROPERTY LINK_WHAT_YOU_USE <span class="keyword">ON</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#设置动态链接库的输出路径（默认 $&#123;CMAKE_BINARY_DIR&#125;）</span></span><br><span class="line"><span class="keyword">set_property</span>(<span class="keyword">TARGET</span> main PROPERTY LIBRARY_OUTPUT_DIRECTORY <span class="variable">$&#123;CMAKE_SOURCE_DIR&#125;</span>/lib)</span><br><span class="line"></span><br><span class="line"><span class="comment">#设置静态链接库的输出路径（默认 $&#123;CMAKE_BINARY_DIR&#125;）</span></span><br><span class="line"><span class="keyword">set_property</span>(<span class="keyword">TARGET</span> main PROPERTY ARCHIVE_OUTPUT_DIRECTORY <span class="variable">$&#123;CMAKE_SOURCE_DIR&#125;</span>/lib)</span><br><span class="line"></span><br><span class="line"><span class="comment">#设置可执行文件的输出路径（默认 $&#123;CMAKE_BINARY_DIR&#125;）</span></span><br><span class="line"><span class="keyword">set_property</span>(<span class="keyword">TARGET</span> main PROPERTY RUNTIME_OUTPUT_DIRECTORY <span class="variable">$&#123;CMAKE_SOURCE_DIR&#125;</span>/bin)</span><br></pre></td></tr></table></figure>

<h3 id="批量设置多个属性"><a href="#批量设置多个属性" class="headerlink" title="批量设置多个属性"></a>批量设置多个属性</h3><p>使用<code>set_target_properties</code>批量设置多个属性</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set_target_properties</span>(main PROPERTIES</span><br><span class="line">    CXX_STANDARD <span class="number">17</span>           <span class="comment"># 采用 C++17 标准进行编译（默认 11）</span></span><br><span class="line">    CXX_STANDARD_REQUIRED <span class="keyword">ON</span>  <span class="comment"># 如果编译器不支持 C++17，则直接报错（默认 OFF）</span></span><br><span class="line">    WIN32_EXECUTABLE <span class="keyword">ON</span>       <span class="comment"># 在 Windows 系统中，运行时不启动控制台窗口，只有 GUI 界面（默认 OFF）</span></span><br><span class="line">    LINK_WHAT_YOU_USE <span class="keyword">ON</span>      <span class="comment"># 告诉编译器不要自动剔除没有引用符号的链接库（默认 OFF）</span></span><br><span class="line">    LIBRARY_OUTPUT_DIRECTORY <span class="variable">$&#123;CMAKE_SOURCE_DIR&#125;</span>/lib   <span class="comment"># 设置动态链接库的输出路径（默认 $&#123;CMAKE_BINARY_DIR&#125;）</span></span><br><span class="line">    ARCHIVE_OUTPUT_DIRECTORY <span class="variable">$&#123;CMAKE_SOURCE_DIR&#125;</span>/lib   <span class="comment"># 设置静态链接库的输出路径（默认 $&#123;CMAKE_BINARY_DIR&#125;）</span></span><br><span class="line">    RUNTIME_OUTPUT_DIRECTORY <span class="variable">$&#123;CMAKE_SOURCE_DIR&#125;</span>/bin   <span class="comment"># 设置可执行文件的输出路径（默认 $&#123;CMAKE_BINARY_DIR&#125;）</span></span><br><span class="line">    )</span><br></pre></td></tr></table></figure>

<h3 id="设置变量和设置属性的区别"><a href="#设置变量和设置属性的区别" class="headerlink" title="设置变量和设置属性的区别"></a>设置变量和设置属性的区别</h3><p>通过set设置的变量全局有效，会让之后创建的所有对象都享有同样的属性；而set_property只对单个对象有效。</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#相当于改变了各个属性的初始默认值。要注意此时 set(CMAKE_xxx) 必须在 add_executable 之前才有效。</span></span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD <span class="number">17</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD_REQUIRED <span class="keyword">ON</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>(CMAKE_WIN32_EXECUTABLE <span class="keyword">ON</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>(CMAKE_LINK_WHAT_YOU_USE <span class="keyword">ON</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>(CMAKE_LIBRARY_OUTPUT_DIRECTORY <span class="variable">$&#123;CMAKE_SOURCE_DIR&#125;</span>/lib)</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>(CMAKE_ARCHIVE_OUTPUT_DIRECTORY <span class="variable">$&#123;CMAKE_SOURCE_DIR&#125;</span>/lib)</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>(CMAKE_RUNTIME_OUTPUT_DIRECTORY <span class="variable">$&#123;CMAKE_SOURCE_DIR&#125;</span>/bin)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_executable</span>(main main.cpp)</span><br></pre></td></tr></table></figure>

<p>注意使用set时记得加引号，否则用空格隔开的会变成分号分割的列表，这可能会造成严重的后果(如在message中列表中的字符串可能视为message的关键字)</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span>(myvar hello world)</span><br><span class="line"><span class="comment">#其实等价于：</span></span><br><span class="line"><span class="keyword">set</span>(myvar “hello;world”)</span><br><span class="line"></span><br><span class="line"><span class="comment">#正确的写法</span></span><br><span class="line"><span class="keyword">set</span>(myvar <span class="string">&quot;hello world&quot;</span>)</span><br></pre></td></tr></table></figure>

<h2 id="链接第三方库"><a href="#链接第三方库" class="headerlink" title="链接第三方库"></a>链接第三方库</h2><p>以使用tbb库为例</p>
<h3 id="直接链接"><a href="#直接链接" class="headerlink" title="直接链接"></a>直接链接</h3><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_executable</span>(main main.cpp)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(main PUBLIC tbb)</span><br></pre></td></tr></table></figure>

<p>如果这样直接指定 tbb，CMake 会让链接器在<strong>系统的库目录</strong>里查找 tbb，他会找到 &#x2F;usr&#x2F;lib&#x2F;libtbb.so 这个系统自带的，但这<strong>对于没有一个固定库安装位置的 Windows 系统并不适用</strong>。</p>
<p>此外，他还要求 tbb 的头文件就在 &#x2F;usr&#x2F;include 这个系统默认的头文件目录，这样才能 #include &lt;tbb&#x2F;parallel_for.h&gt; 不出错，<strong>如果 tbb 的头文件在其他地方就需要再加一个 target_include_directories</strong> 设置额外的头文件查找目录。</p>
<h3 id="写出完整路径"><a href="#写出完整路径" class="headerlink" title="写出完整路径"></a>写出完整路径</h3><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_executable</span>(main main.cpp)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(main PUBLIC c:/Users/archibate/installed/tbb/tbb.dll)</span><br></pre></td></tr></table></figure>

<p>也可以直接写出全部路径，这样也可以让没有默认系统路径的 Windows 找到安装在奇怪位置的 tbb……不过这样根本不跨平台，你这样改了别人如果装在不同地方就出错了。(<strong>不推荐</strong>)</p>
<p>顺便一提，**CMake 的路径分割符始终是 &#x2F;。即使在 Windows 上，也要把所有的 \ 改成 &#x2F;**，这是出于跨平台的考虑。请放心，CMake 会自动在调用 MSVC 的时候转换成 \，你可以放心的用 ${x}&#x2F;bin 来实现和 Python 的 os.path.join(x, ‘bin’) 一样的效果。</p>
<h3 id="使用find-package"><a href="#使用find-package" class="headerlink" title="使用find_package"></a><strong>使用find_package</strong></h3><p>更好的做法是用 CMake 的 find_package 命令。</p>
<p>find_package(TBB REQUIRED) 会查找 &#x2F;usr&#x2F;lib&#x2F;cmake&#x2F;TBB&#x2F;TBBConfig.cmake 这个配置文件，并根据里面的配置信息创建 TBB::tbb 这个伪对象（他实际指向真正的 tbb 库文件路径 &#x2F;usr&#x2F;lib&#x2F;libtbb.so），之后通过 target_link_libraries 链接 TBB::tbb 就可以正常工作了。</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_executable</span>(main main.cpp)</span><br><span class="line"></span><br><span class="line"><span class="keyword">find_package</span>(TBB REQUIRED)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(main PUBLIC TBB::tbb)</span><br></pre></td></tr></table></figure>

<p>TBB::tbb 是一个伪对象(imported)，除了他会指向 &#x2F;usr&#x2F;lib&#x2F;libtbb.so 之外，TBBConfig.cmake 还会给 TBB::tbb 添加一些 PUBLIC 属性，用于让链接了他的对象带上一些 flag 之类的。</p>
<p>比如，TBB 安装在 &#x2F;opt&#x2F;tbb 目录下，头文件在 &#x2F;opt&#x2F;tbb&#x2F;include 里，那么这时 TBBConfig.cmake 里就会有：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">target_include_directories</span>(TBB::tbb PUBLIC /opt/tbb/<span class="keyword">include</span>)</span><br></pre></td></tr></table></figure>

<p>这样 main 在链接了 TBB::tbb 的时候也会被“传染”上 &#x2F;opt&#x2F;tbb&#x2F;include 这个目录，不用调用者手动添加了。再比如，TBB::tbb 链接了另一个库 Blosc::blosc，那这个库也会自动链接到 main 上，无需调用者手动添加。</p>
<p>比如 spdlog 的 spdlog-config.cmake 就会定义 SPDLOG_NOT_HEADER_ONLY 这个宏为 PUBLIC。从而实现直接 #include &lt;spdlog&#x2F;spdlog.h&gt; 时候是纯头文件，而 find_package(spdlog REQUIRED) 时却变成预编译链接库的版本。（其实不是 PUBLIC 而是 INTERFACE，因为伪对象没有实体）</p>
<p><strong>TBBConfig.cmake 这个配置文件的由来</strong></p>
<p>不论是 TBBConfig.cmake 还是 FindTBB.cmake，这个文件通常由库的作者提供，在 Linux 的包管理器安装 tbb 后也会自动安装这个文件。<strong>少部分对 CMake 不友好的第三方库，需要自己写FindXXX.cmake 才能使用。</strong></p>
<p>一些老年项目作者喜欢在项目里自己塞几个 FindXXX.cmake，然而版本可能和系统里的不一样，比如用 3.0 的 finder 去找 2.0 的包，容易出现一些奇奇怪怪的错误。<strong>不建议大家这样用自己创建一个 cmake&#x2F; 目录来存用到的所有库的 finder</strong>，尽量用系统自带的，可以保证用的是系统自带库的那个配置。</p>
<p><strong>和find_package(TBB CONFIG REQUIRED)的区别</strong> </p>
<p>通过 find_package(TBB CONFIG REQUIRED)，添加了一个 CONFIG 选项。这样他会优先查找 TBBConfig.cmake（系统自带的）而不是 FindTBB.cmake（项目作者常把他塞在 cmake&#x2F; 目录里并添加到 CMAKE_MODULE_PATH）。这样能保证寻找包的这个 .cmake 脚本是和系统自带的 tbb 版本是适配的，而不是项目作者当年下载的那个版本的 .cmake 脚本。</p>
<p>当然，如果你坚持要用 find_package(TBB REQUIRED) 也是可以的。</p>
<p>没有 CONFIG 选项：先找 FindTBB.cmake，再找 TBBConfig.cmake，找不到则报错</p>
<p><strong>有 CONFIG 选项：只会找 TBBConfig.cmake，找不到则报错</strong></p>
<p>此外，一些老年项目（例如 OpenVDB）只提供 Find 而没有 Config 文件，这时候就必须用 find_package(OpenVDB REQUIRED) 而不能带 CONFIG 选项。</p>
<p><strong>find_package()不加REQUIRED</strong></p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_executable</span>(main main.cpp)</span><br><span class="line"></span><br><span class="line"><span class="keyword">find_package</span>(TBB)</span><br><span class="line"><span class="comment">#TBB_FOUND也可以换成TARGET TBB:tbb。还可以复合操作例如NOT TARGET TBB::tbb AND TARGET Eigen3::eigen表示找得到 TBB 但是找不到 Eigen3 的情况</span></span><br><span class="line"><span class="keyword">if</span> (TBB_FOUND)</span><br><span class="line">    <span class="keyword">message</span>(STATUS <span class="string">&quot;TBB found at: $&#123;TBB_DIR&#125;&quot;</span>)</span><br><span class="line">    <span class="keyword">target_link_libraries</span>(main PUBLIC TBB::tbb)</span><br><span class="line">    <span class="keyword">target_compile_definitions</span>(main PUBLIC WITH_TBB) <span class="comment">#在可执行程序中定义 WITH_TBB 宏</span></span><br><span class="line"><span class="keyword">else</span>()</span><br><span class="line">    <span class="keyword">message</span>(WARNING <span class="string">&quot;TBB not found! using serial for&quot;</span>)</span><br><span class="line"><span class="keyword">endif</span>()</span><br></pre></td></tr></table></figure>

<p>如果没有 REQUIRED 选项，找不到时将不会报错。只会设置 xx_FOUND 变量为flase，这样可以根据这个变量的值进行一些处理。如上</p>
<p>找到了会把 TBB_FOUND 设为 TRUE，TBB_DIR 设为 TBBConfig.cmake 所在路径。</p>
<p>找不到会把 TBB_FOUND 设为 FALSE，TBB_DIR 为空。</p>
<p>这里我们在找到 TBB 时定义 WITH_TBB 宏，稍后 .cpp 里就可以根据有没有宏进行判断，在有宏和没宏时分别进行不同的处理。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> WITH_TBB</span></span><br><span class="line"><span class="comment">//进行找到TBB库时的操作</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> WITH_TBB</span></span><br><span class="line"><span class="comment">//进行没找到库时的操作</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<h3 id="指定find-package的组件"><a href="#指定find-package的组件" class="headerlink" title="指定find_package的组件"></a>指定find_package的组件</h3><p>有多个组件的库直接find_package会出错(如Qt5)，此时需要指定用到的组件。</p>
<p>find_package 生成的伪对象(imported target)都按照“包名::组件名”的格式命名。你可以在 find_package 中通过 COMPONENTS 选项，后面跟随一个列表表示需要用的组件。</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">2.10</span>)</span><br><span class="line"><span class="keyword">project</span>(hellocmake CXX)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_executable</span>(main main.cpp)</span><br><span class="line"></span><br><span class="line"><span class="keyword">find_package</span>(TBB COMPONENTS tbb tbbmalloc tbbmalloc_proxy REQUIRED)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(main PUBLIC TBB::tbb TBB::tbbmalloc TBB::tbbmalloc_proxy)</span><br></pre></td></tr></table></figure>

<h3 id="在windows上找包"><a href="#在windows上找包" class="headerlink" title="在windows上找包"></a>在windows上找包</h3><p>Windows没有固定的安装路径，假设你的 Qt5 安装在 C:\Qt\Qt5.14.2，则你去找找这个目录：C:\Qt\Qt5.14.2\msvc2019_64\lib\cmake\</p>
<p>你会看到里面有个 Qt5Config.cmake 。现在，有四种方法让 CMake 找得到他。</p>
<p>1.第一种是设置 CMAKE_MODULE_PATH 变量，添加一下包含 Qt5Config.cmake 这个文件的目录路径 </p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_executable</span>(main main.cpp)</span><br><span class="line"></span><br><span class="line"><span class="keyword">find_package</span>(TBB REQUIRED)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(main PUBLIC TBB::tbb)</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>(CMAKE_MODULE_PATH <span class="variable">$&#123;CMAKE_MODULE_PATH&#125;</span> C:/Qt/Qt5.<span class="number">14.2</span>/msvc2019_64/lib/cmake)</span><br><span class="line"></span><br><span class="line"><span class="keyword">find_package</span>(Qt5 REQUIRED COMPONENTS Widgets Gui REQUIRED)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(main PUBLIC Qt5::Widgets Qt5::Gui)</span><br></pre></td></tr></table></figure>

<p>2.第二种是设置 Qt5_DIR 这个变量为 C:\Qt\Qt5.14.2\msvc2019_64\lib\cmake。这样只有 Qt5 这个包会去这个目录里搜索 Qt5Config.cmake，更有针对性。</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_executable</span>(main main.cpp)</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>(Qt5_DIR C:/Qt/Qt5.<span class="number">14.2</span>/msvc2019_64/lib/cmake)</span><br><span class="line"></span><br><span class="line"><span class="keyword">find_package</span>(Qt5 REQUIRED COMPONENTS Widgets Gui REQUIRED)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(main PUBLIC Qt5::Widgets Qt5::Gui)</span><br></pre></td></tr></table></figure>

<p>3.**第三种(推荐)**，直接在命令行通过 -DQt5_DIR&#x3D;”xxx” 指定，这样不用修改 CMakeLists.txt。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmake -B build -DQt5_DIR=&quot;C:/Qt/Qt5.14.2/msvc2019_64/lib/cmake&quot; </span><br></pre></td></tr></table></figure>

<p>4.第四种，通过设置环境变量 Qt5_DIR 也是可以的，但是对 Windows 用户设置环境变量比较麻烦。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export Qt5_DIR=&quot;C:/Qt/Qt5.14.2/msvc2019_64/lib/cmake&quot; </span><br><span class="line">cmake -B build</span><br></pre></td></tr></table></figure>

<h2 id="输出和变量"><a href="#输出和变量" class="headerlink" title="输出和变量"></a>输出和变量</h2><p>使用message在运行 <strong>cmake -B build</strong> 时打印字符串（用于调试）</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">message</span>(<span class="string">&quot;Hello, world!&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#输出如下</span></span><br><span class="line">Hello, world!</span><br></pre></td></tr></table></figure>

<p>message(STATUS “…”) 表示信息类型是状态信息，打印出来有 <strong>–</strong> 前缀</p>
<p>message(WARNING “…”) 表示是警告信息</p>
<p>message(AUTHOR_WARNING “…”)表示是仅仅给项目作者看的警告信息</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">message</span>(STATUS <span class="string">&quot;Hello, world!&quot;</span>)</span><br><span class="line"><span class="keyword">message</span>(WARNING <span class="string">&quot;This is a warning sign!&quot;</span>)</span><br><span class="line"><span class="keyword">message</span>(AUTHOR_WARNING <span class="string">&quot;This is a warning sign for author!&quot;</span>)</span><br><span class="line"><span class="comment">#输出如下</span></span><br><span class="line">--Hello, world!</span><br><span class="line"></span><br><span class="line"><span class="comment">#waring的颜色不同,不是普通的白色</span></span><br><span class="line">CMake Warning at CMakeList.txt:<span class="number">2</span> (<span class="keyword">message</span>):</span><br><span class="line">This is a warning sign!</span><br><span class="line"></span><br><span class="line"><span class="comment">#AUTHOR_WARNING 的不同之处：可以通过 -Wno-dev 关闭，在命令行加上即可cmake -B build -Wno-dev</span></span><br><span class="line">CMake Warning at CMakeList.txt:<span class="number">3</span> (<span class="keyword">message</span>):</span><br><span class="line">This is a warning sign for author!</span><br></pre></td></tr></table></figure>

<p>message(FATAL_ERROR “…”) 表示是错误信息，会终止 CMake 的运行</p>
<p>message(SEND_ERROR “…”) 表示是错误信息，但会继续运行</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">message</span>(STATUS <span class="string">&quot;Hello, world!&quot;</span>)</span><br><span class="line"><span class="keyword">message</span>(FATAL_ERROR <span class="string">&quot;This is an error message!&quot;</span>)</span><br><span class="line"><span class="keyword">message</span>(STATUS <span class="string">&quot;After error...&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#输出</span></span><br><span class="line">--Hello, world!</span><br><span class="line">CMake Error at CMakeList.txt:<span class="number">2</span> (<span class="keyword">message</span>):</span><br><span class="line">This is an error <span class="keyword">message</span>!</span><br><span class="line"><span class="comment">#注意后续After error...不会再打印，因为终止运行了，若是SEND_ERROR则会继续运行</span></span><br></pre></td></tr></table></figure>

<p>message还可以打印变量的值</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span>(myvar hello world)</span><br><span class="line"><span class="keyword">message</span>(<span class="string">&quot;myvar is: $&#123;myvar&#125;&quot;</span>)</span><br></pre></td></tr></table></figure>

<h2 id="变量和缓存"><a href="#变量和缓存" class="headerlink" title="变量和缓存"></a>变量和缓存</h2><p>重复执行 <strong>cmake -B build</strong> 会发现第二次执行要快很多。</p>
<p>这是因为 CMake 第一遍需要检测编译器和 C++ 特性等比较耗时，检测完会把结果存储到缓存中，这样第二遍运行cmake -B build 时就可以直接用缓存的值，就不需要再检测一遍了。</p>
<p>find_package 就用到了缓存机制。变量缓存的意义在于能够把 find_package 找到的库文件位置等信息，储存起来。这样下次执行 find_package 时，就会利用上次缓存的变量，直接返回。避免重复执行 cmake -B 时速度变慢的问题。</p>
<p>然而有时候外部的情况有所更新(如变量改动)，这时候 CMake 里缓存的却是旧的值，会导致一系列问题。缓存是很多 CMake 出错的根源，因此如果出现诡异的错误，可以试试清除缓存。</p>
<h3 id="清除缓存的方法"><a href="#清除缓存的方法" class="headerlink" title="清除缓存的方法"></a>清除缓存的方法</h3><p>1.最简单的办法就是删除 build 文件夹，然后重新运行 cmake -B build。经典 CMake 笑话：”99%的cmake错误可以用删build解决”。</p>
<p>2.删除 build&#x2F;CMakeCache.txt 。删 build 虽然彻底，也会导致编译的中间结果（.o文件）都没了，重新编译要花费很长时间。如果只想清除缓存，不想从头重新编译，可以只删除 build&#x2F;CMakeCache.txt 这个文件。这文件里面装的就是缓存的变量，删了他就可以让 CMake 强制重新检测一遍所有库和编译器。</p>
<h3 id="设置缓存变量"><a href="#设置缓存变量" class="headerlink" title="设置缓存变量"></a>设置缓存变量</h3><p>set(变量名 “变量值” CACHE 变量类型 “注释”)可以设置缓存变量。这样变量的值就会在build&#x2F;CMakeCache.txt中缓存。</p>
<p>缓存变量有以下类型：</p>
<ul>
<li>STRING 字符串，例如 “hello, world”</li>
<li>FILEPATH 文件路径，例如 “C:&#x2F;vcpkg&#x2F;scripts&#x2F;buildsystems&#x2F;vcpkg.cmake”</li>
<li>PATH 目录路径，例如 “C:&#x2F;Qt&#x2F;Qt5.14.2&#x2F;msvc2019_64&#x2F;lib&#x2F;cmake&#x2F;”</li>
<li>BOOL 布尔值，只有两个取值：ON 或 OFF。</li>
</ul>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.15</span>)</span><br><span class="line"><span class="keyword">project</span>(hellocmake LANGUAGES CXX)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_executable</span>(main main.cpp)</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>(myvar <span class="string">&quot;hello&quot;</span> CACHE <span class="keyword">STRING</span> <span class="string">&quot;this is the docstring.&quot;</span>)</span><br><span class="line"><span class="keyword">message</span>(<span class="string">&quot;myvar is: $&#123;myvar&#125;&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>缓存bool变量的例子，设置WITH_TBB变量控制是否链接这个库。CMake 对 BOOL 类型缓存的 set 指令提供了一个简写：option</p>
<p>option(变量名 “描述” 变量值) 等价于：set(变量名 CACHE BOOL 变量值 “描述”)</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.15</span>)</span><br><span class="line"><span class="keyword">project</span>(hellocmake LANGUAGES CXX)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_executable</span>(main main.cpp)</span><br><span class="line"></span><br><span class="line"><span class="comment">#等价于option(WITH_TBB &quot;set to ON to enable TBB, OFF to disable TBB.&quot; ON)</span></span><br><span class="line"><span class="keyword">set</span>(WITH_TBB <span class="keyword">ON</span> CACHE BOOL <span class="string">&quot;set to ON to enable TBB, OFF to disable TBB.&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (WITH_TBB)</span><br><span class="line">    <span class="keyword">target_compile_definitions</span>(main PUBLIC WITH_TBB)</span><br><span class="line">    <span class="keyword">find_package</span>(TBB REQUIRED)</span><br><span class="line">    <span class="keyword">target_link_libraries</span>(main PUBLIC TBB::tbb)</span><br><span class="line"><span class="keyword">endif</span>()</span><br></pre></td></tr></table></figure>

<h3 id="更新缓存变量"><a href="#更新缓存变量" class="headerlink" title="更新缓存变量"></a>更新缓存变量</h3><p>1.直接在CMakeList.txt中更新，然后使用上述清除缓存的方法删除缓存。</p>
<p>2.通过命令行参数，在cmake -B时指定变量的值，如更改myvar变量的值：cmake -B build -Dmyvar&#x3D;world</p>
<p>3.命令行参数太麻烦，直接可视化编辑变量的值(推荐)</p>
<p>在 Linux 中，可以运行 ccmake -B build 来启动基于终端的可视化缓存编辑菜单。</p>
<p>在 Windows 则可以 cmake-gui -B build 来启动图形界面编辑各个缓存选项。</p>
<p>当然，直接用编辑器打开 build&#x2F;CMakeCache.txt 修改后保存也是可以的。</p>
<p>4.set 可以在后面加一个 FORCE 选项，表示不论缓存是否存在，都强制更新缓存。不过这样会导致没办法用 -Dmyvar&#x3D;othervalue 来更新缓存变量。set(myvar “hello” CACHE STRING “this is the docstring.” FORCE)</p>
<h2 id="跨平台与编译器"><a href="#跨平台与编译器" class="headerlink" title="跨平台与编译器"></a>跨平台与编译器</h2><h3 id="检测操作系统和编译器"><a href="#检测操作系统和编译器" class="headerlink" title="检测操作系统和编译器"></a>检测操作系统和编译器</h3><p><strong>检测操作系统</strong></p>
<p>CMAKE_SYSTEM_NAME变量指示主机操作系统，根据不同的操作系统定义不同的宏</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_executable</span>(main)</span><br><span class="line"><span class="keyword">file</span>(GLOB sources CONFIGURE_DEPENDS *.cpp *.h)</span><br><span class="line"><span class="keyword">target_sources</span>(main PUBLIC <span class="variable">$&#123;sources&#125;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (CMAKE_SYSTEM_NAME <span class="keyword">MATCHES</span> <span class="string">&quot;Windows&quot;</span>)</span><br><span class="line">    <span class="keyword">target_compile_definitions</span>(main PUBLIC MY_NAME=<span class="string">&quot;Bill Gates&quot;</span>)</span><br><span class="line"><span class="keyword">elseif</span> (CMAKE_SYSTEM_NAME <span class="keyword">MATCHES</span> <span class="string">&quot;Linux&quot;</span>)</span><br><span class="line">    <span class="keyword">target_compile_definitions</span>(main PUBLIC MY_NAME=<span class="string">&quot;Linus Torvalds&quot;</span>)</span><br><span class="line"><span class="keyword">elseif</span> (CMAKE_SYSTEM_NAME <span class="keyword">MATCHES</span> <span class="string">&quot;Darwin&quot;</span>)</span><br><span class="line">    <span class="keyword">target_compile_definitions</span>(main PUBLIC MY_NAME=<span class="string">&quot;Steve Jobs&quot;</span>)</span><br><span class="line"><span class="keyword">endif</span>()</span><br></pre></td></tr></table></figure>

<p>CMake还提供了一些简写变量：WIN32, APPLE, UNIX, ANDROID, IOS等</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_executable</span>(main)</span><br><span class="line"><span class="keyword">file</span>(GLOB sources CONFIGURE_DEPENDS *.cpp *.h)</span><br><span class="line"><span class="keyword">target_sources</span>(main PUBLIC <span class="variable">$&#123;sources&#125;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (WIN32)</span><br><span class="line">    <span class="keyword">target_compile_definitions</span>(main PUBLIC MY_NAME=<span class="string">&quot;Bill Gates&quot;</span>)</span><br><span class="line"><span class="keyword">elseif</span> (UNIX <span class="keyword">AND</span> <span class="keyword">NOT</span> APPLE)</span><br><span class="line">    <span class="keyword">target_compile_definitions</span>(main PUBLIC MY_NAME=<span class="string">&quot;Linus Torvalds&quot;</span>)</span><br><span class="line"><span class="keyword">elseif</span> (APPLE)</span><br><span class="line">    <span class="keyword">target_compile_definitions</span>(main PUBLIC MY_NAME=<span class="string">&quot;Steve Jobs&quot;</span>)</span><br><span class="line"><span class="keyword">endif</span>()</span><br></pre></td></tr></table></figure>

<p><strong>检测编译器</strong></p>
<p>CMAKE_CXX_COMPILER_ID变量指示编译器，根据不同的编译器定义不同的宏。可以设置这个变量的值来指定使用编译器(修改环境变量或设置配置变量)。</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_executable</span>(main)</span><br><span class="line"><span class="keyword">file</span>(GLOB sources CONFIGURE_DEPENDS *.cpp *.h)</span><br><span class="line"><span class="keyword">target_sources</span>(main PUBLIC <span class="variable">$&#123;sources&#125;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (CMAKE_CXX_COMPILER_ID <span class="keyword">MATCHES</span> <span class="string">&quot;GNU&quot;</span>)</span><br><span class="line">    <span class="keyword">target_compile_definitions</span>(main PUBLIC MY_NAME=<span class="string">&quot;gcc&quot;</span>)</span><br><span class="line"><span class="keyword">elseif</span> (CMAKE_CXX_COMPILER_ID <span class="keyword">MATCHES</span> <span class="string">&quot;NVIDIA&quot;</span>)</span><br><span class="line">    <span class="keyword">target_compile_definitions</span>(main PUBLIC MY_NAME=<span class="string">&quot;nvcc&quot;</span>)</span><br><span class="line"><span class="keyword">elseif</span> (CMAKE_CXX_COMPILER_ID <span class="keyword">MATCHES</span> <span class="string">&quot;Clang&quot;</span>)</span><br><span class="line">    <span class="keyword">target_compile_definitions</span>(main PUBLIC MY_NAME=<span class="string">&quot;clang&quot;</span>)</span><br><span class="line"><span class="keyword">elseif</span> (CMAKE_CXX_COMPILER_ID <span class="keyword">MATCHES</span> <span class="string">&quot;MSVC&quot;</span>)</span><br><span class="line">    <span class="keyword">target_compile_definitions</span>(main PUBLIC MY_NAME=<span class="string">&quot;msvc&quot;</span>)</span><br><span class="line"><span class="keyword">endif</span>()</span><br></pre></td></tr></table></figure>

<p>CMake 还提供了一些简写变量：MSVC, CMAKE_COMPILER_IS_GNUCC</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (MSVC)</span><br><span class="line">    <span class="keyword">target_compile_definitions</span>(main PUBLIC MY_NAME=<span class="string">&quot;MSVC&quot;</span>)</span><br><span class="line"><span class="keyword">elseif</span> (CMAKE_COMPILER_IS_GNUCC)</span><br><span class="line">    <span class="keyword">target_compile_definitions</span>(main PUBLIC MY_NAME=<span class="string">&quot;GCC&quot;</span>)</span><br><span class="line"><span class="keyword">else</span> ()</span><br><span class="line">    <span class="keyword">target_compile_definitions</span>(main PUBLIC MY_NAME=<span class="string">&quot;other compiler&quot;</span>)</span><br><span class="line"><span class="keyword">endif</span>()</span><br></pre></td></tr></table></figure>

<h3 id="使用生成器表达式简化操作"><a href="#使用生成器表达式简化操作" class="headerlink" title="使用生成器表达式简化操作"></a>使用生成器表达式简化操作</h3><p>语法：<code>$&lt;$&lt;类型:值&gt;:为真时的表达式&gt;</code></p>
<p>比如 <code>$&lt;$&lt;PLATFORM_ID:Windows&gt;:MY_NAME=”Bill Gates”&gt;</code></p>
<p>如果平台为WINDOWS，字符串会变为 MY_NAME&#x3D;”Bill Gates”</p>
<p>其他平台上则表现为空字符串</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_executable</span>(main)</span><br><span class="line"><span class="keyword">file</span>(GLOB sources CONFIGURE_DEPENDS *.cpp *.h)</span><br><span class="line"><span class="keyword">target_sources</span>(main PUBLIC <span class="variable">$&#123;sources&#125;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">target_compile_definitions</span>(main PUBLIC</span><br><span class="line">    $&lt;$&lt;PLATFORM_ID:Windows&gt;:MY_NAME=<span class="string">&quot;Bill Gates&quot;</span>&gt;</span><br><span class="line">    $&lt;$&lt;PLATFORM_ID:Linux&gt;:MY_NAME=<span class="string">&quot;Linus Torvalds&quot;</span>&gt;</span><br><span class="line">    $&lt;$&lt;PLATFORM_ID:Darwin&gt;:MY_NAME=<span class="string">&quot;Steve Jobs&quot;</span>&gt;</span><br><span class="line">    )</span><br></pre></td></tr></table></figure>

<p>生成器表达式要匹配多个类型的值时，可以用逗号分割</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_executable</span>(main)</span><br><span class="line"><span class="keyword">file</span>(GLOB sources CONFIGURE_DEPENDS *.cpp *.h)</span><br><span class="line"><span class="keyword">target_sources</span>(main PUBLIC <span class="variable">$&#123;sources&#125;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">target_compile_definitions</span>(main PUBLIC</span><br><span class="line">    $&lt;$&lt;PLATFORM_ID:Windows&gt;:MY_NAME=<span class="string">&quot;DOS-like&quot;</span>&gt;</span><br><span class="line">    $&lt;$&lt;PLATFORM_ID:Linux,Darwin,FreeBSD&gt;:MY_NAME=<span class="string">&quot;Unix-like&quot;</span>&gt;</span><br><span class="line">    )</span><br></pre></td></tr></table></figure>

<h2 id="分支和判断"><a href="#分支和判断" class="headerlink" title="分支和判断"></a>分支和判断</h2><p>通常来说 BOOL 类型的变量只有 ON&#x2F;OFF 两种取值。但是由于历史原因，TRUE&#x2F;FALSE 和 YES&#x2F;NO 也可以表示 BOOL 类型。</p>
<p>if 的特点：**不要给if中的变量加 ${}**，CMake会自动把没加引号的字符串当作变量名求值</p>
<p>由于历史原因，if 的括号中有着特殊的语法，如果是一个字符串，比如 MYVAR，则他会先看是否有 ${MYVAR} 这个变量。如果有这个变量则会被替换为变量的值来进行接下来的比较，否则保持原来字符串不变。</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.15</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD <span class="number">17</span>)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD_REQUIRED <span class="keyword">ON</span>)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_EXTENSIONS <span class="keyword">ON</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">project</span>(hellocmake LANGUAGES C CXX)</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>(MYVAR <span class="keyword">OFF</span>)</span><br><span class="line"><span class="keyword">if</span> (MYVAR)</span><br><span class="line">    <span class="keyword">message</span>(<span class="string">&quot;MYVAR is true&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>()</span><br><span class="line">    <span class="keyword">message</span>(<span class="string">&quot;MYVAR is false&quot;</span>)</span><br><span class="line"><span class="keyword">endif</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_executable</span>(main main.cpp)</span><br></pre></td></tr></table></figure>

<p>如果加了${} ，if (${MYVAR} MATCHES “Hello”) 会被翻译成 if (Hello MATCHES “Hello”)，但是因为找不到名为 Hello 的变量，所以会被直接当成普通的字符串来处理。也就是 if (“Hello” MATCHES “Hello”) 从而会执行真分支，结果正常。</p>
<p>但是如果定义了Hello的变量，那么就会出错，所以不要给变量加${}。</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span>(Hello <span class="string">&quot;world&quot;</span>)</span><br><span class="line"><span class="keyword">set</span>(MYVAR Hello)</span><br><span class="line"><span class="keyword">if</span> (<span class="variable">$&#123;MYVAR&#125;</span> <span class="keyword">MATCHES</span> <span class="string">&quot;Hello&quot;</span>)</span><br><span class="line">    <span class="keyword">message</span>(<span class="string">&quot;MYVAR is Hello&quot;</span>) <span class="comment">#$&#123;MYVAR&#125;会被替换成world，所以不会执行这条语句</span></span><br><span class="line"><span class="keyword">else</span>()</span><br><span class="line">    <span class="keyword">message</span>(<span class="string">&quot;MYVAR is not Hello&quot;</span>) <span class="comment">#执行</span></span><br><span class="line"><span class="keyword">endif</span>()</span><br></pre></td></tr></table></figure>

<p>初学者如果搞不明白，可以把所有不确定的地方都套上一层引号，例如”${MYVAR}”，这样就可以避免被 if 当做变量名来求值了。</p>
<h2 id="变量与作用域"><a href="#变量与作用域" class="headerlink" title="变量与作用域"></a>变量与作用域</h2><h3 id="变量的作用域"><a href="#变量的作用域" class="headerlink" title="变量的作用域"></a>变量的作用域</h3><p>变量分为普通变量，缓存变量，环境变量。普通变量有着作用域，而<strong>缓存变量和环境变量是不论父子模块都共用的，没有作用域一说。</strong></p>
<p>普通变量的传播规则：父模块会传给子模块， 子模块不传给父模块(也就是父模块变量在子模块可见，子模块变量在父不可见)</p>
<p>如果子模块需要向父模块传变量，可以用 set 的 PARENT_SCOPE 选项，把一个变量传递到上一层作用域（也就是父模块）。</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#子模块</span></span><br><span class="line"><span class="keyword">set</span>(MYVAR <span class="keyword">ON</span> PARENT_SCOPE)</span><br><span class="line"></span><br><span class="line"><span class="comment">#父模块</span></span><br><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.15</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>(MYVAR <span class="keyword">OFF</span>)</span><br><span class="line"><span class="keyword">add_subdirectory</span>(mylib) <span class="comment">#这条语句之后，变量MYVAR被子模块修改为ON</span></span><br><span class="line"><span class="keyword">message</span>(<span class="string">&quot;MYVAR: $&#123;MYVAR&#125;&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_executable</span>(main main.cpp)</span><br></pre></td></tr></table></figure>

<p>如果父模块里没有定义 MYVAR 的话，也可以在子模块中设置缓存变量向外部传变量（不推荐）。但是这样就不光父模块可见了，父模块的父模块，到处都可见。</p>
<p><strong>除了父子模块之外还有哪些是带独立作用域的</strong></p>
<ul>
<li>include 的 XXX.cmake <strong>没有</strong>独立作用域</li>
<li>add_subdirectory 的 CMakeLists.txt <strong>有</strong>独立作用域</li>
<li>macro <strong>没有</strong>独立作用域</li>
<li>function <strong>有</strong>独立作用域（因此 PARENT_SCORE 也可以用于 function 的返回值）</li>
</ul>
<h3 id="访问变量"><a href="#访问变量" class="headerlink" title="访问变量"></a>访问变量</h3><p><strong>环境变量的访问方式：$ENV{xx}</strong></p>
<p>用 ${xx} 访问的是局部变量，局部变量服从刚刚所说的父子模块传播规则。而还有一种特殊的方式可以访问到系统的环境变量（environment variable）：$ENV{xx}。比如 $ENV{PATH} 就是获取 PATH 这个环境变量的值。</p>
<p><strong>缓存变量的访问方式：$CACHE{xx}</strong></p>
<p>此外，还可以用 $CACHE{xx} 来访问缓存里的 xx 变量。</p>
<p><strong>${xx}</strong> <strong>找不到局部变量时，会自动去找缓存变量</strong></p>
<p>${xx} 当找不到名为 xx 的局部变量时，就会去在缓存里查找名为 xx 的缓存变量。因此很多变量虽然在代码里没被 set，但是他被-D参数固定在缓存里了，所以依然可以找到。</p>
<h3 id="判断变量是否存在"><a href="#判断变量是否存在" class="headerlink" title="判断变量是否存在"></a>判断变量是否存在</h3><p><strong>if (DEFINED xx)</strong> <strong>判断某变量是否存在</strong></p>
<p>if (DEFINED MYVAR) 可以判断是否存在 MYVAR 这个局部变量或缓存变量。</p>
<p>值得注意的是：空字符串（即””）不代表变量不存在。因此即使是空字符串 DEFINED 也认为存在。</p>
<p><strong>if (xx)</strong> <strong>可以判断某变量是否存在且不为空字符串</strong></p>
<p>可以直接用 if (xx) 来判断是否为空字符串，因为空字符串等价于 FALSE。</p>
<p><strong>if (DEFINED ENV{xx})</strong> <strong>判断某环境变量是否存在</strong></p>
<p>因为 $ENV{xx} 代表环境变量，因此在 set 和 if 中也可以用 ENV{xx} 来表示环境变量。因为 set 的第一参数和 if 的参数都是不加 $ 的，所以要设置 ${x} 就变成了 set(x …)。而设置 $ENV{x} 自然就是 set(ENV{x} …) 咯。</p>
<p>同理还可以用 if (DEFINED CACHE{x}) 判断是否存在这个缓存变量，但是 set(CACHE{x} …) 就不行。</p>
<h2 id="其他建议"><a href="#其他建议" class="headerlink" title="其他建议"></a>其他建议</h2><h3 id="CCache：编译加速缓存"><a href="#CCache：编译加速缓存" class="headerlink" title="CCache：编译加速缓存"></a>CCache：编译加速缓存</h3><p>用法：把 gcc -c main.cpp -o main 换成 ccache gcc -c main.cpp -o main 即可</p>
<p>在 CMake 中可以这样来启用 ccache（就是给每个编译和链接命令前面加上 ccache）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">cmake_minimum_required(VERSION 3.15)</span><br><span class="line">project(hellocmake)</span><br><span class="line"></span><br><span class="line">find_program(CCACHE_PROGRAM ccache)</span><br><span class="line">if (CCACHE_PROGRAM)</span><br><span class="line">    message(STATUS &quot;Found CCache: $&#123;CCACHE_PROGRAM&#125;&quot;)</span><br><span class="line">    set_property(GLOBAL PROPERTY RULE_LAUNCH_COMPILE $&#123;CCACHE_PROGRAM&#125;)</span><br><span class="line">    set_property(GLOBAL PROPERTY RULE_LAUNCH_LINK $&#123;CCACHE_PROGRAM&#125;)</span><br><span class="line">endif()</span><br><span class="line"></span><br><span class="line">add_executable(main main.cpp)</span><br></pre></td></tr></table></figure>

<h3 id="快速启动主程序"><a href="#快速启动主程序" class="headerlink" title="快速启动主程序"></a>快速启动主程序</h3><p>创建一个 run 伪目标，其执行 main 的可执行文件。</p>
<p>这里用了生成器表达式 $&lt;TARGET_FILE:main&gt;，会自动让 run 依赖于 main。如果不放心有没有自动依赖上，手动加一个 add_dependencies(run main) 也是可以的。</p>
<p>这样就可以在命令行运行 cmake –build build –target run 来启动 main.exe 运行了。而不必根据不同的平台，手动写出 build&#x2F;main 或是 build\main.exe。</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_executable</span>(main main.cpp)</span><br><span class="line"><span class="keyword">add_custom_target</span>(run <span class="keyword">COMMAND</span> $&lt;TARGET_FILE:main&gt;)</span><br><span class="line"></span><br><span class="line"><span class="comment">#命令行输入下列命令启动</span></span><br><span class="line">cmake --build build --<span class="keyword">target</span> run</span><br></pre></td></tr></table></figure>


      
       <hr><span style="font-style: italic;color: gray;"> 转载请注明来源，欢迎对文章中的引用来源进行考证，欢迎指出任何有错误或不够清晰的表达。可以在下面评论区评论，也可以邮件至 jaytp@qq.com </span>
    </div>
</article>


<p>
    <a  class="dashang" onclick="dashangToggle()">💰</a>
</p>






    




    </div>
    <div class="copyright">
        <p class="footer-entry">
    ©2016-2020 Yelog
</p>
<p class="footer-entry">Built with <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/yelog/hexo-theme-3-hexo" target="_blank">3-hexo</a> theme</p>

    </div>
    <div class="full-toc">
        <button class="full" data-title="切换全屏 快捷键 s"><span class="min "></span></button>
<a class="" id="rocket" ></a>

    </div>
</div>

<div class="hide_box" onclick="dashangToggle()"></div>
<div class="shang_box">
    <a class="shang_close"  onclick="dashangToggle()">×</a>
    <div class="shang_tit">
        <p>Help us with donation</p>
    </div>
    <div class="shang_payimg">
        <div class="pay_img">
            <img src="/img/alipay.jpg" class="alipay" title="扫码支持">
            <img src="/img/weixin.jpg" class="weixin" title="扫码支持">
        </div>
    </div>
    <div class="shang_payselect">
        <span><label><input type="radio" name="pay" checked value="alipay">alipay</label></span><span><label><input type="radio" name="pay" value="weixin">weixin</label></span>
    </div>
</div>


</body>
<script src="/js/jquery.pjax.js?v=1.1.0" ></script>

<script src="/js/script.js?v=1.1.0" ></script>
<script>
    var img_resize = 'default';
    function initArticle() {
        /*渲染对应的表格样式*/
        
            $("#post .pjax table").addClass("green_title");
        

        /*渲染打赏样式*/
        
        $("input[name=pay]").on("click", function () {
            if($("input[name=pay]:checked").val()=="weixin"){
                $(".shang_box .shang_payimg .pay_img").addClass("weixin_img");
            } else {
                $(".shang_box .shang_payimg .pay_img").removeClass("weixin_img");
            }
        })
        

        /*高亮代码块行号*/
        

        /*访问数量*/
        
        $.getScript("//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js");
        

        /*代码高亮，行号对齐*/
        $('.pre-numbering').css('line-height',$('.has-numbering').css('line-height'));

        
        
    }

    /*打赏页面隐藏与展示*/
    
    function dashangToggle() {
        $(".shang_box").fadeToggle();
        $(".hide_box").fadeToggle();
    }
    

</script>

<!--加入行号的高亮代码块样式-->

<!--自定义样式设置-->
<style>
    
    
    .nav {
        width: 542px;
    }
    .nav.fullscreen {
        margin-left: -542px;
    }
    .nav-left {
        width: 120px;
    }
    
    
    @media screen and (max-width: 1468px) {
        .nav {
            width: 492px;
        }
        .nav.fullscreen {
            margin-left: -492px;
        }
        .nav-left {
            width: 100px;
        }
    }
    
    
    @media screen and (max-width: 1024px) {
        .nav {
            width: 492px;
            margin-left: -492px
        }
        .nav.fullscreen {
            margin-left: 0;
        }
    }
    
    @media screen and (max-width: 426px) {
        .nav {
            width: 100%;
        }
        .nav-left {
            width: 100%;
        }
    }
    
    
    .nav-right .title-list nav a .post-title, .nav-right .title-list #local-search-result a .post-title {
        color: #383636;
    }
    
    
    .nav-right .title-list nav a .post-date, .nav-right .title-list #local-search-result a .post-date {
        color: #5e5e5f;
    }
    
    
    .nav-right nav a.hover, #local-search-result a.hover{
        background-color: #e2e0e0;
    }
    
    

    /*列表样式*/
    

    /* 背景图样式 */
    
    


    /*引用块样式*/
    

    /*文章列表背景图*/
    

    
</style>







</html>
