<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>Hexo</title>
  <meta name="keywords" content="">
  <meta name="description" content="Hexo">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="description" content="网络模型方案均以粗糙的 Python 玩具代码为例 方案 1（Accept + Read&#x2F;Write）1234567891011121314151617181920212223242526import socketdef handle(client_socket, client_address):    &#x2F;&#x2F; L6    while True:        data &#x3D; client_">
<meta property="og:type" content="article">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/2023/01/22/%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="网络模型方案均以粗糙的 Python 玩具代码为例 方案 1（Accept + Read&#x2F;Write）1234567891011121314151617181920212223242526import socketdef handle(client_socket, client_address):    &#x2F;&#x2F; L6    while True:        data &#x3D; client_">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://sleepy-1256633542.cos.ap-beijing.myqcloud.com/20181222103157.png">
<meta property="og:image" content="https://sleepy-1256633542.cos.ap-beijing.myqcloud.com/20181222102937.png">
<meta property="og:image" content="https://sleepy-1256633542.cos.ap-beijing.myqcloud.com/20181222102957.png">
<meta property="og:image" content="https://sleepy-1256633542.cos.ap-beijing.myqcloud.com/20181222103019.png">
<meta property="og:image" content="https://sleepy-1256633542.cos.ap-beijing.myqcloud.com/20181222103040.png">
<meta property="og:image" content="https://sleepy-1256633542.cos.ap-beijing.myqcloud.com/20181222103102.png">
<meta property="article:published_time" content="2023-01-22T03:54:02.008Z">
<meta property="article:modified_time" content="2022-12-29T10:29:19.779Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://sleepy-1256633542.cos.ap-beijing.myqcloud.com/20181222103157.png">


<link rel="icon" href="/img/avatar.jpg">

<link href="/css/style.css?v=1.1.0" rel="stylesheet">

<link href="/css/hl_theme/atom-light.css?v=1.1.0" rel="stylesheet">

<link href="//cdn.jsdelivr.net/npm/animate.css@4.1.0/animate.min.css" rel="stylesheet">

<script src="//cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js"></script>
<script src="/js/titleTip.js?v=1.1.0" ></script>

<script src="//cdn.jsdelivr.net/npm/highlightjs@9.16.2/highlight.pack.min.js"></script>
<script>
    hljs.initHighlightingOnLoad();
</script>

<script src="//cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js"></script>



<script src="//cdn.jsdelivr.net/npm/jquery.cookie@1.4.1/jquery.cookie.min.js" ></script>

<script src="/js/iconfont.js?v=1.1.0" ></script>

<meta name="generator" content="Hexo 6.3.0"></head>
<div style="display: none">
  <input class="theme_disqus_on" value="false">
  <input class="theme_preload_comment" value="">
  <input class="theme_blog_path" value="">
  <input id="theme_shortcut" value="true" />
  <input id="theme_highlight_on" value="true" />
  <input id="theme_code_copy" value="true" />
</div>



<body>
<aside class="nav">
    <div class="nav-left">
        <a href="/"
   class="avatar_target">
    <img class="avatar"
         src="/img/avatar.jpg"/>
</a>
<div class="author">
    <span>John Doe</span>
</div>

<div class="icon">
    
        
            <a title="rss"
               href="/atom.xml"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-rss"></use>
                    </svg>
                
            </a>
        
    
        
            <a title="github"
               href="https://github.com/yelog"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-github"></use>
                    </svg>
                
            </a>
        
    
        
            <a title="facebook"
               href="https://www.facebook.com/faker.tops"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-facebook"></use>
                    </svg>
                
            </a>
        
    
        
    
        
    
        
            <a title="instagram"
               href="https://www.facebook.com/faker.tops"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-instagram"></use>
                    </svg>
                
            </a>
        
    
        
            <a title="reddit"
               href="https://www.reddit.com/user/yelog/"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-reddit"></use>
                    </svg>
                
            </a>
        
    
        
            <a title="weibo"
               href="http://weibo.com/u/2307534817"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-weibo"></use>
                    </svg>
                
            </a>
        
    
        
            <a title="jianshu"
               href="https://www.jianshu.com/u/ff56736de7cf"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-jianshu"></use>
                    </svg>
                
            </a>
        
    
        
            <a title="zhihu"
               href="https://www.zhihu.com/people/jaytp/activities"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-zhihu"></use>
                    </svg>
                
            </a>
        
    
        
    
        
            <a title="oschina"
               href="https://my.oschina.net/yelog"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-oschina"></use>
                    </svg>
                
            </a>
        
    
        
    
        
            <a title="email"
               href="mailto:jaytp@qq.com"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-email"></use>
                    </svg>
                
            </a>
        
    
        
            <a title="qq"
               href="http://wpa.qq.com/msgrd?v=3&uin=872336115&site=qq&menu=yes"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-qq"></use>
                    </svg>
                
            </a>
        
    
        
            <a title="kugou"
               href="https://www.kugou.com/"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-kugou"></use>
                    </svg>
                
            </a>
        
    
        
            <a title="neteasemusic"
               href="https://music.163.com/#/user/home?id=88151013"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-neteasemusic"></use>
                    </svg>
                
            </a>
        
    
</div>




<ul>
    <li>
        <div class="all active" data-rel="All">All
            
                <small>(40)</small>
            
        </div>
    </li>
    
</ul>
<div class="left-bottom">
    <div class="menus">
        
            
            
            
    </div>
    <div>
        
            <a class="about  hasFriend  site_url"
               
               href="/about">About</a>
        
        <a style="width: 50%"
                
                                           class="friends">Friends</a>
        
    </div>
</div>
<input type="hidden" id="yelog_site_posts_number" value="40">

<div style="display: none">
    <span id="busuanzi_value_site_uv"></span>
    <span id="busuanzi_value_site_pv"></span>
</div>

    </div>
    <div class="nav-right">
        <div class="friends-area">
    <div class="friends-title">
        Links
        <i class="iconfont icon-left"></i>
    </div>
    <div class="friends-content">
        <ul>
            
            <li><a target="_blank" href="http://yelog.org/">叶落阁</a></li>
            
        </ul>
    </div>
</div>
        <div class="title-list">
    <div class="right-top">
        <div id="default-panel">
            <i class="iconfont icon-search" data-title="搜索 快捷键 i"></i>
            <div class="right-title">All</div>
            <i class="iconfont icon-file-tree" data-title="切换到大纲视图 快捷键 w"></i>
        </div>
        <div id="search-panel">
            <i class="iconfont icon-left" data-title="返回"></i>
            <input id="local-search-input" autocomplete="off"/>
            <label class="border-line" for="input"></label>
            <i class="iconfont icon-case-sensitive" data-title="大小写敏感"></i>
            <i class="iconfont icon-tag" data-title="标签"></i>
        </div>
        <div id="outline-panel" style="display: none">
            <div class="right-title">大纲</div>
            <i class="iconfont icon-list" data-title="切换到文章列表"></i>
        </div>
    </div>

    <div class="tags-list">
    <input id="tag-search" />
    <div class="tag-wrapper">
        
    </div>

</div>

    
    <nav id="title-list-nav">
        
        
        <a  class="All "
           href="/2023/01/22/%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B/"
           data-tag=""
           data-author="" >
            <span class="post-title" title=""></span>
            <span class="post-date" title="2023-01-22 11:54:02">2023/01/22</span>
        </a>
        
        
        <a  class="All "
           href="/2023/01/22/%E7%BD%91%E7%BB%9Cio%E6%A8%A1%E5%9E%8B/"
           data-tag=""
           data-author="" >
            <span class="post-title" title=""></span>
            <span class="post-date" title="2023-01-22 11:54:02">2023/01/22</span>
        </a>
        
        
        <a  class="All "
           href="/2023/01/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"
           data-tag=""
           data-author="" >
            <span class="post-title" title=""></span>
            <span class="post-date" title="2023-01-22 11:54:02">2023/01/22</span>
        </a>
        
        
        <a  class="All "
           href="/2023/01/22/%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E5%AE%9A%E6%97%B6%E5%99%A8/"
           data-tag=""
           data-author="" >
            <span class="post-title" title=""></span>
            <span class="post-date" title="2023-01-22 11:54:02">2023/01/22</span>
        </a>
        
        
        <a  class="All "
           href="/2023/01/22/%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%E9%9D%9E%E6%B3%95%E8%BE%93%E5%85%A5%E4%BB%A5%E5%8F%8A%E6%9E%84%E9%80%A0%E5%BC%82%E5%B8%B8%E6%83%85%E5%86%B5/"
           data-tag=""
           data-author="" >
            <span class="post-title" title=""></span>
            <span class="post-date" title="2023-01-22 11:54:01">2023/01/22</span>
        </a>
        
        
        <a  class="All "
           href="/2023/01/22/%E5%86%85%E7%BD%AE%E7%B1%BB%E5%9E%8B%E5%92%8CPOD%E7%B1%BB%E5%9E%8B/"
           data-tag=""
           data-author="" >
            <span class="post-title" title=""></span>
            <span class="post-date" title="2023-01-22 11:54:01">2023/01/22</span>
        </a>
        
        
        <a  class="All "
           href="/2023/01/22/%E7%B1%BB%E5%9E%8B%E5%AE%89%E5%85%A8/"
           data-tag=""
           data-author="" >
            <span class="post-title" title=""></span>
            <span class="post-date" title="2023-01-22 11:54:01">2023/01/22</span>
        </a>
        
        
        <a  class="All "
           href="/2023/01/22/%E9%9D%99%E6%80%81%E9%93%BE%E6%8E%A5%E5%92%8C%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5/"
           data-tag=""
           data-author="" >
            <span class="post-title" title=""></span>
            <span class="post-date" title="2023-01-22 11:54:01">2023/01/22</span>
        </a>
        
        
        <a  class="All "
           href="/2023/01/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"
           data-tag=""
           data-author="" >
            <span class="post-title" title=""></span>
            <span class="post-date" title="2023-01-22 11:54:01">2023/01/22</span>
        </a>
        
        
        <a  class="All "
           href="/2023/01/22/%E8%B0%B7%E6%AD%8Cc++%E9%A3%8E%E6%A0%BC/"
           data-tag=""
           data-author="" >
            <span class="post-title" title=""></span>
            <span class="post-date" title="2023-01-22 11:54:01">2023/01/22</span>
        </a>
        
        
        <a  class="All "
           href="/2023/01/22/%E9%98%B2%E5%BE%A1%E5%BC%8F%E7%BC%96%E7%A8%8B%E5%92%8C%E5%A5%91%E7%BA%A6%E5%BC%8F%E7%BC%96%E7%A8%8B%EF%BC%8C%E6%96%AD%E8%A8%80%E5%92%8C%E5%BC%82%E5%B8%B8/"
           data-tag=""
           data-author="" >
            <span class="post-title" title=""></span>
            <span class="post-date" title="2023-01-22 11:54:01">2023/01/22</span>
        </a>
        
        
        <a  class="All "
           href="/2023/01/22/%E5%A4%9A%E7%BB%B4%E6%95%B0%E7%BB%84/"
           data-tag=""
           data-author="" >
            <span class="post-title" title=""></span>
            <span class="post-date" title="2023-01-22 11:54:01">2023/01/22</span>
        </a>
        
        
        <a  class="All "
           href="/2023/01/22/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB%E7%AC%94%E8%AE%B0%EF%BC%88%E7%B1%BB%E4%BC%BCcsapp%E7%9A%84%E4%B9%A6%EF%BC%89/"
           data-tag=""
           data-author="" >
            <span class="post-title" title=""></span>
            <span class="post-date" title="2023-01-22 11:54:01">2023/01/22</span>
        </a>
        
        
        <a  class="All "
           href="/2023/01/22/%E5%B8%B8%E7%94%A8api%E5%92%8C%E5%A4%B4%E6%96%87%E4%BB%B6/"
           data-tag=""
           data-author="" >
            <span class="post-title" title=""></span>
            <span class="post-date" title="2023-01-22 11:54:01">2023/01/22</span>
        </a>
        
        
        <a  class="All "
           href="/2023/01/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"
           data-tag=""
           data-author="" >
            <span class="post-title" title=""></span>
            <span class="post-date" title="2023-01-22 11:54:01">2023/01/22</span>
        </a>
        
        
        <a  class="All "
           href="/2023/01/22/%E7%BC%96%E8%AF%91%E6%9C%9F%E5%B8%B8%E9%87%8F%E5%92%8Cconstexpr/"
           data-tag=""
           data-author="" >
            <span class="post-title" title=""></span>
            <span class="post-date" title="2023-01-22 11:54:01">2023/01/22</span>
        </a>
        
        
        <a  class="All "
           href="/2023/01/22/vscode%20c++%E8%BF%90%E8%A1%8C%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"
           data-tag=""
           data-author="" >
            <span class="post-title" title=""></span>
            <span class="post-date" title="2023-01-22 11:54:01">2023/01/22</span>
        </a>
        
        
        <a  class="All "
           href="/2023/01/22/stdref/"
           data-tag=""
           data-author="" >
            <span class="post-title" title=""></span>
            <span class="post-date" title="2023-01-22 11:54:01">2023/01/22</span>
        </a>
        
        
        <a  class="All "
           href="/2023/01/22/stdaccumulate%E5%92%8Cstdtransform/"
           data-tag=""
           data-author="" >
            <span class="post-title" title=""></span>
            <span class="post-date" title="2023-01-22 11:54:01">2023/01/22</span>
        </a>
        
        
        <a  class="All "
           href="/2023/01/22/socket%20api/"
           data-tag=""
           data-author="" >
            <span class="post-title" title=""></span>
            <span class="post-date" title="2023-01-22 11:54:01">2023/01/22</span>
        </a>
        
        
        <a  class="All "
           href="/2023/01/22/mysql/"
           data-tag=""
           data-author="" >
            <span class="post-title" title=""></span>
            <span class="post-date" title="2023-01-22 11:54:01">2023/01/22</span>
        </a>
        
        
        <a  class="All "
           href="/2023/01/22/muduo%E7%BD%91%E7%BB%9C%E6%BA%90%E7%A0%81/"
           data-tag=""
           data-author="" >
            <span class="post-title" title=""></span>
            <span class="post-date" title="2023-01-22 11:54:01">2023/01/22</span>
        </a>
        
        
        <a  class="All "
           href="/2023/01/22/muduo%E6%97%A5%E5%BF%97/"
           data-tag=""
           data-author="" >
            <span class="post-title" title=""></span>
            <span class="post-date" title="2023-01-22 11:54:01">2023/01/22</span>
        </a>
        
        
        <a  class="All "
           href="/2023/01/22/Linux%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%9C%8D%E5%8A%A1%E7%AB%AF%E7%BC%96%E7%A8%8B%EF%BC%9A%E4%BD%BF%E7%94%A8muduo%20C++%E7%BD%91%E7%BB%9C%E5%BA%93/"
           data-tag=""
           data-author="" >
            <span class="post-title" title=""></span>
            <span class="post-date" title="2023-01-22 11:54:01">2023/01/22</span>
        </a>
        
        
        <a  class="All "
           href="/2023/01/22/linux/"
           data-tag=""
           data-author="" >
            <span class="post-title" title=""></span>
            <span class="post-date" title="2023-01-22 11:54:01">2023/01/22</span>
        </a>
        
        
        <a  class="All "
           href="/2023/01/22/IO%E5%AF%86%E9%9B%86%E5%9E%8B%E4%BB%BB%E5%8A%A1%E5%92%8C%E8%AE%A1%E7%AE%97%E5%AF%86%E9%9B%86%E5%9E%8B%E4%BB%BB%E5%8A%A1/"
           data-tag=""
           data-author="" >
            <span class="post-title" title=""></span>
            <span class="post-date" title="2023-01-22 11:54:01">2023/01/22</span>
        </a>
        
        
        <a  class="All "
           href="/2023/01/22/io%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E5%8E%9F%E7%90%86/"
           data-tag=""
           data-author="" >
            <span class="post-title" title=""></span>
            <span class="post-date" title="2023-01-22 11:54:01">2023/01/22</span>
        </a>
        
        
        <a  class="All "
           href="/2023/01/22/csapp/"
           data-tag=""
           data-author="" >
            <span class="post-title" title=""></span>
            <span class="post-date" title="2023-01-22 11:54:01">2023/01/22</span>
        </a>
        
        
        <a  class="All "
           href="/2023/01/22/CMake%20%E6%A8%A1%E5%9D%97%E5%8C%96%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/"
           data-tag=""
           data-author="" >
            <span class="post-title" title=""></span>
            <span class="post-date" title="2023-01-22 11:54:01">2023/01/22</span>
        </a>
        
        
        <a  class="All "
           href="/2023/01/22/c++%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/"
           data-tag=""
           data-author="" >
            <span class="post-title" title=""></span>
            <span class="post-date" title="2023-01-22 11:54:01">2023/01/22</span>
        </a>
        
        
        <a  class="All "
           href="/2023/01/22/c++%E7%B1%BB%E7%9A%84%E9%BB%98%E8%AE%A4%E5%87%BD%E6%95%B0/"
           data-tag=""
           data-author="" >
            <span class="post-title" title=""></span>
            <span class="post-date" title="2023-01-22 11:54:01">2023/01/22</span>
        </a>
        
        
        <a  class="All "
           href="/2023/01/22/%E8%87%AA%E5%8A%A8%E9%A9%BE%E9%A9%B6/"
           data-tag=""
           data-author="" >
            <span class="post-title" title=""></span>
            <span class="post-date" title="2023-01-22 11:54:01">2023/01/22</span>
        </a>
        
        
        <a  class="All "
           href="/2023/01/22/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E6%80%A7/"
           data-tag=""
           data-author="" >
            <span class="post-title" title=""></span>
            <span class="post-date" title="2023-01-22 11:54:01">2023/01/22</span>
        </a>
        
        
        <a  class="All "
           href="/2023/01/22/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/"
           data-tag=""
           data-author="" >
            <span class="post-title" title=""></span>
            <span class="post-date" title="2023-01-22 11:54:01">2023/01/22</span>
        </a>
        
        
        <a  class="All "
           href="/2023/01/22/%E5%BC%82%E5%B8%B8/"
           data-tag=""
           data-author="" >
            <span class="post-title" title=""></span>
            <span class="post-date" title="2023-01-22 11:54:01">2023/01/22</span>
        </a>
        
        
        <a  class="All "
           href="/2023/01/22/%E7%BA%BF%E7%A8%8B%E6%B1%A0/"
           data-tag=""
           data-author="" >
            <span class="post-title" title=""></span>
            <span class="post-date" title="2023-01-22 11:54:01">2023/01/22</span>
        </a>
        
        
        <a  class="All "
           href="/2023/01/22/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%98%9F%E5%88%97/"
           data-tag=""
           data-author="" >
            <span class="post-title" title=""></span>
            <span class="post-date" title="2023-01-22 11:54:01">2023/01/22</span>
        </a>
        
        
        <a  class="All "
           href="/2023/01/22/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/"
           data-tag=""
           data-author="" >
            <span class="post-title" title=""></span>
            <span class="post-date" title="2023-01-22 11:54:01">2023/01/22</span>
        </a>
        
        
        <a  class="All "
           href="/2023/01/22/%E7%8E%B0%E4%BB%A3CMake/"
           data-tag=""
           data-author="" >
            <span class="post-title" title=""></span>
            <span class="post-date" title="2023-01-22 11:54:01">2023/01/22</span>
        </a>
        
        
        <a  class="All "
           href="/2023/01/21/hello-world/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Hello World">Hello World</span>
            <span class="post-date" title="2023-01-21 23:44:22">2023/01/21</span>
        </a>
        
        <div id="no-item-tips">

        </div>
    </nav>
    <div id="outline-list">
    </div>
</div>

    </div>
    <div class="hide-list">
        <div class="semicircle" data-title="切换全屏 快捷键 s">
            <div class="brackets first"><</div>
            <div class="brackets">&gt;</div>
        </div>
    </div>
</aside>
<div id="post">
    <div class="pjax">
        <article id="post-mysql" class="article article-type-post" itemscope itemprop="blogPost">
    
    <div class="article-meta">
        
        
        
        
    </div>
    <div class="article-meta">
        
            Created At : <time class="date" title='Updated At: 2022-06-05 03:16:39'>2023-01-22 11:54</time>
        
    </div>
    <div class="article-meta">
        
        
        <span id="busuanzi_container_page_pv">
            Views 👀 :<span id="busuanzi_value_page_pv">
                <span class="count-comment">
                    <span class="spinner">
                      <div class="cube1"></div>
                      <div class="cube2"></div>
                    </span>
                </span>
            </span>
        </span>
        
        
    </div>
    
    <div class="toc-ref">
    
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#mysql"><span class="toc-text">mysql</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#mysql%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84"><span class="toc-text">mysql体系结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#InnoDB%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="toc-text">InnoDB存储结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#DML-DDL-DCL"><span class="toc-text">DML,DDL,DCL</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#sql%E8%AF%AD%E5%8F%A5"><span class="toc-text">sql语句</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#sql%E8%AF%AD%E5%8F%A5%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B"><span class="toc-text">sql语句执行过程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%80%E6%9D%A1%E6%9F%A5%E8%AF%A2%E8%AF%AD%E5%8F%A5%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B"><span class="toc-text">一条查询语句执行过程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9B%B4%E6%96%B0%E8%AF%AD%E5%8F%A5%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B"><span class="toc-text">更新语句执行过程</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%88%E6%9B%B4%E6%96%B0%E5%86%85%E5%AD%98%E6%95%B0%E6%8D%AE%EF%BC%8C%E4%B8%8D%E7%9B%B4%E6%8E%A5%E6%9B%B4%E6%96%B0%E7%A3%81%E7%9B%98%E6%95%B0%E6%8D%AE%E7%9A%84%E5%8E%9F%E5%9B%A0"><span class="toc-text">先更新内存数据，不直接更新磁盘数据的原因</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#redo-log"><span class="toc-text">redo log</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%A4%E9%98%B6%E6%AE%B5%E6%8F%90%E4%BA%A4"><span class="toc-text">两阶段提交</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#bin-log"><span class="toc-text">bin log</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B4%A9%E6%BA%83%E6%81%A2%E5%A4%8D"><span class="toc-text">崩溃恢复</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#change-buffer"><span class="toc-text">change buffer</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#buffer-pool"><span class="toc-text">buffer pool</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#sql%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E5%87%BD%E6%95%B0"><span class="toc-text">sql流程控制函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#sql%E8%AF%AD%E5%8F%A5%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F"><span class="toc-text">sql语句执行顺序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%A6%E6%9D%9F"><span class="toc-text">约束</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E8%A1%A8%E5%85%B3%E7%B3%BB"><span class="toc-text">多表关系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E8%A1%A8%E6%9F%A5%E8%AF%A2"><span class="toc-text">多表查询</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%81%94%E5%90%88%E6%9F%A5%E8%AF%A2"><span class="toc-text">联合查询</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%90%E6%9F%A5%E8%AF%A2"><span class="toc-text">子查询</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%94%81"><span class="toc-text">锁</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%94%81%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-text">锁的分类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%A8%E5%B1%80%E9%94%81"><span class="toc-text">全局锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A1%A8%E7%BA%A7%E9%94%81"><span class="toc-text">表级锁</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%A1%A8%E9%94%81"><span class="toc-text">表锁</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%83%E6%95%B0%E6%8D%AE%E9%94%81%EF%BC%88metadata-lock%EF%BC%89"><span class="toc-text">元数据锁（metadata lock）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%84%8F%E5%90%91%E9%94%81"><span class="toc-text">意向锁</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#AUTO-INC-%E9%94%81"><span class="toc-text">AUTO-INC 锁</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A1%8C%E9%94%81"><span class="toc-text">行锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AD%BB%E9%94%81%E5%92%8C%E6%AD%BB%E9%94%81%E6%A3%80%E6%B5%8B"><span class="toc-text">死锁和死锁检测</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1"><span class="toc-text">事务</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%9B%9B%E5%A4%A7%E7%89%B9%E6%80%A7"><span class="toc-text">事务的四大特性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%E7%9A%84%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB"><span class="toc-text">事务的隔离级别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%94%81%E5%92%8C%E4%BA%8B%E5%8A%A1%E8%AF%A6%E8%A7%A3"><span class="toc-text">锁和事务详解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#mvcc%EF%BC%88%E5%A4%9A%E7%89%88%E6%9C%AC%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6%EF%BC%89"><span class="toc-text">mvcc（多版本并发控制）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BF%AB%E7%85%A7%E5%8E%9F%E7%90%86"><span class="toc-text">快照原理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95"><span class="toc-text">索引</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E7%BB%93%E6%9E%84%E4%BC%98%E5%8A%A3%E5%88%86%E6%9E%90"><span class="toc-text">索引结构优劣分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%A2%9E%E4%B8%BB%E9%94%AE%E7%9A%84%E5%A5%BD%E5%A4%84"><span class="toc-text">自增主键的好处</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E5%88%86%E7%B1%BB"><span class="toc-text">索引分类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A6%86%E7%9B%96%E7%B4%A2%E5%BC%95"><span class="toc-text">覆盖索引</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%81%94%E5%90%88%E7%B4%A2%E5%BC%95"><span class="toc-text">联合索引</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E5%B7%A6%E5%89%8D%E7%BC%80%E5%8E%9F%E5%88%99"><span class="toc-text">最左前缀原则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E4%B8%8B%E6%8E%A8"><span class="toc-text">索引下推</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%94%AF%E4%B8%80%E7%B4%A2%E5%BC%95%E5%92%8C%E6%99%AE%E9%80%9A%E7%B4%A2%E5%BC%95%E7%9A%84%E9%80%89%E6%8B%A9"><span class="toc-text">唯一索引和普通索引的选择</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88"><span class="toc-text">索引失效</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90"><span class="toc-text">性能分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#sql%E4%BC%98%E5%8C%96"><span class="toc-text">sql优化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8F%92%E5%85%A5%E4%BC%98%E5%8C%96"><span class="toc-text">插入优化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BB%E9%94%AE%E4%BC%98%E5%8C%96"><span class="toc-text">主键优化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8E%92%E5%BA%8F%E4%BC%98%E5%8C%96"><span class="toc-text">排序优化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E7%BB%84%E4%BC%98%E5%8C%96"><span class="toc-text">分组优化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#limit%E4%BC%98%E5%8C%96"><span class="toc-text">limit优化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#count%E4%BC%98%E5%8C%96"><span class="toc-text">count优化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#update%E4%BC%98%E5%8C%96"><span class="toc-text">update优化</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%86%E5%9B%BE"><span class="toc-text">视图</span></a></li></ol></li></ol></li></ol>
    
<style>
    .left-col .switch-btn,
    .left-col .switch-area {
        display: none;
    }
    .toc-level-3 i,
    .toc-level-3 ol {
        display: none !important;
    }
</style>
</div>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="mysql"><a href="#mysql" class="headerlink" title="mysql"></a>mysql</h1><h2 id="mysql体系结构"><a href="#mysql体系结构" class="headerlink" title="mysql体系结构"></a>mysql体系结构</h2><p><strong>连接层</strong>：最上层是一些客户端和连接服务。<strong>主要完成一些类似于连接处理、授权认证、及相关的安全方案</strong>。在该层上引入了线程池的概念，为通过认证安全接入的客户端提供线程。同样在该层上可以实现基于SSL的安全链接。服务器也会为安全接入的每个客户端验证操作权限。</p>
<p><strong>服务层</strong>：第二层服务层，主要完成大部分的<strong>核心服务功能</strong>， 包括查询解析、分析、优化、缓存、以及所有的内置函数，所有跨存储引擎的功能也都在这一层实现，包括触发器、存储过程、视图等。</p>
<p><strong>引擎层</strong>：第三层存储引擎层，存储引擎就是存储数据、建立索引、更新&#x2F;查询数据等技术的实现方式。<strong>存储引擎真正的负责了MySQL中数据的存储和提取</strong>。存储引擎是基于表的，而不是基于库的，<strong>不同的表可以有不同的存储引擎</strong>。服务器通过API与存储引擎进行通信。不同的存储引擎具有的功能不同，这样我们可以根据自己的实际需要进行选取。</p>
<p><strong>存储层</strong>：第四层为数据存储层，主要是将<strong>数据存储在运行于该设备的文件系统</strong>之上，并完成与存储引擎的交互。</p>
<p><img src="C:\Users\hufei\AppData\Roaming\Typora\typora-user-images\mysqlarchitecture.png" alt="img"></p>
<h2 id="InnoDB存储结构"><a href="#InnoDB存储结构" class="headerlink" title="InnoDB存储结构"></a>InnoDB存储结构</h2><p>InnoDB 的数据是按「数据页」为单位来读写的，默认数据页大小为 16 KB。每个数据页之间通过双向链表的形式组织起来，物理上不连续，但是逻辑上连续。</p>
<p><img src="C:\Users\hufei\AppData\Roaming\Typora\typora-user-images\image-20220603121225077.png" alt="image-20220603121225077"></p>
<p>数据页内包含用户记录，每个记录之间用单向有序链表的方式组织起来，为了加快在数据页内高效查询记录，设计了一个页目录，页目录存储各个槽（分组），且主键值是有序的，于是可以通过二分查找法的方式进行检索从而提高效率。</p>
<p><img src="C:\Users\hufei\AppData\Roaming\Typora\typora-user-images\image-20220603121302165.png" alt="image-20220603121302165"></p>
<p>为了高效查询记录所在的数据页，InnoDB 采用 b+ 树作为索引，每个节点都是一个数据页。</p>
<p><img src="C:\Users\hufei\AppData\Roaming\Typora\typora-user-images\image-20220603121415375.png" alt="image-20220603121415375"></p>
<h2 id="DML-DDL-DCL"><a href="#DML-DDL-DCL" class="headerlink" title="DML,DDL,DCL"></a>DML,DDL,DCL</h2><p> DML（Data Manipulation Language，数据操作语言）：用于<strong>检索或者修改数据</strong>。<br> DML包括： </p>
<p>​	SELECT：用于检索数据；<br>​    INSERT：用于增加数据到数据库；<br>​    UPDATE：用于从数据库中修改现存的数据<br>​    DELETE：用于从数据库中删除数据。</p>
<p> DDL（Data Definition Language，数据定义语言）： 用于<strong>定义数据的结构</strong>，比如创建、修改或者删除数据库对象。<br> DDL包括：DDL语句可以用于创建用户和重建数据库对象。下面是DDL命令：<br>    CREATE TABLE：创建表<br>    ALTER TABLE<br>    DROP TABLE：删除表<br>    CREATE INDEX<br>    DROP INDEX</p>
<p> DCL（Data Control Language，数据控制语言）：用于<strong>定义数据库用户的权限</strong>。<br> DCL包括：<br>    ALTER PASSWORD<br>    GRANT<br>    REVOKE<br>    CREATE SYNONYM</p>
<h2 id="sql语句"><a href="#sql语句" class="headerlink" title="sql语句"></a>sql语句</h2><h3 id="sql语句执行过程"><a href="#sql语句执行过程" class="headerlink" title="sql语句执行过程"></a>sql语句执行过程</h3><h4 id="一条查询语句执行过程"><a href="#一条查询语句执行过程" class="headerlink" title="一条查询语句执行过程"></a>一条查询语句执行过程</h4><p>1.<strong>客户端发出请求</strong></p>
<p>2.<strong>mysql连接器连接客户端</strong>（验证用户身份，给予权限）。</p>
<p>​	连接有长连接和短连接。长连接是指连接成功后，如果客户端持续有请求，则一直使用同一个连接。短连接则是指每次执行完很少的几次查询就断开连接，下次查询再重新建立一个。<strong>尽量使用长连接</strong>。</p>
<p>3.<strong>查询缓存</strong>。</p>
<p>​	之前执行过的语句及其结果可能会以key-value对的形式，被直接缓存在内存中。key是查询的语句，value是查询的结果。<strong>MySQL 8.0版本之后已经没有此功能</strong>。</p>
<p>4.<strong>分析器（对SQL语句进行语法分析和词法分析操作）</strong></p>
<p>​	MySQL 需要知道你要做什么，因此需要对 SQL 语句做解析。<br>​	<strong>词法分析：</strong>你输入的是由多个字符串和空格组成的一条 SQL 语句，MySQL 需要识别出里面的字符串分别是什么，代表什么。检查查询的表或者列是否存在。</p>
<p>​	<strong>语法分析：</strong>语法分析器会根据语法规则，判断你输入的这个 SQL 语句是否满足 MySQL 语法。比如 select 少打了开头的字母“s”</p>
<p>5.<strong>优化器（主要对执行的SQL优化，执行最优的方案）</strong><br>     在开始执行之前，还要先经过优化器的处理。同一条sql语句可以有多个执行方案，但是执行的效率会有不同，而优化器的作用就是决定选择使用哪一个方案。优化器是在表里面有多个索引的时候，决定使用哪个索引；或者在一个语句有多表关联（join）的时候，决定各个表的连接顺序。</p>
<p>6.<strong>执行器（先检查用户是否有执行权限，有才会使用这个引擎提供的接口）</strong><br>    开始执行的时候，要先判断一下你对这个表 T 有没有执行查询的权限，如果没有，就会返回没有权限的错误，如果有权限，就打开表继续执行。打开表的时候，执行器就会根据表的引擎定义，去使用这个引擎提供的接口。</p>
<p>​	执行器循环调用引擎接口获取每行数据，这些接口都是引擎中已经定义好的。最后将所有满足条件的行组成的记录集作为结果集返回给客户端</p>
<p><strong>一条简单的查询语句</strong>。<code>select * from name = &quot;花一个无所&quot;</code></p>
<ol>
<li>判断 <code>buffer pool</code> 中是否存在这条数据</li>
<li>如果不存在则查磁盘。如果存在则读入<code>buffer pool</code> </li>
<li>判断 <code>change buffer</code> 中是否有这条数据。如果存在则 merge并写入<code>buffer pool</code> </li>
<li>返回 merge 之后的数据</li>
</ol>
<h4 id="更新语句执行过程"><a href="#更新语句执行过程" class="headerlink" title="更新语句执行过程"></a>更新语句执行过程</h4><p>前五个步骤与查询语句相同，关键在于执行器不同。InnoDB更新语句操作如下，以update T set c&#x3D;c+1 where ID&#x3D;2为例</p>
<ol>
<li>执行器先找引擎取ID&#x3D;2这一行。</li>
<li>执行器拿到引擎给的行数据，把这个值加上1，比如原来是N，现在就是N+1，得到新的一行数据，再调用引擎接口写入这行新数据。</li>
<li>引擎将这行新数据<strong>更新到内存中</strong>，同时将这个更新操作记录到redo log里面，此时redo log处于prepare状态。然后告知执行器执行完成了，随时可以提交事务。</li>
<li>执行器生成这个操作的binlog，并把binlog写入磁盘。</li>
<li>执行器调用引擎的提交事务接口，引擎把刚刚写入的redo log改成提交（commit）状态，更新完成。</li>
</ol>
<p><strong>一条根据普通索引简单的更新语句</strong>。<code>where name =  &quot;花一个无所&quot;</code></p>
<ol>
<li>判断 <code>buffer pool</code> 中是否存在这条数据</li>
<li>若存在则直接更新 <code>buffer pool</code></li>
<li>否则将改动写入 <code>change buffer</code></li>
<li>写 <code>redo log</code></li>
</ol>
<p><strong>一条根据唯一索引更新的语句</strong>。<code>where uniqId = 7</code></p>
<ol>
<li>判断 <code>buffer pool</code>  中是否存在这条数据</li>
<li>若存在则直接更新 <code>buffer pool</code></li>
<li>否则查磁盘，存在则读入 <code>buffer pool</code></li>
<li>更新 <code>buffer pool</code></li>
<li>写 <code>redo log</code></li>
</ol>
<h5 id="先更新内存数据，不直接更新磁盘数据的原因"><a href="#先更新内存数据，不直接更新磁盘数据的原因" class="headerlink" title="先更新内存数据，不直接更新磁盘数据的原因"></a>先更新内存数据，不直接更新磁盘数据的原因</h5><p>MySQL里如果在每次事务提交的时候，将该事务涉及修改的数据页全部刷新到磁盘中，这整个过程IO成本、查找成本都很高。</p>
<ol>
<li>Innodb 是以页为单位进行磁盘交互的，而一个事务很可能只修改一个数据页里面的几个字节，这个时候将完整的数据页刷到磁盘的话，太浪费资源了！</li>
<li>一个事务可能涉及修改多个数据页，并且这些数据页在物理上并不连续，使用随机IO写入性能太差</li>
<li>磁盘IO缓慢</li>
</ol>
<p>对于mysql来说，所有的变更都必须先更新缓冲池中的数据，然后缓冲池中的脏页会以一定的频率被刷入磁盘（<strong>checkPoint</strong>机制），通过缓冲池来优化CPU和磁盘之间的鸿沟，这样就可以保证整体的性能不会下降太快。</p>
<h5 id="redo-log"><a href="#redo-log" class="headerlink" title="redo log"></a>redo log</h5><p><strong>作用</strong>：保证事务的持久性</p>
<p>缓冲池可以帮助我们消除CPU和磁盘之间的鸿沟，checkpoint机制可以保证数据的最终落盘，然而由于checkpoint并不是每次变更的时候就触发的，而是master线程隔一段时间去处理的。所以最坏的情况就是刚写完缓冲池，数据库宕机了，那么这段数据就是丢失的，无法恢复。这样的话就不满足ACID中的D，为了解决这种情况下的持久化问题，InnoDB引擎的事务采用了WAL技术（Write-Ahead Logging），这种技术的思想就是先写日志，再写磁盘，只有日志写入成功，才算事务提交成功，这里的日志就是redo log。当发生宕机且数据未刷到磁盘的时候，可以通过redo log来恢复，保证ACID中的D，这就是redo log的作用。</p>
<p> 与从缓冲区写入磁盘相比，写redo log性能更高。redo log <strong>只记录事务对数据页做了哪些修改</strong>，这样就能完美地解决性能问题了(相对而言文件更小并且是顺序IO)。redo log是对页的物理修改，第x页的第x位置修改成xx，比如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">page(2,4),offset 64,value 2</span><br></pre></td></tr></table></figure>

<p><strong>redo log 包括两部分</strong>：一个是内存中的日志缓冲( redo log buffer )，另一个是磁盘上的日志文件( redo log file )。 mysql 每执行一条 DML 语句，先将记录写入 redo log buffer ，后续某个时间点再一次性将多个操作记录写到 redo log file 。</p>
<p>具体来说，当有一条记录需要更新的时候，InnoDB引擎就会先把记录写到redo log里面，并更新内存，这个时候更新就算完成了。同时，InnoDB引擎会在适当的时候，将这个操作记录更新到磁盘里面，如系统比较空闲或者redo log写满的时候。</p>
<p>redo log采用循环写，会发生覆盖。文件中有write pos和checkpoint。write pos是当前记录的位置，一边写一边后移，写到文件末尾后回到文件开头。checkpoint是当前要擦除的位置，也是往后推移并且循环的，擦除记录前要把记录更新到数据文件。</p>
<p>如果write pos追上checkpoint，表示log满了，这时候不能再执行新的更新，得停下来先擦掉一些记录，把checkpoint推进一下。</p>
<p>有了redo log，InnoDB就可以保证即使数据库发生异常重启，之前提交的记录都不会丢失，这个能力称为<strong>crash-safe</strong>。</p>
<h5 id="两阶段提交"><a href="#两阶段提交" class="headerlink" title="两阶段提交"></a><strong>两阶段提交</strong></h5><p>两阶段、三阶段都是为了解决分布式事务中的数据一致性问题</p>
<p>所谓两阶段提交，其实就是把 redo log 的写入拆分成了两个步骤：prepare 和 commit。这是为了解决bin log 与 redo log 的一致性问题，从而使从库用bin log同步时数据跟主库保持一致。</p>
<p>首先，存储引擎将执行更新好的新数据存到内存中，同时将这个更新操作记录到 redo log 里面，此时 redo log 处于 prepare 状态。然后告知执行器执行完成了，随时可以提交事务</p>
<p>然后执行器生成这个操作的 bin log，并把 bin log 写入磁盘</p>
<p>最后执行器调用存储引擎的提交事务接口，存储引擎把刚刚写入的 redo log 状态改成提交(commit)状态，更新完成</p>
<p>如果数据库在写入 redo log(prepare) 阶段之后、写入 binlog 之前，发生了崩溃：</p>
<p>此时 redo log 里面的事务处于 prepare 状态，binlog 还没写，之后从库进行同步的时候，无法执行这个操作，但是实际上主库已经完成了这个操作，所以为了主备一致，MySQL 崩溃时会在主库上回滚这个事务</p>
<p> 而如果数据库在写入 binlog 之后，redo log 状态修改为 commit 前发生崩溃，此时 redo log 里面的事务仍然是 prepare 状态，binlog 存在并完整，这样之后就会被从库同步过去，但是实际上主库并没有完成这个操作，所以为了主备一致，即使在这个时刻数据库崩溃了，恢复后仍会重新提交事务。</p>
<h5 id="bin-log"><a href="#bin-log" class="headerlink" title="bin log"></a>bin log</h5><p>binlog 用于记录数据库执行的写入性操作(不包括查询)信息，以二进制的形式保存在磁盘中。 binlog 是 mysql的逻辑日志，并且由 Server 层进行记录，使用任何存储引擎的 mysql 数据库都会记录 binlog 日志。</p>
<ul>
<li><strong>逻辑日志</strong>： 可以简单理解为记录的就是sql语句 。</li>
<li><strong>物理日志</strong>： mysql 数据最终是保存在数据页中的，物理日志记录的就是数据页变更 。</li>
</ul>
<p>binlog 是通过追加的方式进行写入的，可以通过 max_binlog_size 参数设置每个 binlog文件的大小，当文件大小达到给定值之后，会生成新的文件来保存日志。</p>
<p>在实际应用中， binlog 的主要使用场景有两个，分别是 <strong>主从复制</strong> 和 <strong>数据恢复</strong> 。</p>
<ol>
<li><strong>主从复制</strong> ：在 Master 端开启 binlog ，然后将 binlog 发送到各个 Slave 端， Slave 端重放 binlog 从而达到主从数据一致。</li>
<li><strong>数据恢复</strong> ：通过使用 mysqlbinlog 工具来恢复数据。</li>
</ol>
<p><strong>bin log和redo log不同之处</strong></p>
<p>bin log和redo log有以下不同。</p>
<ol>
<li>redo log是InnoDB引擎特有的；binlog是MySQL的Server层实现的，所有引擎都可以使用。</li>
<li>redo log是物理日志，记录的是“在某个数据页上做了什么修改”；binlog是逻辑日志，记录的是这个语句的原始逻辑。</li>
<li>redo log是循环写的，文件大小固定会用完；binlog是可以追加写入的，可以设置每个文件大小，binlog文件写到一定大小后会切换到下一个，并不会覆盖以前的日志。</li>
<li>redo log 适用于崩溃恢复(crash-safe)；binlog 适用于主从复制和数据从备份恢复</li>
</ol>
<h5 id="崩溃恢复"><a href="#崩溃恢复" class="headerlink" title="崩溃恢复"></a>崩溃恢复</h5><p><strong>redo log能用于崩溃恢复的原因</strong></p>
<p>redo log <strong>只会记录未刷入磁盘的日志</strong>，已经刷入磁盘的数据都会从 redo log 这个有限大小的日志文件里删除。</p>
<p>而 bin log 是追加日志，<strong>保存的是全量的日志</strong>。这就会导致一个问题，那就是没有标志能让 InnoDB 从 bin log 中判断哪些数据已经刷入磁盘了，哪些数据还没有。</p>
<p>因此数据库重启后，直接把 redo log 中的数据都恢复至内存就可以了。这就是为什么说 redo log 具有崩溃恢复的能力，而 bin log 不具备。</p>
<p>但是如果不小心整个数据库的数据被删除了，能使用redo log文件恢复数据吗？此时不可以使用redo log文件恢复，只能使用binlog文件从备份恢复。因为redo log文件不会存储历史所有的数据的变更，当内存数据刷新到磁盘中，redo log的数据就失效了，也就是redo log文件内容是会被覆盖的。</p>
<p><strong>恢复步骤</strong></p>
<p>根据两阶段提交，崩溃恢复时的判断规则是这样的：</p>
<p>如果 redo log 里面的事务是完整的，也就是已经有了 commit 标识，则直接提交</p>
<p>如果 redo log 里面的事务处于 prepare 状态，则判断对应的事务 binlog 是否存在并完整（一个事务的 binlog 有完整格式，mysql可以判断）</p>
<ul>
<li>a. 如果 binlog 存在并完整，则提交事务;</li>
<li>b. 否则，回滚事务。</li>
</ul>
<h5 id="change-buffer"><a href="#change-buffer" class="headerlink" title="change buffer"></a>change buffer</h5><p>change buffer是 <code>buffer pool</code>中的一块缓冲区，存储的是<strong>普通二级索引页</strong>的数据变更。它主要解决的是<strong>随机读磁盘IO</strong>消耗大的问题。</p>
<p>当有一条更新语句进来对某条数据进行修改时，需要找到这条数据，优先从 <code>buffer pool</code> 中找，不存在则从磁盘获取。将数据页从磁盘读入 <code>buffer pool</code> 涉及随机 IO 访问，这是数据库中成本最高的操作之一。所以有了这么一块缓冲区之后，针对某些写入或修改操作，直接把改动缓存在 <code>change buffer</code> 中，省去将数据从磁盘读入的过程。当下次查询的时候再从磁盘读出原始数据，将原始数据和 <code>change buffer</code> 中的改动做 merge 之后返回。</p>
<p><code>change buffer</code> 虽然是缓冲区。但其实它是可以持久化的，它持久化的地方默认是 <code>ibdata1</code>  共享空间表中(change buffer的写盘策略跟数据一样，内存放不下会触发落盘，还有checkpoint推进的时候也可能会触发)。因为为了保证数据的一致性。同时， <code>change buffer</code> 也是需要写 <code>redo log</code> 的。所以 <code>redo log</code> 里不仅有针对普通数据页的改动记录，也有 <code>change buffer</code> 的记录。</p>
<p>change buffer适合<strong>写多读少</strong>的业务场景，这种业务模型常见的就是账单类、日志类的系统。反过来，假设一个业务的更新模式是写入之后马上会做查询，那么即使满足了条件，将更新先记录在change buffer，但之后由于马上要访问这个数据页，会立即触发merge过程。这样随机访问IO的次数不会减少，反而增加了change buffer的维护代价。所以，对于这种业务模式来说，change buffer反而起到了副作用。</p>
<p><strong>唯一索引无法使用change buffer</strong>，因为唯一索引更新时需要进行唯一性检查，这必须要将数据从磁盘读入才能判断。</p>
<h3 id="buffer-pool"><a href="#buffer-pool" class="headerlink" title="buffer pool"></a>buffer pool</h3><p> MySQL 的数据是存储在磁盘里的，每次都从磁盘里面读取数据性能是极差的。</p>
<p>为此，Innodb 存储引擎设计了一个<strong>缓冲池(Buffer Pool）</strong>，来提高数据库的读写性能。</p>
<p>有了缓冲池后：</p>
<ul>
<li>当读取数据时，如果数据存在于 Buffer Pool 中，客户端就会直接读取 Buffer Pool 中的数据，否则再去磁盘中读取。</li>
<li>当修改数据时，首先是修改 Buffer Pool 中数据所在的页，然后将其页设置为脏页，最后由后台线程将脏页写入到磁盘。</li>
</ul>
<p><img src="C:\Users\hufei\AppData\Roaming\Typora\typora-user-images\image-20220603140803847.png" alt="image-20220603140803847"></p>
<p>为了更好的管理这些在 Buffer Pool 中的缓存页，InnoDB 为每一个缓存页都创建了一个<strong>控制块</strong>，控制块信息包括「缓存页的表空间、页号、缓存页地址、链表节点」等等。</p>
<p>当我们查询一条记录时，InnoDB 会把整个页的数据加载到 Buffer Pool 中，因为，通过索引只能定位到磁盘中的页，而不能定位到页中的一条记录。将页加载到 Buffer Pool 后，再通过页里的页目录去定位到某条具体的记录。</p>
<p><strong>如何管理空闲页</strong></p>
<p>为了能够快速找到空闲的缓存页，可以使用链表结构，将空闲缓存页的「控制块」作为链表的节点，这个链表称为 <strong>Free 链表</strong>（空闲链表）。</p>
<p>有了 Free 链表后，每当需要从磁盘中加载一个页到 Buffer Pool 中时，就从 Free链表中取一个空闲的缓存页，并且把该缓存页对应的控制块的信息填上，然后把该缓存页对应的控制块从 Free 链表中移除。</p>
<p><strong>如何管理脏页</strong></p>
<p>更新数据的时候，不需要每次都要写入磁盘，而是将 Buffer Pool 对应的缓存页标记为<strong>脏页</strong>，然后再由后台线程将脏页写入到磁盘。</p>
<p>那为了能快速知道哪些缓存页是脏的，于是就设计出 <strong>Flush 链表</strong>，它跟 Free 链表类似的，链表的节点也是控制块，区别在于 Flush 链表的元素都是脏页。</p>
<p><strong>如何管理脏页+干净页</strong></p>
<p>干净页，表示此页已被使用，但是页面未发生修改。使用<strong>LRU 链表（Least recently used）</strong>管理脏页+干净页，也就是说<strong>脏页同时存在于 LRU 链表和 Flush 链表</strong>。</p>
<p>简单的 LRU 算法并没有被 MySQL 使用，因为简单的 LRU 算法无法避免下面这两个问题：</p>
<ul>
<li>预读失效；</li>
<li>Buffer Pool 污染；</li>
</ul>
<p>程序有空间局部性的，靠近当前被访问数据的数据，在未来很大概率会被访问到。因此MySQL 在加载数据页时，会提前把它相邻的数据页一并加载进来，这就是预读。但是可能这些被提前加载进来的数据页，并没有被访问，相当于这个预读是白做了，这个就是<strong>预读失效</strong>。如果这些预读页如果一直不会被访问到，就会出现一个很奇怪的问题，<strong>不会被访问的预读页却占用了 LRU 链表前排的位置</strong>，而末尾淘汰的页，可能是频繁访问的页，这样就大大降低了缓存命中率。</p>
<p><strong>如何解决预读失效</strong></p>
<p>MySQL 是这样做的，它改进了 LRU 算法，将 LRU 划分了 2 个区域：<strong>old 区域 和 young 区域</strong>。young 区域在 LRU 链表的前半部分，old 区域则是在后半部分，如下图：</p>
<p><img src="C:\Users\hufei\AppData\Roaming\Typora\typora-user-images\image-20220605025934160.png" alt="image-20220605025934160"></p>
<p>old 区域占整个 LRU 链表长度的比例可以通过 <code>innodb_old_blocks_pc</code> 参数来设置，默认是 37，代表整个 LRU 链表中 young 区域与 old 区域比例是 63:37。</p>
<p><strong>划分这两个区域后，预读的页就只需要加入到 old 区域的头部，当页被真正访问的时候，才将页插入 young 区域的头部</strong>。如果预读的页一直没有被访问，就会从 old 区域移除，这样就不会影响 young 区域中的热点数据。</p>
<p><strong>如何解决Buffer Pool 污染</strong></p>
<p>当某一个 SQL 语句<strong>扫描了大量的数据</strong>时，在 Buffer Pool 空间比较有限的情况下，可能会将 <strong>Buffer Pool 里的所有页都替换出去，导致大量热数据被淘汰了</strong>，等这些热数据又被再次访问的时候，由于缓存未命中，就会产生大量的磁盘 IO，MySQL 性能就会急剧下降，这个过程被称为 <strong>Buffer Pool 污染</strong>。</p>
<p>像前面这种全表扫描的查询，很多缓冲页其实只会被访问一次，但是它却只因为被访问了一次而进入到 young 区域，从而导致热点数据被替换了。LRU 链表中 young 区域就是热点数据，只要我们<strong>提高进入到 young 区域的门槛</strong>，就能有效地保证 young 区域里的热点数据不会被替换掉。</p>
<p>MySQL 是这样做的，进入到 young 区域条件增加了一个<strong>停留在 old 区域的时间判断</strong>。</p>
<p>具体是这样做的，在对某个处在 old 区域的缓存页进行第一次访问时，就在它对应的控制块中记录下来这个访问时间：</p>
<ul>
<li>如果后续的访问时间与第一次访问的时间<strong>在某个时间间隔内</strong>，那么<strong>该缓存页就不会被从 old 区域移动到 young 区域的头部</strong>；</li>
<li>如果后续的访问时间与第一次访问的时间<strong>不在某个时间间隔内</strong>，那么<strong>该缓存页移动到 young 区域的头部</strong>；</li>
</ul>
<p>这个间隔时间是由 <code>innodb_old_blocks_time</code> 控制的，默认是 1000 ms。</p>
<p>也就说，<strong>只有同时满足「被访问」与「在 old 区域停留时间超过 1 秒」两个条件，才会被插入到 young 区域头部</strong>，这样就解决了 Buffer Pool 污染的问题 。</p>
<p>另外，MySQL 针对 young 区域其实做了一个优化，为了防止 young 区域节点频繁移动到头部。young 区域前面 1&#x2F;4 被访问不会移动到链表头部，只有后面的 3&#x2F;4被访问了才会。</p>
<p><strong>脏页什么时候会被刷入磁盘</strong></p>
<p>下面几种情况会触发脏页的刷新：</p>
<ul>
<li>当 redo log 日志满了的情况下，会主动触发脏页刷新到磁盘；</li>
<li>Buffer Pool 空间不足时，需要将一部分数据页淘汰掉，如果淘汰的是脏页，需要先将脏页同步到磁盘；</li>
<li>MySQL 认为空闲时，后台线程回定期将适量的脏页刷入到磁盘；</li>
<li>MySQL 正常关闭之前，会把所有的脏页刷入到磁盘；</li>
</ul>
<h3 id="sql流程控制函数"><a href="#sql流程控制函数" class="headerlink" title="sql流程控制函数"></a>sql流程控制函数</h3><table>
<thead>
<tr>
<th>函数</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>IF(expr1,expr2,expr3)</td>
<td>如果expr1是真, 返回expr2, 否则返回expr3</td>
</tr>
<tr>
<td>IFNULL(expr1,expr2)</td>
<td>如果expr1不是NULL,返回expr1,否则返回expr2</td>
</tr>
<tr>
<td>CASE WHEN [value1] THEN[result1]… ELSE[default] END</td>
<td>如果value是真, 返回result1,否则返回default</td>
</tr>
<tr>
<td>CASE [expr] WHEN [value1] THEN[result1]… ELSE[default] END</td>
<td>如果expr等于value1, 返回result1,否则返回default</td>
</tr>
</tbody></table>
<p><strong>case when 相当于if…else if…</strong></p>
<p>查询员工的信息，<br>如果薪资高于20000，显示该员工是“高富帅”，<br>如果薪资在15000-20000之间，显示“潜力股”<br>如果薪资在10000-15000之间，显示“有为青年”<br>如果薪资在10000以下，显示“屌丝”</p>
<p>SELECT ename, salary,<br>CASE<br>WHEN salary&gt;&#x3D;20000 THEN “高富帅”<br>WHEN salary&gt;&#x3D;15000 THEN “潜力股”<br>WHEN salary&gt;&#x3D;10000 THEN “有为青年”<br>ELSE “屌丝”<br>END AS “标签”<br>FROM t_employee;</p>
<p><strong>case [expr] when相当于switch…case</strong></p>
<p>#查询订单表，显示订单编号，和订单状态，如果订单状态是0，显示新订单，是1，显示已付款…</p>
<p>SELECT oid ,price,<br>CASE state<br>WHEN 0 THEN “新建订单”<br>WHEN 1 THEN “已付款”<br>WHEN 2 THEN “已发货”<br>WHEN 3 THEN “已收货”<br>END<br>FROM t_order</p>
<h3 id="sql语句执行顺序"><a href="#sql语句执行顺序" class="headerlink" title="sql语句执行顺序"></a>sql语句执行顺序</h3><ol>
<li>from </li>
<li>join </li>
<li>on </li>
<li>where </li>
<li>group by(开始使用select中的别名，后面的语句中都可以使用)</li>
<li>avg,sum…. </li>
<li>having </li>
<li>select </li>
<li>distinct </li>
<li>order by</li>
<li>limit</li>
</ol>
<p>第一步：首先对from子句中的前两个表执行一个笛卡尔乘积，此时生成虚拟表 vt1（选择相对小的表做基础表）。<br>第二步：接下来便是应用on筛选器，on 中的逻辑表达式将应用到 vt1 中的各个行，筛选出满足on逻辑表达式的行，生成虚拟表 vt2 。<br>第三步：如果是outer join 那么这一步就将添加外部行，left outer jion 就把左表在第二步中过滤的添加进来，如果是right outer join 那么就将右表在第二步中过滤掉的行添加进来，这样生成虚拟表 vt3 。</p>
<p>第四步：如果 from 子句中的表数目多余两个表，那么就将vt3和第三个表连接从而计算笛卡尔乘积，生成虚拟表，该过程就是一个重复1-3的步骤，最终得到一个新的虚拟表 vt3。 </p>
<p>第五步：应用where筛选器，对上一步生产的虚拟表引用where筛选器，生成虚拟表vt4，在这有个比较重要的细节不得不说一下，对于包含outer join子句的查询，就有一个让人感到困惑的问题，到底在on筛选器还是用where筛选器指定逻辑表达式呢？on和where的最大区别在于，如果在on应用逻辑表达式那么在第三步outer join中还可以把移除的行再次添加回来，而where的移除的最终的。举个简单的例子，有一个学生表（班级,姓名）和一个成绩表(姓名,成绩)，我现在需要返回一个x班级的全体同学的成绩，但是这个班级有几个学生缺考，也就是说在成绩表中没有记录。为了得到我们预期的结果我们就需要在on子句指定学生和成绩表的关系（学生.姓名&#x3D;成绩.姓名）那么我们是否发现在执行第二步的时候，对于没有参加考试的学生记录就不会出现在vt2中，因为他们被on的逻辑表达式过滤掉了,但是我们用left outer join就可以把左表（学生）中没有参加考试的学生找回来，因为我们想返回的是x班级的所有学生，如果在on中应用学生.班级&#x3D;’x’的话，left outer join会把x班级的所有学生记录找回，所以只能在where筛选器中应用学生.班级&#x3D;’x’ 因为它的过滤是最终的。 </p>
<p>第六步：group by 子句将中的唯一的值组合成为一组，得到虚拟表vt5。如果应用了group by，那么后面的所有步骤都只能得到的vt5的列或者是聚合函数（count、sum、avg等）。原因在于最终的结果集中只为每个组包含一行。这一点请牢记。 </p>
<p>第七步：应用cube或者rollup选项，为vt5生成超组，生成vt6.<br>第八步：应用having筛选器，生成vt7。having筛选器是第一个也是为唯一一个应用到已分组数据的筛选器。<br>第九步：处理select子句。将vt7中的在select中出现的列筛选出来。生成vt8. </p>
<p>第十步：应用distinct子句，vt8中移除相同的行，生成vt9。事实上如果应用了group by子句那么distinct是多余的，原因同样在于，分组的时候是将列中唯一的值分成一组，同时只为每一组返回一行记录，那么所以的记录都将是不相同的。 </p>
<p>第十一步：应用order by子句。按照order_by_condition排序vt9，此时返回的一个游标，而不是虚拟表。sql是基于集合的理论的，集合不会预先对他的行排序，它只是成员的逻辑集合，成员的顺序是无关紧要的。对表进行排序的查询可以返回一个对象，这个对象包含特定的物理顺序的逻辑组织。这个对象就叫游标。正因为返回值是游标，那么使用order by 子句查询不能应用于表表达式。排序是很需要成本的，除非你必须要排序，否则最好不要指定order by，最后，在这一步中是第一个也是唯一一个可以使用select列表中别名的步骤。 </p>
<p>第十二步：应用top选项。此时才返回结果给请求者即用户。 </p>
<h3 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h3><p><img src="C:\Users\hufei\AppData\Roaming\Typora\typora-user-images\image-20220311014136188.png" alt="image-20220311014136188"></p>
<p><img src="C:\Users\hufei\AppData\Roaming\Typora\typora-user-images\image-20220311013953804.png" alt="image-20220311013953804"></p>
<p>外键：</p>
<p><img src="C:\Users\hufei\AppData\Roaming\Typora\typora-user-images\image-20220311014811937.png" alt="image-20220311014811937"></p>
<h3 id="多表关系"><a href="#多表关系" class="headerlink" title="多表关系"></a>多表关系</h3><p>表与表之间的三种关系<br>一对多关系：最常见的关系：学生对班级 ， 员工对部门<br>多对多关系：学生与课程 ， 用户与角色<br>一对一关系：使用较少，因为一对一关系可以合成为一张表</p>
<p>一对多关系 （常见）</p>
<p>　　　　例如： 班级和学生， 部门和员工， 客户和订单， 分类和商品</p>
<p>　　　　建表原则： 在从表（多方）创建一个字段， 字段作为外键指向主表（一方）的主键</p>
<p><img src="C:\Users\hufei\AppData\Roaming\Typora\typora-user-images\image-20220314204301248.png" alt="image-20220314204301248"></p>
<p>多对多关系 （常见）</p>
<p>　　　　例如：老师和学生， 学生和课程， 用户和角色</p>
<p>　　　　建表原则： 需要创建第三行表，中间表中至少有两个字段，这两个字段分别作为外键，指向各自一方的主键</p>
<p>　　　　</p>
<p> <img src="C:\Users\hufei\AppData\Roaming\Typora\typora-user-images\image-20220314204333533.png" alt="image-20220314204333533"></p>
<p>  一对一关系（了解）</p>
<p>　　　　在实际开发中应用不多，因为一对一可以创建成一张表</p>
<p>　　　　建表原则： 外键唯一， 主表的主键和从表的唯一外键，形成主外键关系， 外键唯一用UNIQUE修饰</p>
<p><img src="C:\Users\hufei\AppData\Roaming\Typora\typora-user-images\image-20220314204340789.png" alt="image-20220314204340789"></p>
<h3 id="多表查询"><a href="#多表查询" class="headerlink" title="多表查询"></a>多表查询</h3><p>等值连接是从关系R与S的广义笛卡儿积中选取A、B属性值相等的元组。</p>
<p>给出教师信息表A如下：</p>
<table>
<thead>
<tr>
<th><strong>教师号</strong></th>
<th><strong>教师名</strong></th>
</tr>
</thead>
<tbody><tr>
<td>2017</td>
<td>司小东</td>
</tr>
<tr>
<td>2018</td>
<td>魏大勇</td>
</tr>
</tbody></table>
<p>课程表B如下：</p>
<table>
<thead>
<tr>
<th>教师名</th>
<th>课程名</th>
</tr>
</thead>
<tbody><tr>
<td>司小东</td>
<td>数学模型</td>
</tr>
<tr>
<td>魏大勇</td>
<td>数据库原理</td>
</tr>
</tbody></table>
<p>如果我想通过教师号获得课程名，那就需要把两个表连接起来了，按照教师名这个属性来连接，<br>结果如下：</p>
<table>
<thead>
<tr>
<th>教师号</th>
<th>A.教师名</th>
<th>B.教师名</th>
<th>课程名</th>
</tr>
</thead>
<tbody><tr>
<td>2017</td>
<td>司小东</td>
<td>司小东</td>
<td>数学模型</td>
</tr>
<tr>
<td>2018</td>
<td>魏大勇</td>
<td>魏大勇</td>
<td>数据库原理</td>
</tr>
</tbody></table>
<p><strong>自然连接是一种特殊的等值连接，它会把重复列消除。</strong></p>
<p>所以对于自然连接后的结果应该是：</p>
<table>
<thead>
<tr>
<th>教师号</th>
<th>教师名</th>
<th>课程名</th>
</tr>
</thead>
<tbody><tr>
<td>2017</td>
<td>司小东</td>
<td>数学模型</td>
</tr>
<tr>
<td>2018</td>
<td>魏大勇</td>
<td>数据库原理</td>
</tr>
</tbody></table>
<p><strong>等值连接要求相等的分量,不一定是公共属性;而自然连接要求相等的分量必须是公共属性。</strong></p>
<p><strong>单表可以进行自连接</strong></p>
<p><img src="C:\Users\hufei\AppData\Roaming\Typora\typora-user-images\image-20220315233135576.png" alt="image-20220315233135576"></p>
<h4 id="联合查询"><a href="#联合查询" class="headerlink" title="联合查询"></a>联合查询</h4><p>联合查询可以把多次查询结果集合并，形成一个新的结果集</p>
<p><img src="C:\Users\hufei\AppData\Roaming\Typora\typora-user-images\image-20220315233531404.png" alt="image-20220315233531404"></p>
<h4 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h4><p><img src="C:\Users\hufei\AppData\Roaming\Typora\typora-user-images\image-20220315233744692.png" alt="image-20220315233744692"></p>
<p><img src="C:\Users\hufei\AppData\Roaming\Typora\typora-user-images\image-20220315234206480.png" alt="image-20220315234206480"></p>
<p><img src="C:\Users\hufei\AppData\Roaming\Typora\typora-user-images\image-20220315234836449.png" alt="image-20220315234836449"></p>
<p><img src="C:\Users\hufei\AppData\Roaming\Typora\typora-user-images\image-20220315235257760.png" alt="image-20220315235257760"></p>
<h2 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h2><h3 id="锁的分类"><a href="#锁的分类" class="headerlink" title="锁的分类"></a>锁的分类</h3><h4 id="全局锁"><a href="#全局锁" class="headerlink" title="全局锁"></a>全局锁</h4><p>要使用全局锁，则要执行这条命令：flush tables with read lock</p>
<p>执行后，<strong>整个数据库就处于只读状态了</strong>，这时其他线程执行以下操作，都会被阻塞：</p>
<ul>
<li>对数据的增删查改操作，比如 select、insert、delete、update等语句；</li>
<li>对表结构的更改操作，比如 alter table、drop table 等语句。</li>
</ul>
<p>如果要释放全局锁，则要执行这条命令：unlock tables。当然，当会话断开了，全局锁会被自动释放。</p>
<p><strong>应用场景</strong></p>
<p>全局锁主要应用于做<strong>全库逻辑备份</strong>，这样在备份数据库期间，不会因为数据或表结构的更新，而出现备份文件的数据与预期的不一样。</p>
<p>在全库逻辑备份期间，假设不加全局锁的场景，看看会出现什么意外的情况。</p>
<p>如果在全库逻辑备份期间，有用户购买了一件商品，一般购买商品的业务逻辑是会涉及到多张数据库表的更细，比如在用户表更新该用户的余额，然后在商品表更新被购买的商品的库存。</p>
<p>那么，有可能出现这样的顺序：</p>
<ol>
<li>先备份了用户表的数据；</li>
<li>然后有用户发起了购买商品的操作；</li>
<li>接着再备份商品表的数据。</li>
</ol>
<p>也就是在备份用户表和商品表之间，有用户购买了商品。</p>
<p>这种情况下，备份的结果是用户表中该用户的余额并没有扣除，反而商品表中该商品的库存被减少了，如果后面用这个备份文件恢复数据库数据的话，用户钱没少，而库存少了，等于用户白嫖了一件商品。</p>
<p><strong>缺点</strong></p>
<p>加上全局锁，意味着整个数据库都是只读状态。</p>
<p>那么如果数据库里有很多数据，备份就会花费很多的时间，关键是备份期间，业务只能读数据，而不能更新数据，这样会造成业务停滞。</p>
<p><strong>解决方法</strong></p>
<p>在可重复读的隔离级别下，即使其他事务更新了表的数据，也不会影响备份数据库时的 Read View，这样备份期间备份的数据一直是在开启事务时的数据。</p>
<p>备份数据库的工具是 mysqldump，在使用 mysqldump 时加上 <code>–single-transaction</code> 参数的时候，就会在备份数据库之前先开启事务。这种方法只适用于支持「可重复读隔离级别的事务」的存储引擎，如InnoDB</p>
<p>但是，对于 MyISAM 这种不支持事务的引擎，在备份数据库时就要使用全局锁的方法。</p>
<h4 id="表级锁"><a href="#表级锁" class="headerlink" title="表级锁"></a>表级锁</h4><p>MySQL 里面表级别的锁有这几种：</p>
<ul>
<li>表锁；</li>
<li>元数据锁（MDL）;</li>
<li>意向锁；</li>
<li>AUTO-INC 锁；</li>
</ul>
<h5 id="表锁"><a href="#表锁" class="headerlink" title="表锁"></a>表锁</h5><p>如果我们想对学生表（t_student）加表锁，可以使用下面的命令：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">/</span><span class="operator">/</span>表级别的共享锁，也就是读锁；</span><br><span class="line">lock tables t_student read;</span><br><span class="line"></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>表级别的独占锁，也就是写锁；</span><br><span class="line">lock tables t_stuent wirte;</span><br></pre></td></tr></table></figure>

<p>需要注意的是，表锁除了会限制别的线程的读写外，<strong>也会限制本线程接下来的读写操作</strong>。</p>
<p>也就是说如果本线程对学生表加了共享表锁，那么本线程接下来如果要对学生表执行写操作的语句，是会被阻塞的，当然其他线程对学生表进行写操作时也会被阻塞，直到锁被释放。</p>
<p>要释放表锁，可以使用下面这条命令，会释放当前会话的所有表锁：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unlock tables</span><br></pre></td></tr></table></figure>

<p>另外，当会话退出后，也会释放所有表锁。</p>
<h5 id="元数据锁（metadata-lock）"><a href="#元数据锁（metadata-lock）" class="headerlink" title="元数据锁（metadata lock）"></a><strong>元数据锁（metadata lock）</strong></h5><p>我们不需要显示的使用 MDL，因为当我们对数据库表进行操作时，会自动给这个表加上 MDL：</p>
<ul>
<li>对一张表进行 CRUD 操作时，加的是 <strong>MDL 读锁</strong>；</li>
<li>对一张表做结构变更操作的时候，加的是 <strong>MDL 写锁</strong>；</li>
</ul>
<p><strong>作用</strong></p>
<p>在MySQL5.5.3之前，有一个著名的bug#989，大致如下:</p>
<p>session1:<br>BEGIN;<br>INSERT INTO t … ;<br>COMMIT;</p>
<p>session2:<br>DROP TABLE t;</p>
<p>然而上面的操作流程在binlog记录的顺序是：<br>DROP TABLE t;</p>
<p>BEGIN;<br>INSERT INTO t … ;<br>COMMIT;</p>
<p>很显然备库执行binlog恢复数据时会先删除表t，然后执行insert 会报error，导致复制中断。为了解决该bug,MySQL 在5.5.3引入了MDL锁（metadata lock），来保护表的元数据信息，用于解决或者<strong>保证DDL操作与DML操作之间的一致性</strong>。</p>
<p>简单的例子，如果你在查询一个表的过程中，另外一个session对该表删除了一个列，那前面的查询到底该显示什么呢？事物中再次执行相同的语句还会和之前结果一致吗？为了防止这种情况，表查询开始MySQL会在表上加一个锁，来防止被别的session修改了表定义，这个锁就叫MDL</p>
<p><strong>与行锁的区别</strong></p>
<p>mdl是表级锁，是在server层加的，适用于所有存储引擎。<strong>mdl为了解决ddl和dml之间的冲突，而行锁则是解决dml内的冲突</strong>。所有的dml操作都会在表上加一个metadata读锁；所有的ddl操作都会在表上加一个metadata写锁。读锁和写锁的阻塞关系如下：</p>
<ul>
<li>读锁和写锁之间相互阻塞，即同一个表上的dml和ddl之间互相阻塞。</li>
<li>写锁和写锁之间互相阻塞，即两个session不能对表同时做表定义变更，需要串行操作。</li>
<li>读锁和读锁之间不会产生阻塞。也就是<strong>增删改查不会因为mdl产生阻塞</strong>，可以并发执行，日常工作中大家看到的dml之间的锁等待是innodb行锁引起的，和mdl无关。</li>
</ul>
<p><strong>MDL为什么会造成系统崩溃</strong></p>
<p>MDL申请锁是串行队列排队申请，若队列前有事务阻塞，则后面的事务则可能无法申请到锁。</p>
<p>如事务1对表t1执行一个简单的查询；事务2对t1加一个字段；事务3来对t1做一个查询；</p>
<p>若事务1没有提交，则会导致事务2的ddl操作被阻塞，事务3本身不会被事务1阻塞，但由于在锁队列中，事务2排队更早，它准备加的是MDL写锁，阻塞了事务3的读锁。如果t1是一个执行频繁的表，show processlist会发现大量waiting for table metadata lock的线程，数据库连接很快就会消耗完，导致业务系统无法正常响应。</p>
<p>最新版本的mysql已经解决了这个问题，事务2不会再阻塞事务3。</p>
<p><strong>MDL生命周期</strong></p>
<p>MDL 在语句执行前申请，事务提交后才会释放，这意味着<strong>事务执行期间，MDL 是一直持有的</strong>。若执行完语句就释放，可能会导致事务中途其他事务删除或改变表，无法保证一致性。</p>
<p><strong>注意事项</strong></p>
<ul>
<li>生产环境的任何大表或频繁操作的小表，ddl都要非常慎重，最好在业务低峰期执行。同时ddl前需要检测是否存在长事务，若有长事务最好先kill掉，不能会导致阻塞。</li>
<li>设计上要尽可能避免长事务，长事务不仅仅会带来各种锁问题，还好引起复制延迟&#x2F;回滚空间爆满等各类问题。</li>
<li>要及时提交事务，经常发现客户端设置了事务手工提交，但sql执行后忘记点击提交按钮，导致事务长时间无法提交。建议监控实例中的长事务，避免由于各种原因导致事务没有及时提交。</li>
</ul>
<h5 id="意向锁"><a href="#意向锁" class="headerlink" title="意向锁"></a>意向锁</h5><p>意向锁是一种<strong>快速判断表锁与之前可能存在的行锁冲突的机制</strong>，在添加行锁之前必须先申请意向锁。在添加表锁时会先查有没有意向锁，有则阻塞。</p>
<p><strong>表锁和行锁冲突</strong></p>
<p>事务A锁住了表中的<strong>一行</strong>，让这一行只能读，不能写。</p>
<p>之后，事务B申请<strong>整个表</strong>的写锁。</p>
<p>如果事务B申请成功，那么理论上它就能修改表中的任意一行，这与A持有的行锁是冲突的。</p>
<p>因此表锁在申请时除了判断表是否已被其他事务用表锁锁表，还需要遍历每行判断表中是否有某行已被行锁锁住，效率低。</p>
<p>那么有了意向锁，由于在对记录加行锁前，先会加上表级别的意向锁，那么在加表锁时，直接查该表是否有意向锁，如果有就意味着表里已经有记录被加了行锁，这样就不用去遍历表里的记录。</p>
<h5 id="AUTO-INC-锁"><a href="#AUTO-INC-锁" class="headerlink" title="AUTO-INC 锁"></a>AUTO-INC 锁</h5><p> AUTO-INC 锁是为了在插入数据时，保证声明 <code>AUTO_INCREMENT</code> 属性的字段可以连续递增。</p>
<p>AUTO-INC 锁是特殊的表锁机制，锁不是再一个事务提交后才释放，而是<strong>在执行完插入语句后就会立即释放。</strong></p>
<p><strong>在插入数据时，会加一个表级别的 AUTO-INC 锁</strong>，然后为被 <code>AUTO_INCREMENT</code> 修饰的字段赋值递增的值，等插入语句执行完成后，才会把 AUTO-INC 锁释放掉。</p>
<p>那么，一个事务在持有 AUTO-INC 锁的过程中，其他事务的如果要向该表插入语句都会被阻塞，从而保证插入数据时，被 <code>AUTO_INCREMENT</code> 修饰的字段的值是连续递增的。</p>
<p>但是， AUTO-INC 锁再对大量数据进行插入的时候，会影响插入性能，因为另一个事务中的插入会被阻塞。</p>
<p>因此， 在 MySQL 5.1.22 版本开始，InnoDB 存储引擎提供了一种<strong>轻量级的锁</strong>来实现自增。</p>
<p>一样也是在插入数据的时候，会为被 <code>AUTO_INCREMENT</code> 修饰的字段加上轻量级锁，<strong>然后给该字段赋值一个自增的值，就把这个轻量级锁释放了，而不需要等待整个插入语句执行完后才释放锁</strong>。</p>
<p>InnoDB 存储引擎提供了个 innodb_autoinc_lock_mode 的系统变量，是用来控制选择用 AUTO-INC 锁，还是轻量级的锁。</p>
<ul>
<li>当 innodb_autoinc_lock_mode &#x3D; 0，就采用 AUTO-INC 锁；</li>
<li>当 innodb_autoinc_lock_mode &#x3D; 2，就采用轻量级锁；</li>
<li>当 innodb_autoinc_lock_mode &#x3D; 1，这个是默认值，两种锁混着用，如果能够确定插入记录的数量就采用轻量级锁，不确定时就采用 AUTO-INC 锁。</li>
</ul>
<p>不过，当 innodb_autoinc_lock_mode &#x3D; 2 是性能最高的方式，但是会带来一定的问题。因为并发插入的存在，在每次插入时，自增长的值可能不是连续的，<strong>这在有主从复制的场景中是不安全的</strong>。</p>
<h4 id="行锁"><a href="#行锁" class="headerlink" title="行锁"></a>行锁</h4><p>InnoDB 引擎是支持行级锁的，而 MyISAM 引擎并不支持行级锁。</p>
<p><strong>InnoDB有三种行锁：</strong></p>
<p>1，Record Lock：单个行记录上的锁。包括共享锁和独占锁（不包括其他行，所以会出现幻读）</p>
<p>2，Gap Lock：间隙锁，锁定一个范围，但不包括记录本身。GAP锁的目的，是为了防止同一事务的两次当前读，出现幻读的情况。</p>
<p>3，Next-Key Lock：1+2，锁定记录本身和记录左边的间隙，即一个左开右闭区间。主要目的是解决幻读。</p>
<p>在查询时主动对记录加行锁，可以使用下面这两个方式：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">/</span><span class="operator">/</span>对读取的记录加共享锁</span><br><span class="line"><span class="keyword">select</span> ... lock <span class="keyword">in</span> share mode;</span><br><span class="line"></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>对读取的记录加独占锁</span><br><span class="line"><span class="keyword">select</span> ... <span class="keyword">for</span> <span class="keyword">update</span>;</span><br></pre></td></tr></table></figure>

<p>存储引擎还会在读写时会自动加锁，详情看InnoDB的事务隔离级别的实现。</p>
<p><strong>提高锁的性能</strong></p>
<p><strong>修改事务中操作的顺序可以提高性能</strong>。</p>
<p>在InnoDB事务中，行锁是在需要的时候才加上的，但并不是不需要了就立刻释放，而是要等到事务结束时才释放。这个就是两阶段锁协议。</p>
<p>如果你的事务中需要锁多个行，要把最可能造成锁冲突、最可能影响并发度的锁尽量往后放。</p>
<p>假设你负责实现一个电影票在线交易业务，顾客A要在影院B购买电影票。我们简化一点，这个业务需要涉及到以下操作：</p>
<ol>
<li>从顾客A账户余额中扣除电影票价；</li>
<li>给影院B的账户余额增加这张电影票价；</li>
<li>记录一条交易日志。</li>
</ol>
<p>也就是说，要完成这个交易，我们需要update两条记录，并insert一条记录。当然，为了保证交易的原子性，我们要把这三个操作放在一个事务中。那么，你会怎样安排这三个语句在事务中的顺序呢？</p>
<p>试想如果同时有另外一个顾客C要在影院B买票，那么这两个事务冲突的部分就是语句2了。因为它们要更新同一个影院账户的余额，需要修改同一行数据。</p>
<p>根据两阶段锁协议，不论你怎样安排语句顺序，所有的操作需要的行锁都是在事务提交的时候才释放的。所以，如果你把语句2安排在最后，比如按照3、1、2这样的顺序，那么影院账户余额这一行的锁时间就最少。这就最大程度地减少了事务之间的锁等待，提升了并发度。</p>
<h4 id="死锁和死锁检测"><a href="#死锁和死锁检测" class="headerlink" title="死锁和死锁检测"></a>死锁和死锁检测</h4><p>当并发系统中不同线程出现循环资源依赖，涉及的线程都在等待别的线程释放资源时，就会导致这几个线程都进入无限等待的状态，称为死锁。</p>
<p>以行锁为例：</p>
<table>
<thead>
<tr>
<th>事务A</th>
<th>事务B</th>
</tr>
</thead>
<tbody><tr>
<td>update t set k&#x3D;k+1 where id&#x3D;2</td>
<td></td>
</tr>
<tr>
<td></td>
<td>update t set k&#x3D;k+1 where id&#x3D;1</td>
</tr>
<tr>
<td>update t set k&#x3D;k+1 where id&#x3D;1</td>
<td></td>
</tr>
<tr>
<td></td>
<td>update t set k&#x3D;k+1 where id&#x3D;2</td>
</tr>
</tbody></table>
<p>这时候，事务A在等待事务B释放id&#x3D;1的行锁，而事务B在等待事务A释放id&#x3D;2的行锁。 事务A和事务B在互相等待对方的资源释放，就是进入了死锁状态。当出现死锁以后，有两种策略：</p>
<ul>
<li>一种策略是，直接进入等待，直到超时。这个超时时间可以通过参数innodb_lock_wait_timeout来设置。</li>
<li>另一种策略是，发起死锁检测，发现死锁后，主动回滚死锁链条中的某一个事务，让其他事务得以继续执行。将参数innodb_deadlock_detect设置为on，表示开启这个逻辑。</li>
</ul>
<p>在InnoDB中，innodb_lock_wait_timeout的默认值是50s，当出现死锁以后，第一个被锁住的线程要过50s才会超时退出，然后其他线程才有可能继续执行。时间过长。</p>
<p>若时间很短，比如1s。这样当出现死锁的时候，确实很快就可以解开，但如果不是死锁，而是简单的锁等待呢？所以，超时时间设置太短的话，会出现很多误伤。</p>
<p>正常情况下我们还是要采用第二种策略，即：<strong>主动死锁检测</strong>，而且innodb_deadlock_detect的默认值本身就是on。主动死锁检测在发生死锁的时候，是能够快速发现并进行处理的，但是它也是有额外负担的。每当一个事务被锁的时候，就要看看它所依赖的线程有没有被别人锁住，如此循环，最后判断是否出现了循环等待，也就是死锁。</p>
<p>如果所有事务都要更新同一行的场景，每个新来的被堵住的线程，都要判断会不会由于自己的加入导致了死锁，这是一个时间复杂度是O(n)的操作。假设有1000个并发线程要同时更新同一行，那么死锁检测操作就是100万这个量级的。这期间要消耗大量的CPU资源。</p>
<p><strong>死锁检测优化办法</strong></p>
<p>1.<strong>如果你能确保这个业务一定不会出现死锁，可以临时把死锁检测关掉。</strong>但是这种操作本身带有一定的风险</p>
<p>2.<strong>控制并发度。</strong>比如同一行同时最多只有10个线程在更新，那么死锁检测的成本很低，就不会出现这个问题。一个直接的想法就是，在客户端做并发控制。但是因为客户端很多，即使每个客户端控制到只有5个并发线程，汇总到数据库服务端以后，峰值并发数也可能会很高。因此，这个<strong>并发控制要做在数据库服务端</strong>。如果你有中间件，可以考虑在中间件实现；如果你的团队有能修改MySQL源码的人，也可以做在MySQL里面。基本思路就是，<strong>对于相同行的更新，在进入引擎之前排队</strong>。这样在InnoDB内部就不会有大量的死锁检测工作了。</p>
<p>3.<strong>从设计上优化</strong>。可以考虑通过将一行改成逻辑上的多行来减少锁冲突。还是以影院账户为例，可以考虑放在多条记录上，比如10个记录，影院的账户总额等于这10个记录的值的总和。这样每次要给影院账户加金额的时候，随机选其中一条记录来加。这样每次冲突概率变成原来的1&#x2F;10，可以减少锁等待个数，也就减少了死锁检测的CPU消耗。</p>
<h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><p><strong>一条sql语句默认为一个事务</strong></p>
<p><img src="C:\Users\hufei\AppData\Roaming\Typora\typora-user-images\image-20220316000331849.png" alt="image-20220316000331849"></p>
<h3 id="事务的四大特性"><a href="#事务的四大特性" class="headerlink" title="事务的四大特性"></a>事务的四大特性</h3><ol>
<li>原子性：原子性是指事务是一个不可分割的工作单位，事务中的操作要么全部成功，要么全部失败。部分操作失败时会进行回滚，从而保证原子性</li>
<li>一致性：事务执行的结果必须是使数据库从一个一致性状态变到另一个一致性状态。也就是说数据库应该只包含成功事务提交的结果时</li>
<li>隔离性：一个事务的执行不能其它事务干扰。多个并发事务之间要相互隔离</li>
<li>持久性：持久性是指一个事务一旦被提交，它对数据库中数据的改变就是永久性的，不能回滚。并且接下来即使数据库发生故障也不应该对其有任何影响。</li>
</ol>
<h3 id="事务的隔离级别"><a href="#事务的隔离级别" class="headerlink" title="事务的隔离级别"></a>事务的隔离级别</h3><p>事务隔离级别要实际解决的三大问题</p>
<ol>
<li><p>脏读：脏读指的是读到了其他事务未提交的数据，未提交意味着这些数据可能会回滚，也就是可能最终不会存到数据库中的数据。</p>
</li>
<li><p>不可重复读：不可重复读针对其他事务的update和delete操作。指的是在同一事务内，不同的时刻读到的同一批数据可能是不一样的，可能会受到其他事务的影响，比如其他事务改了这批数据并提交了。</p>
</li>
<li><p>幻读：针对的是其他事务的insert操作。在事务A中同样的查询在不同的时间产生了不同的结果，这就是幻读。原因是事务B中在两次查询间隔中间插入了新的数据。</p>
</li>
</ol>
<p>SQL 标准定义了四种隔离级别，MySQL 全都支持。这四种隔离级别分别是：</p>
<ol>
<li>读未提交（READ UNCOMMITTED）</li>
<li>读提交 （READ COMMITTED）</li>
<li>可重复读 （REPEATABLE READ）</li>
<li>串行化 （SERIALIZABLE）</li>
</ol>
<p>从上往下，隔离强度逐渐增强，性能逐渐变差。采用哪种隔离级别要根据系统需求权衡决定，其中，<strong>可重复读</strong>是 MySQL 的默认级别。</p>
<p>事务隔离其实就是为了解决上面提到的脏读、不可重复读、幻读这几个问题，下面展示了 4 种隔离级别对这三个问题的解决程度。</p>
<table>
<thead>
<tr>
<th>隔离级别</th>
<th>脏读</th>
<th>不可重复读</th>
<th>幻读</th>
</tr>
</thead>
<tbody><tr>
<td>读未提交</td>
<td>未解决</td>
<td>未解决</td>
<td>未解决</td>
</tr>
<tr>
<td>读提交</td>
<td>解决</td>
<td>未解决</td>
<td>未解决</td>
</tr>
<tr>
<td>可重复读</td>
<td>解决</td>
<td>解决</td>
<td>未解决</td>
</tr>
<tr>
<td>串行化</td>
<td>解决</td>
<td>解决</td>
<td>解决</td>
</tr>
</tbody></table>
<p>MySQL <strong>事务隔离其实是依靠锁来实现的</strong>，锁是通过索引来锁住记录的(每个表都至少有一个聚集索引)。加锁自然会带来性能的损失，因此隔离级别越高性能越差。</p>
<p>加行锁的过程要<strong>分有索引和无索引两种情况</strong>，有索引的情况，MySQL 直接就在索引数中找到了这行数据，然后干净利落的加上行锁就可以了。</p>
<p>无索引时MySQL 无法直接定位到这行数据。MySQL 会为这张表中所有行加行锁，在加上行锁后，MySQL 会进行一遍过滤，发现不满足的行就释放锁，最终只留下符合条件的行，因此更新无索引的数据非常影响性能。</p>
<h3 id="锁和事务详解"><a href="#锁和事务详解" class="headerlink" title="锁和事务详解"></a>锁和事务详解</h3><p>几个概念：</p>
<p><strong>锁定读</strong>：在一个事务中，主动给读加锁，如SELECT … LOCK IN SHARE MODE 和 SELECT … FOR UPDATE。分别加上了行共享锁和行排他锁。共享锁可以和共享锁共存，所以可以多事务同时读。排他锁独占，所以加了排他锁之后其他事务不可以读和写。</p>
<p><strong>一致性非锁定读</strong>：InnoDB在读提交和可重复读隔离级别处理SELECT语句的默认模式。一致性非锁定读不会对其访问的表设置任何锁，因此，在对表执行一致性非锁定读的同时，其它事务可以同时并发的读取或者修改它们。</p>
<p><strong>当前读</strong>：读取的是最新版本，像<strong>UPDATE、DELETE、INSERT、SELECT … LOCK IN SHARE MODE、SELECT … FOR UPDATE</strong>这些操作都是一种当前读，为什么叫当前读？就是它读取的是记录的最新版本，读取时还要保证其他并发事务不能修改当前记录，会对读取的记录进行加锁。</p>
<p><strong>快照读</strong>：读取的是快照版本，也就是历史版本，像不加锁的<strong>SELECT</strong>操作就是快照读，即不加锁的非阻塞读；</p>
<p><strong>隐式锁定</strong>：InnoDB在事务执行过程中，使用两阶段锁协议（不主动进行显示锁定的情况）：</p>
<ul>
<li>随时都可以执行锁定，InnoDB会根据隔离级别在需要的时候自动加锁；</li>
<li>锁只有在执行commit或者rollback的时候才会释放，并且所有的锁都是在同一时刻被释放。</li>
</ul>
<p><strong>显式锁定</strong>：如SELECT … LOCK IN SHARE MODE 和 SELECT … FOR UPDATE（存储引擎层）；lock table和unlock table（server层）</p>
<p><strong>InnoDB有三种行锁的算法：</strong></p>
<p>1，Record Lock：单个行记录上的锁。（不包括其他行，所以会出现幻读）</p>
<p>2，Gap Lock：间隙锁，锁定一个范围，但不包括记录本身。GAP锁的目的，是为了防止同一事务的两次当前读，出现幻读的情况。</p>
<p>3，Next-Key Lock：1+2，锁定记录本身和记录左边的间隙，即一个左开右闭区间。主要目的是解决幻读。</p>
<p><strong>InnoDB的事务具体实现</strong></p>
<table>
<thead>
<tr>
<th>事务隔离级别</th>
<th>实现方式</th>
</tr>
</thead>
<tbody><tr>
<td>未提交读（RU）</td>
<td>事务对当前被读取的数据不加锁，都是<strong>当前读</strong>；  事务在更新某数据的瞬间（就是发生更新的瞬间），必须先对其加<strong>行级共享锁</strong>，直到事务结束才释放。</td>
</tr>
<tr>
<td>提交读（RC）</td>
<td>事务对当前被读取的数据不加锁，且是<strong>快照读</strong>；  事务在更新某数据的瞬间（就是发生更新的瞬间），必须先对其加<strong>行级排他锁（Record）</strong>，直到事务结束才释放。</td>
</tr>
<tr>
<td>可重复读（RR）</td>
<td>事务对当前被读取的数据不加锁，且是<strong>快照读</strong>；  事务在更新某数据的瞬间（就是发生更新的瞬间），必须先对其加<strong>行级排他锁（Record，GAP，Next-Key）</strong>，直到事务结束才释放。  <strong>通过间隙锁，在这个级别MySQL就解决了幻读的问题</strong>  <strong>通过快照，在这个级别MySQL就解决了不可重复读的问题</strong></td>
</tr>
<tr>
<td>序列化读（S）</td>
<td>事务在读取数据时，必须先对其加<strong>表级共享锁</strong> ，直到事务结束才释放，都是<strong>当前读</strong>；  事务在更新数据时，必须先对其加<strong>表级排他锁</strong> ，直到事务结束才释放。</td>
</tr>
</tbody></table>
<p><strong>RR级别的锁都是next-key锁，可以解决幻读的问题，但是需要主动加锁</strong>。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">begin</span>;</span><br><span class="line"></span><br><span class="line">#假设users表为空，下面查出来的数据为空</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> users lock <span class="keyword">in</span> share mode; #加上共享锁</span><br><span class="line"></span><br><span class="line">#此时另一个事务B想提交且插入了一条id<span class="operator">=</span><span class="number">1</span>的数据，由于有间隙锁，所以要等待</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> users; #读快照，查出来的数据为空</span><br><span class="line"></span><br><span class="line"><span class="keyword">update</span> users <span class="keyword">set</span> name<span class="operator">=</span><span class="string">&#x27;mysql&#x27;</span> <span class="keyword">where</span> id<span class="operator">=</span><span class="number">1</span>;#<span class="keyword">update</span>是当前读，由于不存在数据，不进行更新</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> users; #读快照，查出来的数据为空</span><br><span class="line"></span><br><span class="line"><span class="keyword">commit</span>;</span><br><span class="line"></span><br><span class="line">#事务B提交成功并插入数据</span><br></pre></td></tr></table></figure>

<h3 id="mvcc（多版本并发控制）"><a href="#mvcc（多版本并发控制）" class="headerlink" title="mvcc（多版本并发控制）"></a>mvcc（多版本并发控制）</h3><p>需要mvcc的原因：锁住一个资源后会禁止其他任何线程访问同一个资源。但是很多应用的一个特点都是读多写少的场景——&gt;使用了一种读写锁的方法，读锁和读锁之间不互斥，而写锁和写锁、读锁都互斥——&gt;让读写之间也不冲突的方法，就是读取数据时通过一种类似快照的方式将数据保存下来，这样读锁就和写锁不冲突了，不同的事务session会看到自己特定版本的数据。</p>
<p>mvcc：对于Mysql中的每一个数据行都有可能存在多个版本，在每次事务更新数据的时候都会同时记录undo log（未提交的也会记录undo log），并且把自己的事务id赋值给当前版本的row trx_id。记录上的最新值，通过回滚操作，都可以得到前一个版本的值。这就是mvcc</p>
<p>假如三个事务更新了同一行数据，那么就会有对应的三个数据版本。</p>
<p><img src="C:\Users\hufei\AppData\Roaming\Typora\typora-user-images\image-20220317221606939.png" alt="image-20220317221606939"></p>
<p>系统会判断，<strong>当没有事务再需要用到这些回滚日志时，回滚日志会被删除。</strong>就是当系统里没有比这个回滚日志更早的视图的时候。</p>
<p>因此最好避免使用长事务，长事务意味着系统里面会存在很老的事务视图。由于这些事务随时可能访问数据库里面的任何数据，所以这个事务提交之前，数据库里面它可能用到的回滚记录都必须保留，这就会导致大量占用存储空间。</p>
<p>不同时刻启动的事务会有不同的快照，记录数据的值。</p>
<p>在实现可重复读的隔离级别，只需要在<strong>事务开始的时候创建快照</strong>，之后的查询里都共用这个快照，后续的事务对数据的更改是对当前事务是不可见的，这样就实现了可重复读。</p>
<p>而读提交，每一个<strong>语句执行前都会重新计算</strong>出一个新的快照。</p>
<h3 id="快照原理"><a href="#快照原理" class="headerlink" title="快照原理"></a>快照原理</h3><p>快照并非为每个事务存储真正的行数据，而是而是每次需要的时候根据当前版本和undo log计算出来的。</p>
<p>InnoDB为每个事务构造了一个活跃事务数组，用来保存这个事务启动瞬间，当前正在“活跃”的所有事务ID。“活跃”指的就是，启动了但还没提交。</p>
<p>譬如数组为[47,49,52]，事务id为60，那么小于47的事务都已经提交，对事务60来说是可见的；id大于60的事务还未创建，是不可见的。</p>
<p>对于<strong>可重复读，这个数组不会变</strong>；而<strong>读提交则会在每次读取时更新活跃数组</strong>；</p>
<p>可重复读事务创建时，就要顺着undo log往前找，直到找到某个版本的事务id小于60并且不在活跃数组中，这个版本的数据就是事务的快照。</p>
<p>而读提交事务每次读取数据时，先会更新活跃数组，然后顺着undo log往前找，直到找到某个版本的事务不在活跃数组中即可。</p>
<p>需要注意快照不适用于并发写的情况，因为写的时候(如update k&#x3D;k+1)需要读取最新版本的数据，并且会给版本加排他锁（不影响读其他版本的数据），等到事务结束才释放。</p>
<p><img src="C:\Users\hufei\AppData\Roaming\Typora\typora-user-images\b7bd3c773392176bba242235f4da000f.webp" alt="b7bd3c773392176bba242235f4da000f"></p>
<p>如B读到的数据是3而不是2。</p>
<h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><h3 id="索引结构优劣分析"><a href="#索引结构优劣分析" class="headerlink" title="索引结构优劣分析"></a>索引结构优劣分析</h3><p>设计一个适合 MySQL 索引的数据结构，至少满足以下要求：</p>
<ul>
<li>能在尽可能少的磁盘的 I&#x2F;O 操作中完成查询工作；</li>
<li>要能高效地查询某一个记录，也要能高效地执行范围查找；</li>
</ul>
<p><strong>数组</strong></p>
<p>优点：查询最快，可用二分查找</p>
<p>缺点：维护困难，插入删除效率低。适合存储静态数据，比如你要保存的是2017年某个城市的所有人口信息，这类不会再修改的数据。</p>
<p><strong>红黑树，avl树</strong></p>
<p>优点：相比数组维护简单，插入删除效率高</p>
<p>缺点：一个节点只能有两个子节点，树过高，需要的I&#x2F;O操作多</p>
<p><strong>哈希表</strong></p>
<p>优点：查询速度快</p>
<p>缺点：只支持精确匹配，不支持范围查询；不支持根据索引排序</p>
<p><strong>B树</strong></p>
<p>优点：多叉树，树的高度低，磁盘I&#x2F;O次数少</p>
<p>缺点： B 树的每个节点都包含数据（索引+记录），而用户的记录数据的大小很有可能远远超过了索引数据，这就需要花费更多的磁盘 I&#x2F;O 操作次数来读到有用的索引数据。因此B树的查询速度不平均，有可能很快，有可能很慢； B 树做范围查询，需要使用中序遍历，这会涉及多个节点的磁盘 I&#x2F;O 问题，从而导致整体速度下降；B树插入和删除可能发生树变形，效率低</p>
<p><strong>B+树</strong></p>
<p>优点：记录都保存在叶子节点，相比B树，每个节点索引更多，树更矮，磁盘I&#x2F;O次数少，查询速度平均；记录用双向链表相连，支持范围查询和排序；存在冗余节点，插入和删除不会发生严重的树变形，相比B树效率更高</p>
<p>缺点：单记录查询平均I&#x2F;O次数相比B树更多(因此mongodb使用B树。不使用哈希表是因为哈希表范围查询太慢，做了综合考虑)</p>
<h3 id="自增主键的好处"><a href="#自增主键的好处" class="headerlink" title="自增主键的好处"></a>自增主键的好处</h3><p>自增主键的插入数据模式，正符合了我们前面提到的递增插入的场景。每次插入一条新记录，都是追加操作，都不涉及到挪动其他记录，也不会触发叶子节点的分裂。</p>
<p>而有业务逻辑的字段做主键，则往往不容易保证有序插入，这样写数据成本相对较高。</p>
<p>除了考虑性能外，我们还可以从存储空间的角度来看。假设你的表中确实有一个唯一字段，比如字符串类型的身份证号，那应该用身份证号做主键，还是用自增字段做主键呢？</p>
<p>由于每个二级索引的叶子节点上都是主键的值。如果用身份证号做主键，那么每个二级索引的叶子节点占用约20个字节，而如果用整型做主键，则只要4个字节，如果是长整型（bigint）则是8个字节。</p>
<p><strong>显然，主键长度越小，普通索引的叶子节点就越小，普通索引占用的空间也就越小。</strong></p>
<p>所以，从性能和存储空间方面考量，自增主键往往是更合理的选择。</p>
<p>有没有什么场景适合用业务字段直接做主键的呢？还是有的。比如，有些业务的场景需求是这样的：</p>
<ol>
<li>只有一个索引；</li>
<li>该索引必须是唯一索引。</li>
</ol>
<p>你一定看出来了，这就是典型的KV场景。</p>
<p>由于没有其他索引，所以也就不用考虑其他索引的叶子节点大小的问题。</p>
<p>索引结构：</p>
<table>
<thead>
<tr>
<th>索引结构</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>b+树</td>
<td>最常见的索引类型，大部分引擎支持</td>
</tr>
<tr>
<td>hash索引</td>
<td>用哈希表实现，只支持精确匹配，不支持范围查询</td>
</tr>
<tr>
<td>R-tree(空间索引)</td>
<td>MyISAM引擎的一个特殊索引，主要用于地理空间数据类型，使用少</td>
</tr>
<tr>
<td>Full-text(全文索引)</td>
<td>是一种通过建立倒排索引，快速匹配文档的方式</td>
</tr>
</tbody></table>
<p>各引擎支持索引：</p>
<table>
<thead>
<tr>
<th>索引</th>
<th>InnoDB</th>
<th>MyISAM</th>
<th>Memory</th>
</tr>
</thead>
<tbody><tr>
<td>B+tree索引</td>
<td>支持</td>
<td>支持</td>
<td>支持</td>
</tr>
<tr>
<td>Hash索引</td>
<td>不支持(在指定条件下会自动构建)</td>
<td>不支持</td>
<td>支持</td>
</tr>
<tr>
<td>R-tree</td>
<td>不支持</td>
<td>支持</td>
<td>不支持</td>
</tr>
<tr>
<td>Full-text</td>
<td>5.6版本后支持</td>
<td>支持</td>
<td>不支持</td>
</tr>
</tbody></table>
<p><img src="C:\Users\hufei\AppData\Roaming\Typora\typora-user-images\image-20220318232645585.png" alt="image-20220318232645585"></p>
<p><img src="C:\Users\hufei\AppData\Roaming\Typora\typora-user-images\image-20220318232725678.png" alt="image-20220318232725678"></p>
<p><img src="C:\Users\hufei\AppData\Roaming\Typora\typora-user-images\image-20220318232828330.png" alt="image-20220318232828330"></p>
<p><img src="C:\Users\hufei\AppData\Roaming\Typora\typora-user-images\image-20220318232941993.png" alt="image-20220318232941993"></p>
<h3 id="索引分类"><a href="#索引分类" class="headerlink" title="索引分类"></a>索引分类</h3><table>
<thead>
<tr>
<th>分类</th>
<th>含义</th>
<th>特点</th>
<th>关键字</th>
</tr>
</thead>
<tbody><tr>
<td>主键索引</td>
<td>针对表中主键创建的索引</td>
<td>默认自动创建，只能有一个</td>
<td>PRIMARY</td>
</tr>
<tr>
<td>唯一索引</td>
<td>针对UNIQUE列创建的索引</td>
<td>可以有多个</td>
<td>UNIQUE</td>
</tr>
<tr>
<td>常规索引</td>
<td>快速定位数据</td>
<td>可以有多个</td>
<td></td>
</tr>
<tr>
<td>全文索引</td>
<td>查找文本关键词，而不是比较值</td>
<td>可以有多个</td>
<td>FULLTEXT</td>
</tr>
</tbody></table>
<p>在InnoDB引擎中，根据索引存储形式又可以分为聚集索引和二级索引</p>
<p><strong>聚集索引</strong>：索引的叶子节点保存的是行数据，必须有且只能有一个聚集索引。有主键时主键索引就是聚集索引，没有时第一个唯一索引就是聚集索引，二者都无时自动创建自增主键作为聚集索引。</p>
<p><strong>二级索引</strong>：普通索引，索引的叶子节点存储的是聚集索引的值。可以有多个。</p>
<p>注意，二级索引存放的是聚集索引的索引值（一般也就是行数据对应主键的值），因此得到主键值之后还需要用主键值去聚集索引中再查询一次得到行数据。在这个过程中，<strong>回到主键索引树搜索的过程，我们称为回表</strong>。</p>
<h3 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h3><p>若在查询中避免了回表的过程，就是覆盖索引。如执行的语句是select ID from T where k between 3 and 5，id是主键，已经存放在了二级索引树上，因此只需要查询一次二级索引就可以得到结果。</p>
<p>由于覆盖索引可以减少树的搜索次数，显著提升查询性能，所以<strong>使用覆盖索引是一个常用的性能优化手段</strong>。</p>
<p><strong>除了查询主键的情况还有什么办法可以使用到覆盖索引呢？</strong></p>
<p>如在一个市民表上需要查询市民的身份证号和名字，那么我们可以将身份证号和名字建立一个联合索引，那么二级索引的叶子节点上就包括了身份证号和名字，无需再回表查询了。</p>
<p>当然增加索引会造成额外的维护代价，需要综合考虑。</p>
<h3 id="联合索引"><a href="#联合索引" class="headerlink" title="联合索引"></a>联合索引</h3><p>多个普通字段组合在一起创建的索引就叫做联合索引</p>
<p><img src="C:\Users\hufei\AppData\Roaming\Typora\typora-user-images\index.png" alt="image-20220319032542383"></p>
<p>索引会先根据第一个索引列排序，如果相同，再根据后面的索引列进行排序。</p>
<h3 id="最左前缀原则"><a href="#最左前缀原则" class="headerlink" title="最左前缀原则"></a>最左前缀原则</h3><p>在通过联合索引检索数据时，从索引中最左边的列开始，一直向右匹配，并且不跳过索引中的列。</p>
<p>比如，如果创建了一个 <code>(a, b, c)</code> 联合索引，如果查询条件是以下这几种，就可以匹配上联合索引：</p>
<ul>
<li>where a&#x3D;1；</li>
<li>where a&#x3D;1 and b&#x3D;2 and c&#x3D;3；</li>
<li>where a&#x3D;1 and b&#x3D;2；</li>
</ul>
<p>需要注意的是，因为<strong>有查询优化器</strong>，所以 <strong>a 字段在 where 子句的顺序并不重要</strong>。</p>
<p>但是，如果查询条件是以下这几种，因为不符合最左匹配原则，所以就无法匹配上联合索引，联合索引就会失效:</p>
<ul>
<li>where b&#x3D;2；</li>
<li>where c&#x3D;3；</li>
<li>where b&#x3D;2 and c&#x3D;3；</li>
</ul>
<h3 id="索引下推"><a href="#索引下推" class="headerlink" title="索引下推"></a>索引下推</h3><p>索引下推功能，可以在索引遍历过程中，在存储引擎层对索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数。</p>
<p>假设我们想从一开始创建的表中，查询 name 以 ‘L’ 开头，并且 age 为 17 的人员信息。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t_user <span class="keyword">where</span> name <span class="keyword">like</span> <span class="string">&#x27;L%&#x27;</span> <span class="keyword">and</span> age <span class="operator">=</span> <span class="number">17</span>;</span><br></pre></td></tr></table></figure>

<p>在不用索引下推的情况下，根据前边”最左匹配原则”描述的那样，该查询在联合索引中只有 name 列可以使用到索引，age 列是用不到索引的。在扫描 (‘name’, age) 索引树时，根据 name like ‘L%’ 这个条件，可以查找到 LiLei、Lili、Lisa、Lucy 四条索引数据，接下来，再根据这四条索引数据中的 id 值，逐一进行回表扫描，从聚簇索引中找到相应的行数据，将找到的行数据返回给 server 层。server 层中，再根据 age &#x3D; 17 这个条件进行筛选，最终只留下 Lucy 用户的数据信息。</p>
<p>在使用索引下推的情况下，存储引擎层还是先根据 name like ‘L%’ 这个条件，查找到 LiLei、Lili、Lisa、Lucy 四条索引数据，不过接下来不是直接进行回表操作，而是根据 age &#x3D; 17 这个条件，对四条索引数据进行判断筛选，将符合条件的索引对应的 id 进行回表扫描，最终将找到的行数据返回给 server 层。（也就是我们把本应该在 server 层进行筛选的条件，下推到存储引擎层来进行筛选判断了。这个下推的前提是索引中有 age 列信息，如果是其它条件，如 gender &#x3D; 0，这个即使下推下来也没用）</p>
<p>使用索引下推优化，可以有效减少回表次数，也可以减少 server 层从存储引擎层接收数据的次数，从而大大提升查询效率。</p>
<h3 id="唯一索引和普通索引的选择"><a href="#唯一索引和普通索引的选择" class="headerlink" title="唯一索引和普通索引的选择"></a>唯一索引和普通索引的选择</h3><p>假设你在维护一个市民系统，每个人都有一个唯一的身份证号，而且业务代码已经保证了不会写入两个重复的身份证号。如果市民系统需要按照身份证号查姓名，就会执行类似这样的SQL语句：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select name from CUser where id_card = &#x27;xxxxxxxyyyyyyzzzzz&#x27;;</span><br></pre></td></tr></table></figure>

<p>此时选择普通索引还是唯一索引</p>
<p><strong>查询性能分析</strong></p>
<p>查询时两种索引性能差距很小。</p>
<p>假设，执行查询的语句是 select id from T where k&#x3D;5。这个查询语句在索引树上查找的过程，先是通过B+树从树根开始，按层搜索到叶子节点，也就是图中右下角的这个数据页，然后可以认为<strong>数据页内部通过二分法来定位记录</strong>（所以不同的索引节点不能放在同一页）。</p>
<ul>
<li>对于普通索引来说，查找到满足条件的第一个记录(5,500)后，需要查找下一个记录，直到碰到第一个不满足k&#x3D;5条件的记录。</li>
<li>对于唯一索引来说，由于索引定义了唯一性，查找到第一个满足条件的记录后，就会停止继续检索。</li>
</ul>
<p>那么，这个不同带来的性能差距会有多少呢？<strong>答案是，微乎其微。</strong></p>
<p>你知道的，InnoDB的数据是按数据页为单位来读写的。也就是说，当需要读一条记录的时候，并不是将这个记录本身从磁盘读出来，而是以页为单位，将其整体读入内存。在InnoDB中，每个数据页的大小默认是16KB。</p>
<p>因为引擎是按页读写的，所以说，当找到k&#x3D;5的记录的时候，它所在的数据页就都在内存里了。那么，对于普通索引来说，要多做的那一次“查找和判断下一条记录”的操作，就只需要一次指针寻找和一次计算。</p>
<p>当然，如果k&#x3D;5这个记录刚好是这个数据页的最后一个记录，那么要取下一个记录，必须读取下一个数据页，这个操作会稍微复杂一些。</p>
<p>但是，我们之前计算过，对于整型字段，一个数据页可以放近千个key，因此出现这种情况的概率会很低。所以，我们计算平均性能差异时，仍可以认为这个操作成本对于现在的CPU来说可以忽略不计。</p>
<p><strong>更新性能分析</strong></p>
<p>更新时由于change buffer的存在，在写多读少的业务场景下最好选择普通索引</p>
<h3 id="索引失效"><a href="#索引失效" class="headerlink" title="索引失效"></a>索引失效</h3><p>1.<strong>对索引列使用函数</strong></p>
<p>当我们在查询条件中对索引列使用函数，就会导致索引失效。</p>
<p>因为索引保存的是索引字段的原始值，而不是经过函数计算后的值，自然就没办法走索引了。</p>
<p>不过，从 MySQL 8.0 开始，索引特性增加了函数索引，即可以针对函数计算后的值建立一个索引，也就是说该索引的值是函数计算后的值，所以就可以通过扫描索引来查询数据。</p>
<p>举个例子，我通过下面这条语句，对 length(name) 的计算结果建立一个名为 idx_name_length 的索引。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> t_user <span class="keyword">add</span> key idx_name_length ((length(name)));</span><br></pre></td></tr></table></figure>

<p>2.<strong>对索引列进行表达式计算</strong></p>
<p>在查询条件中对索引进行表达式计算，也是无法走索引的。</p>
<p>比如，下面这条查询语句</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t_user <span class="keyword">where</span> id <span class="operator">+</span> <span class="number">1</span> <span class="operator">=</span> <span class="number">10</span>;</span><br></pre></td></tr></table></figure>

<p>但是，如果把查询语句的条件<strong>改成 where id &#x3D; 10 - 1</strong>，这样就不是在索引字段进行表达式计算了，于是就可以走索引查询了。</p>
<p>原因在索引保存的是索引字段的原始值，而不是 id + 1 表达式计算后的值，所以无法走索引</p>
<p>当然mysql可以进行特殊处理求出索引字段原始值，但是表达式计算的情况多种多样，每种都要考虑的话，代码可能会很臃肿，所以mysql没有这样做。</p>
<p>3.<strong>对索引使用头部模糊匹配</strong></p>
<p>当我们使用头部模糊匹配的时候，也就是 <code>like %xx</code> 或者 <code>like %xx%</code> 这两种方式都会造成索引失效。</p>
<p>如name like ‘林%’有效，name like ‘%林’则会失效</p>
<p>因为索引 B+ 树是按照索引值有序排列存储的，只能根据前缀进行比较。</p>
<p>4.<strong>字符串不加引号</strong></p>
<p>MySQL 在遇到字符串和数字比较的时候，会自动把字符串转为数字，然后再进行比较。</p>
<p>如果字符串是索引列，而条件语句中的输入参数是数字的话，那么索引列会发生隐式类型转换，由于隐式类型转换是通过 CAST 函数实现的，等同于对索引列使用了函数，所以就会导致索引失效。</p>
<p>失效例子：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t_user <span class="keyword">where</span> phone <span class="operator">=</span> <span class="number">1300000001</span>;<span class="operator">/</span><span class="operator">/</span>phone是字符串</span><br></pre></td></tr></table></figure>

<p>phone 字段为字符串，所以 MySQL 要会自动把字符串转为数字，所以这条语句相当于：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t_user <span class="keyword">where</span> <span class="built_in">CAST</span>(phone <span class="keyword">AS</span> signed <span class="type">int</span>) <span class="operator">=</span> <span class="number">1300000001</span>;</span><br></pre></td></tr></table></figure>

<p>可以看到，CAST 函数是作用在了 phone 字段，而 phone 字段是索引，也就是<strong>对索引使用了函数</strong>！而前面我们也说了，对索引使用函数是会导致索引失效的。</p>
<p>不失效例子：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t_user <span class="keyword">where</span> id <span class="operator">=</span> &quot;1&quot;;<span class="operator">/</span><span class="operator">/</span>id是数字</span><br></pre></td></tr></table></figure>

<p>这时因为字符串部分是输入参数，也就需要将字符串转为数字，所以这条语句相当于：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t_user <span class="keyword">where</span> id <span class="operator">=</span> <span class="built_in">CAST</span>(&quot;1&quot; <span class="keyword">AS</span> signed <span class="type">int</span>);</span><br></pre></td></tr></table></figure>

<p>可以看到，索引字段并没有用任何函数，CAST 函数是用在了输入参数，因此是可以走索引扫描的。</p>
<p>5.<strong>WHERE 子句中 OR 前的条件列是索引列，而在 OR 后的条件列不是索引列</strong></p>
<p>举个例子，比如下面的查询语句，id 是主键，age 是普通列，从执行计划的结果看，是走了全表扫描。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t_user <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1</span> <span class="keyword">or</span> age <span class="operator">=</span> <span class="number">18</span>;</span><br></pre></td></tr></table></figure>

<p>这是因为 OR 的含义就是两个只要满足一个即可，因此两个条件的记录都要查询，然后进行合并。只要有条件列不是索引列，就会进行全表扫描。</p>
<p>6.<strong>联合索引不遵守最左前缀法则</strong></p>
<p>7.<strong>联合索引范围查询(&gt;、&lt;、between、like等)</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> testTable <span class="keyword">where</span> a<span class="operator">&gt;</span><span class="number">1</span> <span class="keyword">and</span> b<span class="operator">=</span><span class="number">2</span></span><br></pre></td></tr></table></figure>

<p>首先a字段在B+树上是有序的，所以可以用二分查找法定位到1，然后将所有大于1的数据取出来，a可以用到索引。</p>
<p>b有序的前提是a是确定的值，那么现在a的值是取大于1的，可能有10个大于1的a，也可能有一百个a。</p>
<p>大于1的a那部分的B+树里，b字段是无序的，所以<strong>b不能用二分查找来查询</strong>，b用不到索引。（索引失效关键在于能不能使用二分查找）</p>
<p>8.<strong>优化器导致索引失效</strong></p>
<p>因为回表的原因，走索引效率不一定更高。优化器会判断走索引和全表扫描谁的效率高，若全表扫描更高时不会走索引</p>
<p><img src="C:\Users\hufei\AppData\Roaming\Typora\typora-user-images\image-20220319034349465.png" alt="image-20220319034349465"></p>
<p><img src="C:\Users\hufei\AppData\Roaming\Typora\typora-user-images\image-20220319035020522.png" alt="image-20220319035020522"></p>
<p><img src="C:\Users\hufei\AppData\Roaming\Typora\typora-user-images\image-20220319035416073.png" alt="image-20220319035416073"></p>
<p><img src="C:\Users\hufei\AppData\Roaming\Typora\typora-user-images\image-20220319035556705.png" alt="image-20220319035556705"></p>
<h3 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h3><p><code>show global status like &#39;Com______&#39;</code>&#x2F;&#x2F;查询数据库增删改查各自的访问频次</p>
<p><img src="C:\Users\hufei\AppData\Roaming\Typora\typora-user-images\image-20220319030133337.png" alt="image-20220319030133337"></p>
<p><img src="C:\Users\hufei\AppData\Roaming\Typora\typora-user-images\image-20220319030637629.png" alt="image-20220319030637629"></p>
<p><img src="C:\Users\hufei\AppData\Roaming\Typora\typora-user-images\image-20220319031045669.png" alt="image-20220319031045669"></p>
<h3 id="sql优化"><a href="#sql优化" class="headerlink" title="sql优化"></a>sql优化</h3><h4 id="插入优化"><a href="#插入优化" class="headerlink" title="插入优化"></a>插入优化</h4><p><img src="C:\Users\hufei\AppData\Roaming\Typora\typora-user-images\image-20220320212637861.png" alt="image-20220320212637861"></p>
<p>插入大批量数据使用load</p>
<h4 id="主键优化"><a href="#主键优化" class="headerlink" title="主键优化"></a>主键优化</h4><p><img src="C:\Users\hufei\AppData\Roaming\Typora\typora-user-images\image-20220320213439189.png" alt="image-20220320213439189"></p>
<p><img src="C:\Users\hufei\AppData\Roaming\Typora\typora-user-images\image-20220320213503174.png" alt="image-20220320213503174"></p>
<p><img src="C:\Users\hufei\AppData\Roaming\Typora\typora-user-images\image-20220320213613180.png" alt="image-20220320213613180"></p>
<h4 id="排序优化"><a href="#排序优化" class="headerlink" title="排序优化"></a>排序优化</h4><p><img src="C:\Users\hufei\AppData\Roaming\Typora\typora-user-images\image-20220320214021525.png" alt="image-20220320214021525"></p>
<h4 id="分组优化"><a href="#分组优化" class="headerlink" title="分组优化"></a>分组优化</h4><p><img src="C:\Users\hufei\AppData\Roaming\Typora\typora-user-images\image-20220320214238071.png" alt="image-20220320214238071"></p>
<h4 id="limit优化"><a href="#limit优化" class="headerlink" title="limit优化"></a>limit优化</h4><p><img src="C:\Users\hufei\AppData\Roaming\Typora\typora-user-images\image-20220320214906293.png" alt="image-20220320214906293"></p>
<h4 id="count优化"><a href="#count优化" class="headerlink" title="count优化"></a>count优化</h4><p><img src="C:\Users\hufei\AppData\Roaming\Typora\typora-user-images\image-20220320215359582.png" alt="image-20220320215359582"></p>
<p><img src="C:\Users\hufei\AppData\Roaming\Typora\typora-user-images\image-20220320215330621.png" alt="image-20220320215330621"></p>
<h4 id="update优化"><a href="#update优化" class="headerlink" title="update优化"></a>update优化</h4><p><img src="C:\Users\hufei\AppData\Roaming\Typora\typora-user-images\image-20220320220409456.png" alt="image-20220320220409456"></p>
<h3 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h3><p><img src="C:\Users\hufei\AppData\Roaming\Typora\typora-user-images\image-20220320221846951.png" alt="image-20220320221846951"></p>
<p><img src="C:\Users\hufei\AppData\Roaming\Typora\typora-user-images\image-20220320221528463.png" alt="image-20220320221528463"></p>

      
       <hr><span style="font-style: italic;color: gray;"> 转载请注明来源，欢迎对文章中的引用来源进行考证，欢迎指出任何有错误或不够清晰的表达。可以在下面评论区评论，也可以邮件至 jaytp@qq.com </span>
    </div>
</article>


<p>
    <a  class="dashang" onclick="dashangToggle()">💰</a>
</p>






    




    </div>
    <div class="copyright">
        <p class="footer-entry">
    ©2016-2020 Yelog
</p>
<p class="footer-entry">Built with <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/yelog/hexo-theme-3-hexo" target="_blank">3-hexo</a> theme</p>

    </div>
    <div class="full-toc">
        <button class="full" data-title="切换全屏 快捷键 s"><span class="min "></span></button>
<a class="" id="rocket" ></a>

    </div>
</div>

<div class="hide_box" onclick="dashangToggle()"></div>
<div class="shang_box">
    <a class="shang_close"  onclick="dashangToggle()">×</a>
    <div class="shang_tit">
        <p>Help us with donation</p>
    </div>
    <div class="shang_payimg">
        <div class="pay_img">
            <img src="/img/alipay.jpg" class="alipay" title="扫码支持">
            <img src="/img/weixin.jpg" class="weixin" title="扫码支持">
        </div>
    </div>
    <div class="shang_payselect">
        <span><label><input type="radio" name="pay" checked value="alipay">alipay</label></span><span><label><input type="radio" name="pay" value="weixin">weixin</label></span>
    </div>
</div>


</body>
<script src="/js/jquery.pjax.js?v=1.1.0" ></script>

<script src="/js/script.js?v=1.1.0" ></script>
<script>
    var img_resize = 'default';
    function initArticle() {
        /*渲染对应的表格样式*/
        
            $("#post .pjax table").addClass("green_title");
        

        /*渲染打赏样式*/
        
        $("input[name=pay]").on("click", function () {
            if($("input[name=pay]:checked").val()=="weixin"){
                $(".shang_box .shang_payimg .pay_img").addClass("weixin_img");
            } else {
                $(".shang_box .shang_payimg .pay_img").removeClass("weixin_img");
            }
        })
        

        /*高亮代码块行号*/
        

        /*访问数量*/
        
        $.getScript("//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js");
        

        /*代码高亮，行号对齐*/
        $('.pre-numbering').css('line-height',$('.has-numbering').css('line-height'));

        
        
    }

    /*打赏页面隐藏与展示*/
    
    function dashangToggle() {
        $(".shang_box").fadeToggle();
        $(".hide_box").fadeToggle();
    }
    

</script>

<!--加入行号的高亮代码块样式-->

<!--自定义样式设置-->
<style>
    
    
    .nav {
        width: 542px;
    }
    .nav.fullscreen {
        margin-left: -542px;
    }
    .nav-left {
        width: 120px;
    }
    
    
    @media screen and (max-width: 1468px) {
        .nav {
            width: 492px;
        }
        .nav.fullscreen {
            margin-left: -492px;
        }
        .nav-left {
            width: 100px;
        }
    }
    
    
    @media screen and (max-width: 1024px) {
        .nav {
            width: 492px;
            margin-left: -492px
        }
        .nav.fullscreen {
            margin-left: 0;
        }
    }
    
    @media screen and (max-width: 426px) {
        .nav {
            width: 100%;
        }
        .nav-left {
            width: 100%;
        }
    }
    
    
    .nav-right .title-list nav a .post-title, .nav-right .title-list #local-search-result a .post-title {
        color: #383636;
    }
    
    
    .nav-right .title-list nav a .post-date, .nav-right .title-list #local-search-result a .post-date {
        color: #5e5e5f;
    }
    
    
    .nav-right nav a.hover, #local-search-result a.hover{
        background-color: #e2e0e0;
    }
    
    

    /*列表样式*/
    

    /* 背景图样式 */
    
    


    /*引用块样式*/
    

    /*文章列表背景图*/
    

    
</style>







</html>
